##### 问题8
1. 确定各流路径及链路容量：
    - 原有流（A、B、C、D ）与新流 E ，明确其路径中的链路及容量。如流 A 路径 R1 - R2 - R3 ，链路容量为 2/3、2/3 ；流 E 路径 R1 - R2 - R6 ，涉及链路 R1 - R2（容量 2/3 ）及 R2 - R6（容量需结合情况看，图未完整显示 ）。
2. 重新分配带宽：
    - 新流 E 会在共享链路（R1 - R2 、R2 - R6 ）上竞争带宽。原有在 R1 - R2 链路的流 A ，以及 R2 - R6 链路（若有流），其最小带宽会重新计算。
    - 算法会调整带宽，让五个流中最小带宽尽可能大。比如 R1 - R2 链路，之前按流 A 分配，加入 E 后，可能降低 A 和 E 在该链路的带宽，保证五个流新的最小带宽是尽可能高的值 ，即重新调整以最大化所有五个流中的最小带宽，在共享链路按需降低已有流带宽来适配 E 。 

最大 - 最小带宽分配会重新调整，让五个流里最小带宽尽可能大，可能降低共享链路上已有流的带宽，给新流 E 腾空间，最终让所有流里最小的那个带宽值，在调整后达到最大可能 。 
##### 问题10
###### 1.  additive increase additive decrease (AIAD，加性增 - 加性减)
- **收敛性**：拥塞窗口在无拥塞时，每轮往返时间（RTT）按固定量线性增加；检测到拥塞，也按固定量线性减少 。因调整是缓慢的线性增量，达到稳定状态（收敛）的过程慢，对网络变化响应迟缓 。 
- **稳定性**：窗口调整平缓，线性增减大幅降低了网络状态突变风险，稳定性好，适合优先保障稳定、对速度要求不高的网络场景 。 

###### 2. multiplicative increase additive decrease (MIAD，乘性增 - 加性减)
- **收敛性**：无拥塞时，窗口按大于1的常数乘性增长（指数级），相比AIAD能更快探索网络容量，收敛速度显著更快 。 
- **稳定性**：乘性增长可能使窗口突然大幅增大，超网络承载能力，引发更频繁拥塞，一定程度影响稳定性 ，是在速度与稳定间找平衡的策略，适合重视吞吐量和适应性的场景 。 

###### 3. multiplicative increase multiplicative decrease (MIMD，乘性增 - 乘性减)
- **收敛性**：窗口增减均为指数级，不管是网络空闲时的增长，还是拥塞时的减少，调整都快速且幅度大，收敛极快，能迅速适应网络波动 。 
- **稳定性**：指数级的大幅波动易让吞吐量剧烈振荡，在带宽、延迟多变环境中，可能超可用容量，引发反复拥塞周期，稳定性差 ，仅适合对响应速度要求极高、可接受一定不稳定的特定高速网络场景 。 

因此，AIAD 稳定但收敛慢；MIAD 收敛快于 AIAD ，但牺牲部分稳定性；MIMD 收敛极快，却因指数特性易让系统不稳定 ，需依网络对稳定和速度的需求选策略 。 
##### 问题11
UDP 存在的原因及仅让用户进程发送原始 IP 数据包不足的原因如下：
1. **端口识别需求**：IP 数据包仅含 IP 地址，指明目标机器，但无法区分机器上的不同用户进程 。UDP 借助目标端口号，让接收主机知晓数据包应交付给哪个用户进程，可实现同一主机上多个进程的数据包收发区分，像一栋公寓楼送信，UDP 的端口就像具体公寓号，原始 IP 包无此“公寓号”信息，无法精准投递到进程 。 
2. **协议栈分层适配**：网络采用分层模型，UDP 是适配该模型、构建在 IP 之上的极简协议，用于支持端口机制 。若仅用原始 IP 包，同一 IP 地址通常只能有一个专用监听套接字，无法满足同一主机上不同应用（“目的地”）的通信需求，有了 UDP 等带端口的协议，才能让多应用共存通信 。 
3. **端到端校验支持**：IP 数据包的校验和通常仅覆盖首部，数据的错误检测依赖链路层，并非端到端 。UDP（和 TCP ）会对数据进行端到端校验和检查，能一定程度保障数据传输的完整性，原始 IP 包做不到这一点 。 
4. **实际应用刚需**：像 DNS 默认用 UDP ，QUIC、HTTP/3 推动网络往 UDP 迁移 。若没有 UDP ，诸多依赖其特性（如低开销、快速传输 ）的应用无法良好运行，且 TCP 因演进困难，也需要 UDP 来补充适配不同场景 。 
##### 问题18
TCP最小MTU（含TCP和IP开销，不含数据链路层开销）的总大小计算如下：  

1. **IP头部最小长度**：20字节（无选项时）。  
2. **TCP头部最小长度**：20字节（无选项时）。  

将两者相加，总开销为：  
\[
20 \text{字节（IP头部）} + 20 \text{字节（TCP头部）} = 40 \text{字节}
\]  
##### 问题19
TCP 仍需处理数据到达顺序错误的问题，因为：  

###### 1. **IP 分片与 TCP 段的关系**
- **IP 分片的作用范围**：IP 层的分片和重组仅针对单个 IP 数据包。例如，一个 TCP 段若被分片为多个 IP 数据包，这些分片会携带相同的 **IP 标识符**和 **分片偏移量**，目标主机的 IP 层可将其重组为完整的 TCP 段。  
- **TCP 段的独立性**：不同的 TCP 段会被封装在不同的 IP 数据包中。由于 IP 是无连接协议，这些数据包可能经不同路径传输，导致到达目标的顺序混乱（如 TCP 段 2 的 IP 包先于段 1 的包到达）。  


###### 2. **IP 不保证数据包顺序**
- IP 层仅负责单个数据包的分片重组，不保证多个 IP 数据包的交付顺序。例如：  
  - TCP 段 1 被分片为 IP 包 A1、A2；  
  - TCP 段 2 被分片为 IP 包 B1、B2；  
  - 若包 B1 先于 A1 到达，IP 层重组后，TCP 段 2 会先于段 1 被交付给 TCP 层，导致数据顺序错误。  


###### 3. **TCP 依赖序列号处理乱序**
- TCP 通过 **序列号（Sequence Number）** 为每个字节编号，接收端根据序列号排序数据。即使 IP 层重组了单个段的分片，但不同段的 IP 包可能乱序，TCP 必须重新排列这些段以恢复正确顺序。  
- 例如：TCP 段 1（序列号 1-1000）和段 2（序列号 1001-2000）的 IP 包乱序到达，TCP 接收端会缓存段 2，等待段 1 到达后再按序组装数据。  


IP 层的分片重组仅解决单个 TCP 段内部的分片顺序问题，但无法避免不同 TCP 段的 IP 包乱序。因此，TCP 必须依赖自身的序列号机制处理数据顺序，确保应用层接收的数据流有序。
##### 问题21
在TCP协议中，两个端口之间**无法同时建立多个TCP连接**，因为：
###### 1. **TCP连接的唯一性由“五元组”确定**  
TCP连接的唯一性由**五元组**标识，包括：  
- 源IP地址、源端口号  
- 目标IP地址、目标端口号  
- 传输层协议（TCP）  

当主机1的端口`p`与主机2的端口`q`建立连接时，五元组中的四个要素（源/目标IP、源/目标端口）已固定。若尝试建立第二个连接，这四个要素完全相同，TCP协议会认为是同一个连接，因此无法创建新连接。  


###### 2. **案例说明**  
假设：  
- 主机1的IP为`A`，端口为`p`；  
- 主机2的IP为`B`，端口为`q`。  

第一个连接的五元组为：`(A, p, B, q, TCP)`。  
若试图建立第二个连接，其五元组仍为`(A, p, B, q, TCP)`，与第一个连接完全重复，因此系统会拒绝创建新连接。  


###### 3. **例外情况：同一主机的不同端口**  
若想在两台主机间建立多个TCP连接，需至少改变五元组中的一个要素。例如：  
- 主机1使用不同的源端口（如`p1`和`p2`）与主机2的`q`端口建立连接，此时五元组中的源端口不同，可形成多个连接。  

仅当主机1的端口`p`和主机2的端口`q`之间的五元组唯一时，才能建立一个TCP连接。由于两个端口的组合无法改变五元组中的IP和端口信息，**无法同时创建多个TCP连接**。
##### 问题22
TCP 报头中确认字段（32 位 acknowledgement field ）和 ACK 标志位（ACK bit ）作用不同，ACK 标志位有实际意义，因为：
1. **字段功能差异**：
    - 32 位确认号字段，用于告知对端期望接收的下一个字节序列号，明确数据接收的进度，是对数据序号的“数值确认” 。
    - ACK 标志位是控制位，用于“开关确认功能” ，只有该位被置 1 时，确认号字段里的数值才有效，起到标识确认信息是否存在的作用 。 
2. **协议逻辑需求**：在 TCP 连接建立、断开等阶段，或一些控制报文（如 SYN、FIN 报文 ）里，即便还未涉及数据序号确认，也需用 ACK 标志位传递“确认”的控制意图。比如三次握手时，第二次握手的 SYN + ACK 报文，ACK 位置 1 ，配合确认号，能清晰表达“确认连接请求，同时告知自身初始序列号” ，若没有 ACK 位，仅靠确认号字段，无法区分是正常数据确认，还是连接建立等阶段的控制确认 。 
3. **简洁性与明确性**：用单独 1 位的 ACK 标志位，能简洁、清晰地标识确认功能是否激活，让接收方快速判断确认号字段是否需要解析，相比仅通过确认号字段隐含判断，逻辑更简单直接，降低协议解析的复杂度和歧义 。 

所以，ACK 标志位并非冗余，对完善 TCP 协议的控制逻辑、明确确认功能状态至关重要，和 32 位确认号字段协同，保障 TCP 可靠传输等机制有序运行 。 
##### 问题25
###### 1. 关键参数梳理  
- 往返时延（RTT）：\(10\ \text{ms}\)（每轮 RTT 后，拥塞窗口翻倍）  
- 接收窗口（Receive Window）：\(24\ \text{KB}\)（目标需达到的窗口大小）  
- 最大段大小（MSS）：\(2\ \text{KB}\)（慢启动初始窗口为 \(1 \times \text{MSS}\) ）  


###### 2. 慢启动的窗口增长规则  
慢启动的核心逻辑是：**每经过 1 个 RTT，拥塞窗口 \(cwnd\) 翻倍**（只要未达到接收窗口或触发拥塞）。初始时，\(cwnd = 1 \times \text{MSS} = 2\ \text{KB}\) 。  


###### 3. 逐轮 RTT 的窗口增长过程  
我们需要跟踪每轮 RTT 后 \(cwnd\) 的大小，直到 \(cwnd \geq 24\ \text{KB}\) ：  

| 经过的 RTT 轮数 | 拥塞窗口 \(cwnd\) 大小（KB） | 说明                     |  
|----------------|-----------------------------|--------------------------|  
| 0（初始）      | \(2\)                       | 初始窗口为 \(1 \times \text{MSS}\) |  
| 1              | \(4\)                       | 第 1 轮 RTT 后，\(cwnd\) 翻倍 |  
| 2              | \(8\)                       | 第 2 轮 RTT 后，\(cwnd\) 翻倍 |  
| 3              | \(16\)                      | 第 3 轮 RTT 后，\(cwnd\) 翻倍 |  
| 4              | \(24\)                      | 第 4 轮 RTT 中，\(cwnd\) 增长到接收窗口大小 |  


###### 4. 计算总时间  
每轮 RTT 耗时 \(10\ \text{ms}\) ，共需 **4 轮 RTT** 使 \(cwnd\) 达到 \(24\ \text{KB}\) 。因此：  
\[
\text{总时间} = 4 \times 10\ \text{ms} = 40\ \text{ms}
\]  

因此在无拥塞的情况下，需要 \(\boldsymbol{40\ \text{ms}}\) 才能发送首个完整的接收窗口数据。
##### 问题26
当 TCP 发生超时后，拥塞窗口（congestion window，cwnd ）和慢启动阈值（slow - start threshold，ssthresh ）的变化遵循特定规则，以下是计算过程：

###### 1. 超时后的初始设置
当发生超时，TCP 会将慢启动阈值（ssthresh ）设置为当前拥塞窗口的一半，同时将拥塞窗口重置为 1 个最大段大小（Maximum Segment Size，MSS ） 。
已知当前拥塞窗口为 18 KB，MSS 为 1 KB，所以：
    - 慢启动阈值 \(ssthresh=\frac{18}{2} = 9\) KB 。
    - 拥塞窗口 \(cwnd = 1\) KB（因为超时后进入慢启动阶段，初始拥塞窗口为 1 个 MSS ）。
 
###### 2. 四轮成功传输时拥塞窗口的增长
TCP 慢启动阶段，每一轮成功的传输（一个 RTT ），拥塞窗口会翻倍 。
    - **第一轮成功传输后**：\(cwnd = 1\times2 = 2\) KB（此时 \(2\) KB < \(ssthresh = 9\) KB ，处于慢启动阶段 ）。 
    - **第二轮成功传输后**：\(cwnd = 2\times2 = 4\) KB（仍小于慢启动阈值，继续慢启动 ）。 
    - **第三轮成功传输后**：\(cwnd = 4\times2 = 8\) KB（还是小于慢启动阈值 ）。 
    - **第四轮成功传输后**：\(cwnd = 8\times2 = 16\) KB（依旧小于慢启动阈值，慢启动持续 ）。 

经过四次成功传输突发后，拥塞窗口大小为 16 KB 。
##### 问题27
根据雅各布森（Jacobson）算法，RTT 估计值的更新公式为：  
\[
RTT_{\text{new}} = \alpha \times RTT_{\text{old}} + (1 - \alpha) \times RTT_{\text{sample}}
\]  
其中，\(\alpha = 0.9\)，初始 \(RTT_{\text{old}} = 30\ \text{ms}\)，需依次处理三个采样值：26 ms、32 ms、24 ms。  


###### 1. 第一次更新（采样值 26 ms）  
\[
RTT_{\text{new1}} = 0.9 \times 30 + 0.1 \times 26 = 27 + 2.6 = 29.6\ \text{ms}
\]  


###### 2. 第二次更新（采样值 32 ms）  
\[
RTT_{\text{new2}} = 0.9 \times 29.6 + 0.1 \times 32 = 26.64 + 3.2 = 29.84\ \text{ms}
\]  


###### 3. 第三次更新（采样值 24 ms）  
\[
RTT_{\text{new3}} = 0.9 \times 29.84 + 0.1 \times 24 = 26.856 + 2.4 = 29.256\ \text{ms}
\]  


**最终 RTT 估计值约为 29.26 ms**。
##### 问题28
###### 1. 计算最大吞吐量  
关键参数：  
- 发送窗口大小：65,535 字节（转换为比特：\(65535 \times 8 = 524280\) 比特）  
- 信道单向延迟：10 ms，往返时间（RTT）：\(2 \times 10 = 20\) ms（0.02 秒）  

原理：  
TCP 吞吐量受限于 **“窗口大小”** 和 **“带宽延迟积”** 中的较小值。当窗口大小小于带宽延迟积时，每轮 RTT 只能发送一个窗口的数据。  

计算：  
\[
\text{最大吞吐量} = \frac{\text{窗口大小（比特）}}{\text{RTT（秒）}} = \frac{524280}{0.02} = 26214000\ \text{bps} = 26.214\ \text{Mbps}
\]  


###### 2. 计算线路效率  
关键参数：  
- 信道带宽：1 Gbps（1000 Mbps）  

原理：  
效率 = （实际吞吐量 / 信道带宽）× 100%。  

计算：  
\[
\text{线路效率} = \frac{26.214\ \text{Mbps}}{1000\ \text{Mbps}} \times 100\% \approx 2.62\%
\]  
##### 补充题
当TCP发生超时后，拥塞控制机制会调整拥塞窗口（cwnd）和慢启动阈值（ssthresh），后续按慢启动和拥塞避免阶段逐步增长。以下是详细推导过程：  


1. 超时后的初始状态  
- **超时时刻拥塞窗口**：\(cwnd = 8\ \text{KB}\)  
- **慢启动阈值设置**：\(ssthresh = \frac{cwnd}{2} = \frac{8}{2} = 4\ \text{KB}\)  
- **重置拥塞窗口**：\(cwnd = 1\ \text{KB}\)（1个MSS，\(MSS=1\ \text{KB}\)）  


###### 2. 逐轮RTT的cwnd增长过程  
慢启动阶段（cwnd ≤ ssthresh）  
- **RTT 1**：\(cwnd = 1 \times 2 = 2\ \text{KB}\)（< 4 KB，继续慢启动）  
- **RTT 2**：\(cwnd = 2 \times 2 = 4\ \text{KB}\)（= ssthresh，转入拥塞避免）  

拥塞避免阶段（cwnd > ssthresh）  
每轮RTT中，\(cwnd\) 线性增加1个MSS（1 KB）：  
- **RTT 3**：\(cwnd = 4 + 1 = 5\ \text{KB}\)  
- **RTT 4**：\(cwnd = 5 + 1 = 6\ \text{KB}\)  
- **RTT 5**：\(cwnd = 6 + 1 = 7\ \text{KB}\)  
- **RTT 6**：\(cwnd = 7 + 1 = 8\ \text{KB}\)  
- **RTT 7**：\(cwnd = 8 + 1 = 9\ \text{KB}\)  
- **RTT 8**：\(cwnd = 9 + 1 = 10\ \text{KB}\)（此时 \(cwnd = \text{接收窗口}=10\ \text{KB}\)）  
- **RTT 9**：\(cwnd = 10 + 1 = 11\ \text{KB}\)（发送窗口受限于接收窗口，仍为10 KB）  
- **RTT 10**：\(cwnd = 11 + 1 = 12\ \text{KB}\)（发送窗口仍为10 KB）  


###### 3. 发送窗口的确定  
发送窗口取 \(cwnd\) 和接收窗口（\(10\ \text{KB}\)）的较小值：  
- 从 **RTT 8** 开始，\(cwnd \geq 10\ \text{KB}\)，发送窗口被限制为 \(10\ \text{KB}\)。  

**经过10个RTT后，甲的发送窗口为10 KB**。