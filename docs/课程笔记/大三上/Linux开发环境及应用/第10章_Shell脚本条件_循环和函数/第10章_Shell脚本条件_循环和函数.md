# 第10章 Shell脚本：条件、循环和函数

## 一、Shell中的逻辑判断

### 1. 条件判断的基本依据

在 Shell 脚本中，条件判断的核心机制是**命令的执行结果状态**。每一条命令执行完毕后，都会返回一个称为“返回码”（也称退出状态、exit status）的整数值，用于指示该命令是否成功执行。

- **返回码为 `0`**：表示命令**成功执行**。
- **返回码为非 `0`（1~255）**：表示命令**执行失败或出现异常**。

这一机制源于 Unix/Linux 系统的设计哲学：“一切皆文件，一切皆进程”，而进程终止时必须提供一个状态码。在 C 语言程序中，这个状态码通常由 `main()` 函数的 `return` 语句指定，或通过调用 `exit(code)` 显式设置。因此，在 Shell 中，任何可执行命令（包括脚本、二进制程序、内置命令等）都可以作为条件判断的依据。

> **注意**：如果 C 程序的 `main()` 函数未显式 `return` 一个值，其返回码将是未定义的随机值，**不能用于可靠的条件判断**。

---

### 2. Shell内部变量 `$?`

Shell 提供了一个特殊的内部变量 `$?`，用于**获取上一条命令的返回码**。这是进行条件判断和调试的重要工具。

- 示例：
  ```bash
  ls /nonexistent
  echo $?   # 输出非0（如2），表示命令失败
  ls /
  echo $?   # 输出0，表示成功
  ```

- **在管道（pipeline）中的行为**：
  当多个命令通过管道连接时（如 `cmd1 | cmd2 | cmd3`），`$?` 的值是**最后一个命令**（即 `cmd3`）的返回码，而非整个管道的成功与否。
  
  > PPT 中明确指出：“用管道线连接在一起的若干命令，进行条件判断时以最后一个命令执行的返回码为准。”

  若需获取管道中任意命令的返回状态，可使用 Bash 的 `PIPESTATUS` 数组（但此内容超出本章范围）。

---

### 3. 复合逻辑（短路求值）

Shell 支持通过逻辑操作符 `&&` 和 `||` 将多个命令组合成复合条件，其执行遵循**短路求值（short-circuit evaluation）**原则：

- **`cmd1 && cmd2`**  
  - 先执行 `cmd1`；
  - 若 `cmd1` 成功（返回码为 0），则**继续执行** `cmd2`；
  - 若 `cmd1` 失败，则**跳过** `cmd2`。
  - 常用于“前置条件满足时才执行后续操作”。

- **`cmd1 || cmd2`**  
  - 先执行 `cmd1`；
  - 若 `cmd1` 失败（返回码非 0），则**执行** `cmd2`；
  - 若 `cmd1` 成功，则**跳过** `cmd2`。
  - 常用于“失败时提供备选方案或错误提示”。

- PPT 中给出的典型示例：
  ```bash
  ls -d xdir >/dev/null && echo FOUND      # 若目录存在，输出 FOUND
  ls -d ydir >/dev/null 2>&1 || echo No ydir  # 若目录不存在，输出 No ydir
  ```
  其中 `>/dev/null` 和 `2>&1` 用于屏蔽标准输出和错误输出，使判断更干净。

---

### 4. 命令 `true` 与 `false`

为了便于编写逻辑清晰的脚本，Shell 提供了两个特殊命令：

- **`/bin/true`**  
  - 功能：不做任何操作，**始终返回 0**。
  - 用途：在需要“占位成功”或构造无限循环时使用。
    ```bash
    while true; do ...; done
    ```

- **`/bin/false`**  
  - 功能：不做任何操作，**始终返回非 0（通常为 1）**。
  - 用途：用于强制失败、测试错误处理逻辑等。

- **性能优化**：  
  PPT 特别指出，许多现代 Shell（如 Bash）将 `true` 和 `false` 实现为**内部命令（built-in）**，避免了启动外部进程的开销，从而提升脚本执行效率。

---

### 5. 自定义程序用作条件判断

用户可以编写自己的 C 程序（或其他语言程序），并将其作为 Shell 条件判断的一部分。关键在于**正确设置程序的退出状态**。

- 在 C 语言中，可通过以下方式控制返回码：
  ```c
  int main(void) {
      // 成功
      return 0;
      // 或
      exit(0);
  }
  ```
  返回码范围应为 **0 到 255**（超出部分会被截断）。

- Shell 脚本中直接调用该程序即可参与逻辑判断：
  ```bash
  ./my_program && echo "Success" || echo "Failed"
  ```

- **重要警告**（来自 PPT）：
  > “如果代码中 main() 函数没有 return 一个确定的值，返回码就是随机值，不可用来做条件判断。”

  这是因为 C 标准未规定无返回值 `main` 的行为，实际返回值可能为栈上的垃圾数据，导致 Shell 判断结果不可预测。

因此，在将自定义程序用于 Shell 条件判断时，**必须显式返回确定的状态码**。

## 二、test 及 `[` 命令

### 1. 命令 `test` 与 `[`

在 Shell 脚本中，`test` 是一个用于**条件测试**的核心命令，它根据给定的表达式返回成功（0）或失败（非 0）。为了提升脚本可读性，Shell 提供了等价语法 `[ ... ]`，其中 `[` 实际上是 `test` 命令的一个别名（通常为符号链接或内置实现）。

- **功能完全相同**：
  ```bash
  test -r /etc/motd
  [ -r /etc/motd ]
  ```
  两者效果一致，均检测 `/etc/motd` 是否可读。

- **关键语法要求**：
  - 使用 `[` 时，**右括号 `]` 必须作为单独的参数存在**，即其前后必须有空格。
  - 错误示例：`[ -r file]`（缺少空格）会导致语法错误。
  - 正确示例：`[ -r file ]`

> PPT 强调：“`[` 就是 `test` 的另一个名字”，因此所有 `test` 支持的操作，`[ ]` 同样支持。

---

### 2. 文件特性检测

`test` 和 `[ ]` 可对文件系统对象进行多种属性判断，常用于脚本中验证路径是否存在、是否具备特定权限等。PPT 中列出的主要文件测试选项如下：

| 选项 | 含义说明 |
|------|----------|
| `-f file` | 判断 `file` 是否为**普通文件**（非目录、设备等） |
| `-d file` | 判断 `file` 是否为**目录** |
| `-r file` | 判断当前用户对 `file` 是否**可读** |
| `-w file` | 判断当前用户对 `file` 是否**可写** |
| `-x file` | 判断当前用户对 `file` 是否**可执行**（对目录表示可进入） |
| `-s file` | 判断 `file` 是否**非空**（即大小 > 0 字节） |

- 示例应用：
  ```bash
  [ -d /tmp ] && echo "Temporary directory exists"
  [ -s logfile ] || echo "Log file is empty or missing"
  ```

> 注意：若文件路径包含空格或特殊字符，应使用引号包裹变量，如 `[ -f "$filename" ]`，以避免词法分割错误。

---

### 3. 字符串比较

`test` 支持对字符串内容进行相等性或空值判断，这是处理用户输入、环境变量等场景的基础。

- **基本操作符**：
  - `str1 = str2`：判断两个字符串**相等**
  - `str1 != str2`：判断两个字符串**不相等**

- **重要语法规则**：
  - 操作符 `=` 和 `!=` **两侧必须有空格**，否则 Shell 会将其视为单个单词，导致语法错误。
  - 推荐将变量用双引号包裹，防止空值或含空格字符串引发异常。

- 典型示例（来自 PPT）：
  ```bash
  [ "$a" = "" ] && echo "empty string"
  test $# = 0 && echo "No argument"
  ```
  其中 `$#` 表示传入脚本的参数个数，`test $# = 0` 用于判断是否未提供任何参数。

> 注意：在部分 Shell（如 Bash）中，也可使用 `==` 代替 `=`，但 `=` 是 POSIX 标准，更具可移植性。

---

### 4. 整数比较

Shell 不直接支持数值运算中的 `<`、`>` 等符号用于条件判断（这些会被解释为重定向），而是通过专用整数比较操作符实现。

| 运算符 | 含义         | 示例说明 |
|--------|--------------|----------|
| `-eq`  | 等于（equal）| `5 -eq 5` → true |
| `-ne`  | 不等于（not equal）| `3 -ne 4` → true |
| `-gt`  | 大于（greater than）| `10 -gt 5` → true |
| `-ge`  | 大于等于     | `5 -ge 5` → true |
| `-lt`  | 小于（less than）| `2 -lt 3` → true |
| `-le`  | 小于等于     | `4 -le 4` → true |

- **典型应用场景**（PPT 示例）：
  ```bash
  test $(ls | wc -l) -ge 100 && echo "Too many files"
  ```
  此处通过 `ls | wc -l` 获取当前目录文件数量，并判断是否 ≥100。

> 注意：整数比较操作符**仅适用于整数**，若用于字符串（如 `"abc"`），行为未定义或报错。

---

### 5. 复合条件

当需要组合多个测试条件时，`test` 和 `[ ]` 支持使用逻辑运算符构建复合表达式。

- **逻辑操作符**：
  - `! expr`：逻辑“非”，取反表达式结果
  - `expr1 -a expr2`：逻辑“与”（AND），两者都为真才为真
  - `expr1 -o expr2`：逻辑“或”（OR），任一为真即为真

- **PPT 给出的关键示例**：
  ```bash
  [ ! -d $cmd -a -x $cmd ] && $cmd
  ```
  含义：如果 `$cmd` **不是目录** **并且** **可执行**，则执行该命令。这常用于安全地运行外部程序，避免误将目录当作命令执行。

- **严格语法要求**：
  - 所有操作符（包括 `!`、`-a`、`-o`）和操作数之间**必须有空格**。
  - 错误示例：`[! -d file]` 或 `[ -d file-a -x file ]` 均非法。
  - 正确写法：`[ ! -d "$file" -a -x "$file" ]`

> 注意：虽然 `-a` 和 `-o` 在传统 Shell 中广泛使用，但在现代脚本中更推荐使用 `[[ ]]`（Bash 扩展）或通过多个 `[ ]` 结合 `&&`/`||` 实现，以提高可读性和避免优先级歧义。但本章 PPT 仍聚焦于 POSIX 兼容的 `[ ]` 与 `-a`/`-o` 用法。

## 三、命令组合

### 1. 两种方式：`{ }` 与 `( )`

在 Shell 脚本中，有时需要将多个命令**作为一个逻辑单元**进行处理，例如将它们的输出整体重定向到一个文件、通过管道传递给另一个命令，或在条件语句中统一执行。为此，Shell 提供了两种命令组合结构：

- **花括号 `{ }`**：用于在当前 Shell 环境中将一组命令组合成一个复合命令。
- **圆括号 `( )`**：用于在子 Shell（subshell）中执行一组命令。

两者都能实现“命令打包”，但在**执行环境和副作用**上存在本质区别。

---

### 2. 语义差异

这是理解 `{ }` 与 `( )` 的核心所在：

- **`{ list; }` —— 在当前 Shell 中执行**  
  - 所有命令在**当前 Shell 进程**中顺序执行。
  - 对变量、工作目录、环境等的修改**会保留到后续脚本中**。
  - 适用于需要**影响当前执行环境**的场景。
  
  示例：
  ```bash
  x=0
  { x=5; echo "Inside: $x"; }
  echo "Outside: $x"   # 输出 Outside: 5
  ```

- **`( list )` —— 在子 Shell 中执行**  
  - Shell 会**fork 一个子进程**来执行括号内的命令。
  - 子 Shell 中对变量、路径等的修改**不会影响父 Shell**。
  - 常用于隔离副作用、并行处理或临时环境操作。
  
  示例：
  ```bash
  x=0
  ( x=5; echo "Inside: $x" )
  echo "Outside: $x"   # 输出 Outside: 0
  ```

> PPT 明确指出：“花括号方式是在当前 shell 中执行；圆括号方式是在子 shell 中执行。”这一区别决定了何时使用哪种结构。

---

### 3. 语法差异

尽管功能相似，但两者的语法要求不同，违反会导致语法错误：

- **花括号 `{ }` 的严格语法**：
  - 左花括号 `{` 后**必须有一个空格**（因为 `{` 是保留字，不是元字符）。
  - 命令列表的**最后一个命令后必须加分号 `;` 或换行**。
  - 右花括号 `}` 必须单独作为一个词（前后有空格）。
  
  正确示例：
  ```bash
  { echo "Hello"; date; }
  { cd /tmp; pwd; } > output.txt
  ```
  
  错误示例：
  ```bash
  {echo "Hello"}        # 缺少空格，Shell 会尝试执行名为 "{echo" 的命令
  { echo "Hello" }      # 缺少末尾分号（在单行中）
  ```

- **圆括号 `( )` 的宽松语法**：
  - 圆括号是 Shell 的**元字符（metacharacters）**，无需额外空格。
  - 不强制要求末尾分号（但建议保持风格一致）。
  
  正确示例：
  ```bash
  (echo "Hello"; date)
  (cd /tmp; pwd) | cat
  ```

- **PPT 提供的典型用例**：
  ```bash
  { ls -l; ps; } | more
  (ls -l; ps) | more
  ```
  两者都能将 `ls` 和 `ps` 的输出合并后传给 `more`，但前者在当前 Shell 执行，后者在子 Shell 执行。若命令中包含 `cd` 或变量赋值，则行为将显著不同。

> **总结**：当需要**保留副作用**（如变量修改）时，用 `{ }`；当希望**隔离环境**或避免污染当前 Shell 时，用 `( )`。同时务必遵守各自的语法规则。

## 四、条件分支结构

### 1. `if` 结构

`if` 是 Shell 脚本中最基础的条件控制结构，用于根据命令的返回状态（exit status）决定执行哪一段代码。

- **基本语法**（严格遵循 PPT 所示格式）：
  ```bash
  if condition; then
    commands
  elif condition; then
    commands
  else
    commands
  fi
  ```
  - `condition` 可以是任意命令、`test` 表达式、`[ ]` 测试或复合逻辑（如 `cmd1 && cmd2`）。
  - `then` 是关键字，表示条件为真时开始执行后续命令。
  - `elif`（else if）和 `else` 为可选部分，支持多级判断。
  - 必须以 `fi`（`if` 的反写）结束整个结构。

- **换行与分号规则**（PPT 强调的关键细节）：
  - `then` **可以与 `if` 写在同一行**，但必须用分号 `;` 分隔：
    ```bash
    if [ -f file ]; then echo "Exists"; fi
    ```
  - **不能直接将 `if` 和 `then` 连写**（如 `if [ -f file ] then`），这会导致语法错误。
  - 同理，`elif` 后也需跟 `; then` 或换行后写 `then`。

- **典型应用场景**（结合前文知识）：
  ```bash
  if [ $# -eq 0 ]; then
    echo "No arguments provided."
  elif [ ! -r "$1" ]; then
    echo "File not readable."
  else
    cat "$1"
  fi
  ```

> 注意：`if` 判断的是**命令是否成功（返回码为 0）**，而非“表达式真假”，这是 Shell 与其他编程语言的重要区别。

---

### 2. `case` 结构（多分支）

当需要根据某个变量的值匹配多个可能选项时，`case` 结构比多个 `if-elif` 更清晰、高效。

- **标准语法**（完全依据 PPT）：
  ```bash
  case word in
    pattern1) commands ;;
    pattern2 | pattern3) commands ;;
    *) default commands ;;
  esac
  ```
  - `word` 通常是变量（如 `$1`、`$option`），会被依次与各 `pattern` 匹配。
  - 每个分支以 `)` 结束模式定义，以 `;;` 终止命令序列。
  - 支持**多模式合并**：使用 `|` 分隔多个匹配模式（注意两侧无空格或可有空格，取决于 Shell 实现，但 PPT 示例中无空格）。
  - `*)` 是通配默认分支，相当于 `else`。

- **模式匹配规则**：
  - 使用 **Shell 通配符（globbing）**，而非正则表达式。
    - `*`：匹配任意字符（包括空）
    - `?`：匹配单个字符
    - `[abc]`：匹配括号内任一字符
  - 不支持正则中的 `+`、`{n,m}` 等语法。

- **`;;` 的强制性**：
  - PPT 特别指出：`;;` 是**不可省略的终止符**，不能用空行、`#` 注释或换行代替。
  - 若省略 `;;`，Shell 会继续执行后续分支的命令（类似 C 语言的“fall-through”），通常不是预期行为。

- **实际示例**（来自常见脚本实践）：
  ```bash
  case "$1" in
    start)   echo "Starting service...";;
    stop)    echo "Stopping service...";;
    restart|reload) echo "Reloading...";;
    *)       echo "Usage: $0 {start|stop|restart}"; exit 1;;
  esac
  ```

---

### 3. 注释

Shell 脚本中的注释用于解释代码逻辑、禁用某行命令或临时调试，其规则简单但重要。

- **基本规则**：
  - 使用 `#` 开头，从 `#` 起到**行尾**的所有内容均被 Shell 忽略。
  - 注释可出现在行首，也可跟在命令之后（作为行尾注释）。

- **PPT 特别说明**：
  > “若 `#` 出现在单词开头，则整行注释生效。”

  这句话意在强调：只要 `#` 不是字符串或变量的一部分，且未被引号包裹，它就会触发整行注释。例如：
  ```bash
  # This is a full-line comment
  echo "Hello"  # This is an end-of-line comment
  echo "# This is NOT a comment, it's part of the string"
  ```

- **注意事项**：
  - 注释**不能嵌套**。
  - 在 `[ ]` 或 `test` 中，`#` 不具备注释功能（会被视为普通字符）。
  - 避免在命令中间插入 `#`，除非你确实想注释掉后面的内容。

> 良好的注释习惯能显著提升 Shell 脚本的可读性和可维护性，尤其在复杂的条件和循环结构中。

## 五、表达式运算（`expr` 命令）

### 1. 表达式计算背景

Shell 脚本语言本身是一种**无类型（typeless）的解释性命令语言**，其变量本质上都是字符串，不具备原生的数值类型或正则表达式引擎。因此，Shell **无法直接进行算术运算、数值比较或模式提取**。

为弥补这一缺陷，传统 Unix 系统提供了外部命令 `/usr/bin/expr`，用于在 Shell 脚本中执行基本的表达式求值。该命令接收一系列参数构成的表达式，解析后输出计算结果，并通过返回码指示成功与否。

- **性能优化**：  
  PPT 指出，许多现代 Shell（如 Bash、Dash）将 `expr` 实现为**内部命令（built-in）** 或提供等效的 `$((...))` 算术扩展，以避免频繁调用外部程序带来的性能开销。但在兼容性要求高的脚本中，`expr` 仍是 POSIX 标准的一部分，广泛使用。

---

### 2. `expr` 支持的运算类型

`expr` 支持四类核心运算，涵盖基础编程所需：

#### （1）算术运算
- 支持整数运算（不支持浮点）：
  - `+`：加法
  - `-`：减法
  - `*`：乘法
  - `/`：整除（向零取整）
  - `%`：取模（余数）

#### （2）关系运算（比较）
- 返回结果为 **1（真）或 0（假）**：
  - `=`：等于
  - `!=`：不等于
  - `>`：大于
  - `>=`：大于等于
  - `<`：小于
  - `<=`：小于等于

> 注意：这些符号在 Shell 中有特殊含义（如 `>` 是重定向），因此在 `expr` 中使用时必须**加空格并可能需转义**。

#### （3）逻辑运算
- `|`：逻辑或（OR）—— 若左侧非零则返回左侧，否则返回右侧
- `&`：逻辑与（AND）—— 若左侧为零则返回 0，否则返回右侧

> ⚠️ 重要区别：  
> `expr` 使用的是 **单字符 `|` 和 `&`**，**不是** Shell 的 `||` 和 `&&`。后者是命令组合操作符，而前者是 `expr` 内部的逻辑运算符。

#### （4）正则表达式匹配
- 语法：`expr string : pattern`
- 功能：将 `string` 与 `pattern` 进行**锚定匹配**（隐含前缀 `^`）
- 若 `pattern` 包含 `\(...\)` 捕获组，则返回**第一个捕获组的内容**；否则返回**匹配的字符数**。

---

### 3. 使用注意事项

尽管 `expr` 功能强大，但其语法极为严格，常见错误多源于格式不当：

#### （1）运算符两侧必须有空格
- 错误：`expr 2+3` → 被视为单个词，报错
- 正确：`expr 2 + 3`

#### （2）特殊字符必须转义
- Shell 会先解析命令行，因此 `*`、`(`、`)`、`>` 等元字符需用反斜杠 `\` 转义，防止被 Shell 提前处理。
- 示例（来自 PPT）：
  ```bash
  expr $a \* \( $b + $c \)
  ```
  - `\*` 防止被解释为文件通配符
  - `\(` 和 `\)` 防止被 Shell 当作子命令分组

#### （3）变量建议用双引号包裹（虽非强制，但更安全）
- 尤其当变量可能为空或含空格时，避免词法分割错误。

#### （4）返回值 vs 输出值
- `expr` 的**标准输出**是计算结果（如 `5`）
- **返回码**：若表达式无效（如除零、语法错误），返回非 0；否则返回 0
- 因此，通常通过命令替换获取结果：
  ```bash
  result=$(expr $a + $b)
  ```

---

### 4. 正则表达式应用

`expr` 的正则功能虽简单，但在无 `grep -o` 或 `sed` 的老系统中非常实用，尤其用于**从字符串中提取特定字段**。

- **基本用法**：
  ```bash
  expr "hello123" : 'hello\([0-9]*\)'
  # 输出：123
  ```

- **PPT 典型示例：从 ping 输出提取 RTT 时间**
  假设 `ping` 输出一行如下：
  ```
  64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.23 ms
  ```
  可使用：
  ```bash
  line="64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.23 ms"
  rtt=$(expr "$line" : '.*time=\([0-9.]*\) ms')
  echo $rtt   # 输出：1.23
  ```

- **关键点**：
  - `.*` 匹配任意前缀
  - `\(...\)` 定义捕获组，`expr` 只返回该部分
  - 模式末尾可包含字面量（如 `ms`）以提高匹配精度

> 注意：`expr` 的正则为**基本正则表达式（BRE）**，不支持 `+`、`?`、`{n}` 等扩展语法，且**必须锚定开头**（隐含 `^`）。

---

综上，`expr` 是早期 Shell 脚本实现表达式运算的重要工具。尽管现代 Shell 已提供 `$((...))`、`[[ ]]`、`let` 等更高效机制，但在编写可移植 POSIX 脚本时，`expr` 仍具有不可替代的价值。正确掌握其语法规则和转义要求，是编写健壮 Shell 脚本的关键一环。

## 六、内部命令 `eval`

### 1. 功能

`eval` 是 Shell 的一个**内置命令（built-in）**，其核心功能是：**将传入的参数拼接成一个字符串，并将其作为 Shell 命令重新解析和执行**。这使得 Shell 脚本具备了“运行时动态构造并执行命令”的能力，体现了典型的**解释型语言特性**——即“数据可以被当作代码执行”。

- **工作原理**：
  ```bash
  eval "command arg1 arg2"
  ```
  等价于直接执行：
  ```bash
  command arg1 arg2
  ```
  但关键区别在于：`command arg1 arg2` 可以是**由变量、表达式或其他逻辑动态生成的字符串**。

- **典型用途场景**：
  - 构造包含变量名的赋值语句（如间接变量引用）
  - 动态拼接复杂命令（如带条件的重定向或管道）
  - 实现配置驱动的命令执行（如从文件读取命令模板）

> PPT 强调：`eval` 实现了“**数据即代码**”（data as code）的编程范式，这是 Shell 作为脚本语言灵活性的重要体现。

---

### 2. 应用示例（`flow.sh`）

PPT 中提到的 `flow.sh` 脚本展示了 `eval` 在**自动化任务调度与重试机制**中的实际应用：

- **场景描述**：
  - 每天 23:00 执行网页抓取任务（如 `wget` 或 `curl`）
  - 若抓取失败（命令返回非 0），则等待 10 分钟后重试
  - 最多重试若干次，或直到成功

- **`eval` 的作用**：
  由于要执行的命令可能包含复杂的选项、URL、输出路径等，且这些内容可能来自配置变量或用户输入，直接写死命令不灵活。通过 `eval`，可将命令构造成字符串后动态执行：

  ```bash
  # 假设 cmd 是从配置中读取的命令字符串
  cmd='wget -O /data/page.html http://example.com'
  
  attempt=0
  max_attempts=3
  while [ $attempt -lt $max_attempts ]; do
    if eval "$cmd"; then
      echo "Success!"
      break
    else
      attempt=$((attempt + 1))
      echo "Attempt $attempt failed. Retrying in 10 minutes..."
      sleep 600
    fi
  done
  ```

- **优势**：
  - 命令内容可外部化（如从文件或环境变量读取）
  - 支持在运行时根据条件动态修改命令（如添加代理、重试头等）
  - 便于日志记录和调试（可先打印 `$cmd` 再 `eval`）

> ⚠️ **安全警告**：  
> `eval` 若处理不可信输入（如用户输入、网络数据），极易导致**命令注入漏洞**。例如：
> ```bash
> cmd="rm -rf /"   # 恶意输入
> eval "$cmd"      # 系统被删除！
> ```
> 因此，**仅在完全可控的数据源上使用 `eval`**，否则应避免。

---

### 3. 执行轨迹调试

由于 `eval` 执行的是动态生成的命令，其实际行为在代码中并不直观，给调试带来困难。为此，Shell 提供了**执行跟踪（execution tracing）** 功能。

- **启用方式**：
  ```bash
  sh -x script.sh
  # 或在脚本内部加入：set -x
  ```

- **对 `eval` 的效果**：
  - Shell 会**先显示 `eval` 展开后的完整命令**，再执行它。
  - 这使得开发者能清晰看到“到底执行了什么”，极大提升调试效率。

- **示例**：
  ```bash
  # script.sh
  url="http://example.com"
  cmd="curl -s '$url'"
  eval $cmd
  ```
  运行 `sh -x script.sh` 输出：
  ```
  + url=http://example.com
  + cmd='curl -s '\''http://example.com'\'''
  + eval 'curl -s '\''http://example.com'\'''
  ++ curl -s 'http://example.com'
  ```

  可见，`eval` 行被展开为实际执行的 `curl` 命令，便于验证引号、变量替换是否正确。

> PPT 特别指出：使用 `sh -x` 是理解 `eval` 行为的关键手段，尤其在命令包含空格、引号或特殊字符时。

---

综上，`eval` 是 Shell 中强大但需谨慎使用的工具。它赋予脚本高度的动态性，适用于配置驱动、命令模板、间接引用等高级场景，但必须严格控制输入来源，并配合 `sh -x` 等调试手段确保安全性与正确性。

## 七、循环结构

### 1. `while` 循环

`while` 循环是 Shell 中用于**条件持续执行**的核心控制结构，其特点是：**先判断条件，再决定是否执行循环体**。只要条件命令返回成功（退出状态为 0），循环就会反复执行。

- **标准语法**（严格遵循 PPT 格式）：
  ```bash
  while condition; do
    commands
  done
  ```
  - `condition` 可以是任意命令、`test` 表达式、`[ ]` 测试或复合逻辑。
  - `do` 是关键字，可与 `while` 同行（需加分号）或另起一行。
  - 循环体在 `do` 和 `done` 之间。

- **典型应用场景**（PPT 所列示例）：
  - **倒计时**：
    ```bash
    i=10
    while [ $i -gt 0 ]; do
      echo "$i..."
      i=$((i - 1))
      sleep 1
    done
    echo "Go!"
    ```
  - **等待文件消失（轮询机制）**：
    ```bash
    while test -r lockfile; do
      sleep 5
    done
    echo "Lock released, proceeding."
    ```
    此模式常用于进程间同步，如等待另一个程序释放锁文件。
  
  - **批量网络探测（ping 测试）**：
    ```bash
    host=1
    while [ $host -le 254 ]; do
      ping -c1 -w1 192.168.1.$host >/dev/null && echo "Host $host is up"
      host=$((host + 1))
    done
    ```

> 注意：`while` 循环若条件始终为真且无退出机制，将导致**无限循环**。务必确保循环体内有改变条件状态的语句。

---

### 2. `for` 循环

`for` 循环用于**遍历一个明确的单词列表（word list）**，适用于已知迭代范围的场景。

- **语法1：显式列表遍历**
  ```bash
  for name in word1 word2 ...; do
    commands
  done
  ```
  - `name` 是循环变量，每次迭代依次取 `word1`, `word2`, … 的值。
  - 列表可以是字面量、变量展开、命令替换等。
  - 示例：
    ```bash
    for file in *.txt; do
      echo "Processing $file"
    done
    ```

- **语法2：遍历位置参数（省略 `in` 子句）**
  ```bash
  for name; do   # 等价于 for name in "$@"
    commands
  done
  ```
  - 当省略 `in ...` 部分时，Shell 默认遍历所有**位置参数**（即 `$1`, `$2`, ..., `$#`）。
  - 这是处理脚本参数的简洁方式。
  - 示例：
    ```bash
    # 脚本 usage: ./script.sh file1 file2 file3
    for f; do
      [ -f "$f" ] && echo "$f exists"
    done
    ```

> ⚠️ 注意：若当前无位置参数（`$# = 0`），此循环体将**不会执行一次**。

---

### 3. 辅助命令 `seq`

由于传统 Shell 不支持 C 风格的 `for ((i=1; i<=10; i++))`（该语法为 Bash 扩展，非 POSIX），早期脚本常借助外部命令 `seq` 生成数字序列，配合 `for` 实现数值循环。

- **基本用法**：
  ```bash
  seq 1 254        # 输出 1 到 254，每行一个数字
  seq 2 2 10       # 步长为 2：2, 4, 6, 8, 10
  ```

- **与 `for` 结合的经典示例**（PPT 提供）：
  ```bash
  for i in $(seq 1 254); do
    ping -c1 -w1 192.168.0.$i
  done
  ```
  - `$(seq 1 254)` 通过命令替换生成空格分隔的数字串（如 `1 2 3 ... 254`）
  - `for` 将其作为单词列表依次赋值给 `i`

> **替代方案**：现代脚本可使用 Bash 的 `{1..254}`（大括号扩展）避免调用外部命令：
> ```bash
> for i in {1..254}; do ...
> ```
> 但 `seq` 在 POSIX 兼容脚本中更通用。

---

### 4. 控制语句

Shell 提供三种关键控制语句，用于在循环中改变执行流程：

- **`break`**  
  - 立即**退出当前最内层循环**。
  - 支持指定层数：`break n` 可跳出 `n` 层嵌套循环（`n` 默认为 1）。
  - 示例：
    ```bash
    for i in 1 2 3; do
      for j in a b c; do
        [ "$i" = "2" -a "$j" = "b" ] && break 2
      done
    done
    ```

- **`continue`**  
  - **跳过本轮循环剩余命令**，直接进入下一次迭代。
  - 同样支持 `continue n` 跳出到第 `n` 层循环的下一轮。
  - 示例：
    ```bash
    for file in *; do
      [ ! -f "$file" ] && continue   # 跳过非普通文件
      echo "File: $file"
    done
    ```

- **`exit [n]`**  
  - **立即终止整个脚本**（不仅是循环）。
  - 可选参数 `n` 为退出状态码（0 表示成功，非 0 表示失败）。
  - 若省略 `n`，默认使用上一条命令的返回码。
  - 示例：
    ```bash
    if [ ! -d /critical ]; then
      echo "Critical directory missing!" >&2
      exit 1
    fi
    ```

> **重要区别**：  
> - `break`/`continue` 仅影响**循环结构**；  
> - `exit` 影响**整个脚本进程**，慎用于函数或深层逻辑中。

---

综上，Shell 的循环结构虽语法简洁，但结合 `test`、命令替换、控制语句等机制，足以应对从简单遍历到复杂轮询的各种自动化任务。掌握 `while` 与 `for` 的适用场景、`seq` 的使用限制以及控制语句的精确作用范围，是编写高效可靠 Shell 脚本的关键。

## 八、Shell 函数

### 1. 函数定义语法

Shell 函数提供了一种将常用命令序列封装为可重用单元的机制，其定义简洁且无需声明返回类型或参数列表。

- **标准定义格式**（严格遵循 PPT）：
  ```bash
  name() {
    commands
  }
  ```
  - 函数名 `name` 后紧跟一对空括号 `()`，这是 Shell 函数的标识。
  - 函数体由花括号 `{ }` 包裹，内部包含任意数量的命令。
  - 花括号与函数名之间必须有空格（因 `{` 是保留字）。

- **关键使用规则**：
  - **函数必须在调用前定义**：Shell 是逐行解释执行的，若先调用后定义，会报“command not found”错误。
  - **调用方式如同普通命令**：
    ```bash
    myfunc arg1 arg2
    ```
    参数直接跟在函数名后，无需括号。

> 示例：
> ```bash
> greet() {
>   echo "Hello, $1!"
> }
> greet World   # 输出：Hello, World!
> ```

---

### 2. 参数与返回

Shell 函数通过位置参数接收输入，并通过特殊机制返回状态或数据。

- **参数传递与引用**：
  - 函数内部使用 `$1`, `$2`, ..., `$#` 访问传入的参数，与脚本主程序一致。
  - `$*` 和 `$@` 可用于整体处理所有参数（注意引号包裹时的行为差异）。

- **返回状态码**：
  - 使用 `return [n]` 设置函数的退出状态（0 表示成功，1–255 表示失败）。
  - 若未显式 `return`，函数返回**最后一条命令的退出状态**。
  - 调用者可通过 `$?` 获取该状态码，用于条件判断：
    ```bash
    checkfile() {
      [ -f "$1" ] && return 0 || return 1
    }
    checkfile /etc/passwd && echo "Exists"
    ```

- **变量作用域问题**：
  - **默认无局部作用域**：在函数内定义的变量（如 `x=5`）是**全局变量**，在函数外部依然可见且可修改。
  - **实现局部变量**：使用 `local` 关键字（Bash/Dash 等支持）：
    ```bash
    demo() {
      local temp="inside"   # 仅在函数内有效
      global="visible"      # 全局可见
    }
    ```
  - PPT 明确指出：“函数内定义的变量在函数外仍可见”，强调了 Shell 默认的全局作用域特性。

---

### 3. 应用示例：交互式配置函数

PPT 中以函数 `get_attr` 为例，展示了如何封装用户交互逻辑，提升脚本模块化程度。

- **功能目标**：
  - 提示用户输入某项配置（如网络协议类型）
  - 显示默认值（如 `default: tcp`）
  - **限制输入范围**：只接受预设选项（如 `tcp`, `udp`, `icmp`）
  - 将最终选择结果**赋值给一个全局变量**，供后续脚本使用

- **典型实现逻辑**：
  ```bash
  get_attr() {
    local prompt="$1"
    local default="$2"
    local options="$3"  # 如 "tcp|udp|icmp"
    local input

    while true; do
      read -p "$prompt [$default]: " input
      input=${input:-$default}   # 若为空，使用默认值

      # 检查输入是否在允许列表中（简化版）
      case "$input" in
        tcp|udp|icmp)
          eval "$4='$input'"    # 将结果写入调用者指定的变量
          return 0
          ;;
        *)
          echo "Invalid choice. Please select from: tcp, udp, icmp"
          ;;
      esac
    done
  }

  # 调用示例
  get_attr "Choose protocol" "tcp" "tcp|udp|icmp" PROTO
  echo "Selected: $PROTO"
  ```

- **关键技术点**：
  - 使用 `eval "$varname='$value'"` 实现**间接赋值**（因 Shell 函数无法直接返回字符串）
  - 通过 `case` 限制输入合法性
  - 循环确保用户输入有效前不退出

> 此模式广泛应用于安装脚本、配置向导等需要人机交互的场景。

---

### 4. 主程序结构

在复杂 Shell 脚本中，通常采用“函数定义 + 主控流程”的结构组织代码。

- **典型结构**：
  ```bash
  #!/bin/sh

  # 函数定义区
  func1() { ... }
  func2() { ... }
  get_attr() { ... }

  # 主程序入口
  main() {
    get_attr "Enter hostname" "localhost" "" HOST
    get_attr "Enter port" "80" "" PORT
    setup_service "$HOST" "$PORT"
  }

  main "$@"
  ```

- **长命令拆分技巧**：
  - 当命令过长时，可使用**续行符 `\`** 换行，提高可读性。
  - **严格语法要求**：`\` 后**不能有任何字符（包括空格或注释）**，否则续行失效。
  
  正确实例（来自 PPT 风格）：
  ```bash
  curl -s \
       --connect-timeout 10 \
       --retry 3 \
       "http://$HOST:$PORT/health"
  ```

  错误示例：
  ```bash
  curl -s \     # ← 此行末尾有空格，导致语法错误
       --help
  ```

- **设计优势**：
  - 主程序逻辑清晰，仅负责协调函数调用
  - 函数可复用、可测试
  - 配置与执行分离，便于维护

---

综上，Shell 函数虽无复杂类型系统，但通过合理利用参数传递、`return` 状态码、`local` 变量及 `eval` 间接赋值，足以构建结构清晰、交互友好的自动化脚本。理解其全局作用域特性与间接数据返回机制，是掌握 Shell 函数编程的关键。