# **Linux开发环境及应用 第11章：进程**

## 一、概述

### 1. 进程的基本概念和逻辑内存

#### **程序 vs 进程**

根据PPT内容，**程序**被定义为“指令和数据的集合”，以普通文件形式存放在磁盘上，其i节点被标记为可执行，且内容需符合系统格式要求。而**进程**则是程序在运行时的动态实体，是一个包含**指令段、用户数据段和系统数据段的执行环境**。

两者的关系具有以下关键特性：
- 程序仅用于**初始化**进程的指令段和用户数据段；
- 一旦初始化完成，**进程与原程序文件之间不再有直接联系**；
- 运行期间，磁盘上的程序文件**不可被修改或删除**（因仍被映射）；
- **多个并发进程可由同一程序创建**，彼此相互独立；
- 为节省内存，内核会安排这些进程**共享指令段**，甚至不同程序的进程也可**共享动态链接库**，但这种共享对用户是**完全透明的**。

#### **进程的组成部分**

PPT明确将进程划分为四个逻辑部分：

1. **指令段（Text）**  
   - 存放程序编译后的CPU指令，包括主程序、子程序及所调用的库函数代码；  
   - 属性为**只读**，**大小固定不变**，支持多进程共享。

2. **用户数据段**  
   - 存储全局变量、`static`变量、字符串常量等；  
   - 支持**动态增长与缩小**，用于实现堆内存分配；  
   - 底层通过系统调用 `sbrk()` 调整大小，调整单位为“页”；  
   - 标准库函数如 `malloc()` 和 `free()` 正是基于此机制实现。

3. **用户栈段**  
   - 用于支持函数调用机制：保存返回地址、传递参数、存储函数内部定义的局部变量（`static`变量除外）；  
   - `main` 函数启动前，**命令行参数（`argc`, `argv`）和环境参数已被系统初始化并置于栈的最底部**；  
   - 栈空间可**动态向上增长**（向低地址方向），但受系统限制（如 `ulimit -s`）。

4. **系统数据段**  
   - 位于**内核空间**，每个进程对应一套独立数据；  
   - 包含**页表**和**进程控制块（PCB）**；  
   - 用户态程序**无法直接访问**，必须通过系统调用间接操作。

#### **进程虚拟地址空间的布局**

PPT中虽未给出具体图示文字描述，但结合上下文可知，在32位Linux系统（特别是Pentium架构）下，每个进程拥有**独立的4GB虚拟地址空间**（0x00000000 ~ 0xFFFFFFFF），典型布局自低地址向高地址依次为：
- **文本段（Text）**：存放可执行代码；
- **数据段（Data/BSS）**：初始化/未初始化的全局与静态变量；
- **堆（Heap）**：通过 `malloc` 动态分配，向上增长；
- **未分配区域（空洞）**：堆与栈之间的空白区；
- **栈（Stack）**：向下增长，存放函数调用帧；
- **内核空间**：高地址部分（通常0xC0000000以上），用户不可访问。

该布局确保了进程间的隔离性与内存管理的灵活性。

#### **Pentium虚拟地址到物理地址转换**

PPT专门用多页讲解Pentium架构下的地址转换机制，核心为**两级页表结构**：
- 虚拟地址被划分为三部分：**页目录索引（10位） + 页表索引（10位） + 页内偏移（12位）**；
- 转换流程：
  1. CPU从CR3寄存器获取**页目录基址（Page Directory Base）**；
  2. 用高10位索引查找**页目录项（PDE, Page Directory Entry）**，得到页表物理地址；
  3. 用中间10位索引查找**页表项（PTE, Page Table Entry）**，得到物理页帧号；
  4. 结合低12位偏移，形成最终**物理地址**。
- 整个过程由**MMU（内存管理单元）硬件自动完成**，操作系统负责维护页目录和页表内容。

#### **能解决的问题**

PPT最后总结指出，上述虚存机制能够有效解决以下关键问题：
- **内存越界保护**：通过页表权限位防止非法访问；
- **读写保护**：指令段设为只读，数据段可读写；
- **缺页调入（Demand Paging）**：访问未加载页面时触发缺页异常，由OS从磁盘调入；
- **扩展逻辑内存**：利用磁盘交换区（swap）使逻辑内存远大于物理内存；
- **栈段自动生长**：访问超出当前栈范围时，通过缺页机制动态扩展；
- **多进程内存共享与写时复制（COW）**：父子进程`fork`后共享页，写操作时才复制；
- **LRU页面置换支持**：页表项中的访问位（Accessed bit）和脏位（Dirty bit）辅助实现近似LRU算法；
- **页面回写判断**：脏位标记是否需在换出时写回磁盘。

---

### 2. 进程的执行状态

#### **进程的系统数据：PCB（Process Control Block）**

PPT强调，PCB是内核中描述进程的核心数据结构，包含以下关键信息：
- **页表**：管理进程虚拟地址到物理地址的映射（在32位Pentium下约占已分配虚拟内存的1/1024）；
- **打开文件描述符表**：记录进程当前打开的所有文件；
- **核心态堆栈**：大小约几KB，用于系统调用和中断处理；
- **调度信息**：进程状态、优先级；
- **文件系统上下文**：当前工作目录、根目录的i节点，以及umask值；
- **身份标识**：进程ID（PID）、父进程ID（PPID）、实际/有效用户ID（UID）和组ID（GID）；
- **进程组号**：用于作业控制。

#### **传统UNIX的 user + proc 结构**

PPT指出，在传统UNIX系统中，PCB被拆分为两个结构：
- **user 结构**（约5000字节，定义于 `<sys/user.h>`）：
  - 存放**进程运行时才需要的数据**，如核心态堆栈（占用大部分空间）；
  - 仅当进程处于运行或就绪状态时驻留内存。
- **proc 结构**（约300字节，定义于 `<sys/proc.h>`）：
  - 存放**进程生命周期内始终需要的管理信息**，如状态、PID、优先级等；
  - 始终驻留在内核内存中。
- 用户程序**不能直接读写这些结构**，必须通过系统调用（如 `getpid()`, `chdir()`, `umask()`, `open()`, `setpgrp()` 等）间接访问或修改。

#### **进程的基本状态**

PPT将进程状态简化为两类基本状态：
- **运行状态（Running/Runnable）**：
  - 正在占用CPU，或已准备好等待调度；
  - 内核的调度器仅关注此类进程。
- **睡眠状态（Sleeping / Blocked / Waiting / 挂起）**：
  - 因等待某事件（如I/O完成、信号量）而主动放弃CPU；
  - **不消耗CPU时间**；
  - 一旦等待条件满足（如键盘输入到达），即被唤醒转为运行状态。
- PPT特别提醒：**编程时应避免“忙等待”**（即循环检查条件而不让出CPU），这会浪费系统资源。

#### **进程的调度**

- 内核采用**基于优先级的调度策略**，高优先级进程优先获得CPU；
- **优先级动态调整**：刚从睡眠状态唤醒的进程会被赋予较高优先级，以提升交互式应用（如终端、GUI）的响应速度；
- 用户可通过 `nice()` 系统调用**有限地降低**（不能提高）自身或子进程的优先级。

#### **命令 `ps`**

- **功能**：显示当前系统中进程的状态信息，实质是**有选择地打印内核PCB数组的内容**。
- **常用选项**：
  - 无选项：仅显示当前终端启动的进程；
  - `-e`：列出**所有进程**；
  - `-f`：以**full格式**输出（增加列数）；
  - `-l`：以**long格式**输出（更详细信息）。
- **输出字段含义**（以 `ps -ef` 或 `ps -l` 为例）：
  - `UID`：用户ID（可映射为用户名）；
  - `PID`：进程ID；
  - `PPID`：父进程ID；
  - `C`：CPU占用指数（不同系统算法不同，例如每10ms加1，每秒衰减一半）；
  - `STIME`：进程启动时间；
  - `SZ`：进程逻辑内存大小（以页为单位）；
  - `TTY`：关联的终端设备名；
  - `TIME`：累计占用CPU的时间；
  - `PRI`：调度优先级；
  - `S`：进程状态（`R`=运行, `S`=睡眠, `Z`=僵尸）；
  - `WCHAN`：若进程处于睡眠状态，显示其**等待的内核通道（Wait Channel）**，即阻塞在哪个内核函数或资源上。

---

### 3. 进程的执行时间

#### **`time` 命令**

- PPT区分了两种 `time`：
  - **外部命令 `/usr/bin/time`**：功能更全，输出格式固定；
  - **Shell内建命令 `time`**（如在csh中）：输出格式简洁，如 `0.4u 6.2s 0:10 61%`。
- 两者均报告三类时间：
  - **Real（Wall Clock Time）**：从开始到结束的实际耗时；
  - **User**：进程在**用户态**消耗的CPU时间；
  - **System**：进程在**内核态**（系统调用）消耗的CPU时间。
- PPT还提到 `vmstat` 命令可用于监控系统级CPU时间使用情况。

#### **系统调用 `times()`**

- 函数原型：
  ```c
  clock_t times(struct tms *buf);
  ```
- `struct tms` 结构体包含四个字段：
  - `tms_utime`：本进程用户态CPU时间；
  - `tms_stime`：本进程内核态CPU时间；
  - `tms_cutime`：**已终止子进程**的用户态CPU时间总和；
  - `tms_cstime`：**已终止子进程**的内核态CPU时间总和。
- `clock()` 函数返回上述四项之和，单位为 `1/CLOCKS_PER_SEC` 秒。
- **`getrusage()`** 被描述为 `times()` 的**升级版**，除CPU时间外，还能返回14项额外资源使用统计，包括：
  - 最大驻留集大小（内存）；
  - 页面错误次数；
  - I/O操作次数；
  - 上下文切换次数等。

#### **与时间有关的标准库函数**

PPT列举了C标准库中常用的时间函数：
- `time_t time(time_t *t)`：返回自 **1970年1月1日 00:00:00 UTC** 起的秒数；
- `gettimeofday()`：提供**微秒（μs）级精度**的时间戳；
- `mktime()`：将 `struct tm`（年月日时分秒）转换为 `time_t`；
- `localtime()` / `gmtime()`：将 `time_t` 转换为本地/UTC时间的 `struct tm`；
- `ctime()` / `asctime()`：将 `time_t` 或 `struct tm` 转换为可读字符串（如 `"Wed Jun 30 21:49:08 1993\n"`）；
- `strftime()`：按自定义格式（如 `%Y-%m-%d %H:%M:%S`）生成时间字符串。

#### **忙等待问题**

- PPT明确指出：在多任务系统中，**“忙等待”（busy-waiting）是不可取的**，因为它持续占用CPU却不做有效工作；
- 推荐替代方案：
  - 使用 `sleep(1)` 实现**秒级定时轮询**；
  - 使用 `select()` 系统调用可实现**毫秒级精度的睡眠**，同时可监听多个文件描述符。

---

### 4. 进程的基本概念：小结

PPT在本节末尾进行了全面总结，涵盖以下要点：
- 清晰区分**程序**（静态文件）与**进程**（动态实体）的定义及其关系；
- 掌握进程的**四个组成部分**（指令段、数据段、栈段、系统数据段）及其在C语言程序中的对应（如全局变量→数据段，局部变量→栈段）；
- 理解**32位进程虚拟地址空间的典型布局**；
- 深入掌握**Pentium架构下虚实地址转换机制**，包括所需数据结构（PD、PDE、PT、PTE）及软硬件协作方式；
- 明确该机制如何支撑**内存保护、栈生长、写时复制、缺页调入、LRU置换、多进程共享**等高级功能；
- 熟悉**PCB包含的信息**及通过系统调用访问的方法；
- 掌握**进程的基本状态（运行/睡眠）与调度原则**；
- 能使用 `ps`、`time`、`vmstat` 等命令观察进程属性（如 `C`、`SZ`、`TIME`）；
- 掌握 `times()`、`clock()`、`getrusage()` 等系统调用获取精确CPU时间；
- 熟练使用标准库中的时间函数进行时间坐标与日历时间的相互转换；
- 认识**忙等待的危害**，并掌握合理替代方案（`sleep`、`select`）。

## 二、进程的生命周期：从生到死

### 1. `fork()`：创建新进程

根据PPT内容，**`fork()` 是创建新进程的唯一方式**。调用后，系统会生成一个称为“子进程”的新进程，而原进程则被称为“父进程”。

其核心行为包括：
- **完全复制用户空间**：子进程获得父进程的**指令段、用户数据段和栈段**的完整副本；
- **部分复制系统数据段**：如进程控制块（PCB）会被新建，但页表等结构在初期通过**共享物理页**实现高效复制；
- **采用写时复制（Copy-on-Write, COW）技术**：父子进程初始共享相同的物理内存页，只有当任一方尝试**写入**某页时，内核才真正复制该页。这一机制对程序员完全透明，极大提升了 `fork()` 的性能。

关于返回值，PPT特别强调其关键作用：
- 在**父进程中**，`fork()` 返回**子进程的 PID（>0）**；
- 在**子进程中**，`fork()` 返回 **0**；
- 若创建失败（如资源不足），则在父进程中返回 **-1**。

正是通过检查返回值是否为0，程序才能区分当前是父进程还是子进程，从而执行不同的逻辑分支。

---

### 2. `fork()` 举例

PPT中包含两个典型示例（标记为“fork举例(1)”和“fork举例(2)”），用于演示 `fork()` 的实际行为：

- **并发执行**：`fork()` 调用后，父子进程**同时运行**，执行顺序由调度器决定，输出可能交错；
- **独立地址空间**：尽管子进程初始复制了父进程的数据，但后续对变量的修改（如整型变量、数组元素）**互不影响**，证明两者拥有独立的内存空间；
- **共享文件描述符**：若父进程在 `fork()` 前打开了文件，则父子进程共享同一文件描述符，对文件偏移量的操作会相互影响（此点虽未在提纲中列出，但属于 `fork` 语义的重要部分）。

这些例子直观展示了进程的隔离性与 `fork` 的复制语义。

---

### 3. 命令行参数和环境参数

PPT明确指出，**命令行参数和环境参数在进程启动时被初始化并存放在用户栈的最底部**。

访问方式如下：
- **命令行参数**：通过 `main` 函数的标准形式访问：
  ```c
  int main(int argc, char *argv[])
  ```
  其中 `argc` 为参数个数，`argv` 为参数字符串指针数组。

- **环境参数**（即环境变量）提供三种访问方法：
  1. **全局变量 `environ`**：
     ```c
     extern char **environ; // 定义在 <unistd.h> 或 libc 中
     // environ 是一个以 NULL 结尾的字符串指针数组
     ```
  2. **`main` 函数的第三参数**（非POSIX标准，但多数系统支持）：
     ```c
     int main(int argc, char *argv[], char *envp[])
     ```
     `envp` 指向环境字符串数组。
  3. **库函数 `getenv()`**（推荐方式）：
     ```c
     #include <stdlib.h>
     char *value = getenv("PATH"); // 返回指定环境变量的值
     ```

PPT强调，这三部分（命令行参数、环境参数、栈帧）共同构成了进程栈的初始状态。

---

### 4. `exec` 系统调用

PPT将 `exec` 描述为**用指定程序文件重新初始化当前进程**的系统调用。它**不创建新进程**，而是**替换当前进程的用户空间内容**。

具体效果包括：
- **重置指令段、用户数据段和栈段**：原有代码和数据被新程序覆盖；
- **保留进程ID（PID）、打开的文件描述符、当前工作目录、umask、信号处理设置等系统属性**；
- **通常在 `fork()` 之后由子进程调用**，形成经典的 “fork-exec” 模式，用于启动新程序。

PPT详细列出了 **6 种 `exec` 变体**，其命名规则基于后缀字母组合：
- **`l`（list）**：命令行参数以**可变参数列表**形式传入，最后一个参数必须是 `(char *)0`；
- **`v`（vector）**：命令行参数以**指针数组 `char *argv[]`** 形式传入，数组以 `NULL` 结尾；
- **`e`**：显式传入**环境变量数组 `char *envp[]`**，替代当前环境；
- **`p`**：**使用 PATH 环境变量**搜索可执行文件，无需提供完整路径。

因此六种格式为：
- `execl`, `execv`：基本形式；
- `execle`, `execve`：带自定义环境；
- `execlp`, `execvp`：带 PATH 搜索。

PPT强调，不同格式的区别仅在于**如何初始化堆栈底部的命令行参数和环境参数**，底层最终都调用 `execve`。

---

### 5. “僵尸”进程（Zombie / Defunct）

PPT对“僵尸进程”给出了明确定义：**进程生命期结束后的一种特殊状态**。

其成因与特点如下：
- **成因**：子进程已终止（调用 `exit()` 或从 `main` 返回），但**父进程尚未调用 `wait()` 系统调用来“收尸”**；
- **资源释放情况**：
  - 进程占用的**内存、文件描述符等资源已被内核回收**；
  - 但**PCB 中的部分数据（如退出状态、PID）仍保留在内核进程表中**，等待父进程读取；
- **危害**：僵尸进程本身不消耗内存或CPU，但会**占用进程表项**；若系统中僵尸进程过多，可能导致**无法创建新进程**（因进程表满）；
- **状态标识**：在 `ps` 命令中显示为 `Z`（Zombie）或 `defunct`。

PPT还提及 **“孤儿进程”** 的概念：
- 当**父进程先于子进程退出**，子进程成为孤儿；
- 此时，**init 进程（PID=1）会自动收养该子进程**，成为其新父进程；
- 当孤儿进程终止后，**init 会自动调用 `wait()` 回收**，因此**不会变成僵尸进程**。

---

### 6. `wait` 系统调用

为解决僵尸进程问题，PPT介绍了 `wait` 系统调用。

其核心功能是：
- **阻塞父进程**，直到**任意一个子进程终止**；
- **回收子进程的PCB资源**，防止其变为僵尸；
- **获取子进程的退出状态**。

函数原型为：
```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *stat_loc);
```
- 若已有子进程终止，`wait()` **立即返回**；
- 返回值为**已终止子进程的 PID**；
- 若无子进程或出错，返回 `-1`。

关于退出状态的解析，PPT虽未列出宏名，但结合上下文可知需使用标准宏：
- `WIFEXITED(status)`：判断是否正常退出；
- `EXITSTATUS(status)`：若正常退出，获取其退出码（0~255）；
- `WIFSIGNALED(status)`：判断是否被信号杀死；
- `TERMSIG(status)`：若被信号杀死，获取信号编号。

此外，PPT提到 `wait` 的增强版本：
- **`waitpid()`**：可等待**指定 PID 的子进程**，并支持非阻塞选项；
- **`wait3()` 和 `wait4()`**：在等待的同时，通过 `struct rusage` 返回**子进程的资源使用统计信息**（如CPU时间、内存、I/O等），是 `wait` 与 `getrusage` 功能的结合。

这些机制共同构成了Linux进程生命周期管理的核心：`fork` 创建 → `exec` 替换 → `wait` 回收。

## 三、自编 Shell：xsh0

### 1. 字符串库函数 `strtok`

根据PPT内容，`strtok` 是实现简易命令行解析的关键工具。其功能是**将一个字符串按指定的分隔符集合进行切分，逐个返回“单词”（token）**。

- **分隔符**：PPT中明确使用 `" \t\n"`（空格、制表符、换行符）作为分隔字符集，这与标准 shell 的单词分割规则一致。
- **工作方式**：
  - 首次调用时传入待解析的字符串指针（如 `s`）和分隔符字符串；
  - 后续调用必须传入 **`NULL`** 作为第一个参数，表示继续从上次切分位置往后解析；
  - 每次返回当前 token 的首地址，若无更多 token 则返回 `NULL`。
- **示例用法**（来自PPT）：
  ```c
  char *p = strtok(s, " \t\n");     // 获取第一个单词
  p = strtok(NULL, " \t\n");        // 获取第二个单词
  p = strtok(NULL, " \t\n");        // 获取第三个单词
  ```
- **内部状态**：`strtok` 使用静态变量保存上次切分的位置，因此**不是线程安全的**。在单线程的 `xsh0` 中使用是安全的。

PPT通过图示展示了 `fgets` 读入一行命令（如 `"ls -l /home\n"`）后，经过多次 `strtok` 调用，依次提取出 `"ls"`、`"-l"`、`"/home"` 的过程，为后续构造 `execvp` 的参数数组奠定基础。

---

### 2. 最简单的 Shell：`xsh0.c`

PPT以 `xsh0.c` 为例，完整演示了一个**最小可行 shell** 的实现逻辑，体现了进程控制的核心流程：

1. **读入用户输入**  
   使用 `fgets(buffer, sizeof(buffer), stdin)` 从标准输入读取一整行命令（包含换行符 `\n`）。

2. **解析命令与参数**  
   - 利用 `strtok` 按 `" \t\n"` 分割输入字符串；
   - 将每个 token 依次存入一个 `char *args[MAX_ARGS]` 数组中；
   - 最后一个元素设为 `NULL`，以满足 `execvp` 对参数数组的要求（以 `NULL` 结尾）。

3. **创建子进程**  
   调用 `fork()` 创建子进程。父进程与子进程在此分道扬镳。

4. **子进程执行命令**  
   - 在子进程中调用 `execvp(args[0], args)`；
   - `execvp` 会：
     - 使用 `PATH` 环境变量搜索可执行文件 `args[0]`；
     - 用该程序替换当前进程映像；
     - 将 `args` 作为新程序的 `argv` 参数。
   - 若 `execvp` 成功，则子进程开始执行新命令；若失败（如命令不存在），通常会打印错误并调用 `exit(1)`。

5. **父进程等待子进程结束**  
   - 父进程调用 `wait(NULL)`（或带状态指针的 `wait(&status)`）；
   - 阻塞直到子进程终止；
   - 回收子进程资源，避免产生僵尸进程；
   - 子进程结束后，父进程回到循环开头，提示用户输入下一条命令。

PPT通过多张状态图（如“执行fgets后的状态”、“for循环第1轮后”等）逐步展示了 `args` 数组如何被填充，清晰呈现了从原始字符串到可执行参数列表的转换过程。

---

### 3. 库函数 `system()`

PPT在介绍完手动实现的 `xsh0` 后，引出了标准库函数 `system()`，作为执行 shell 命令的**高层封装**。

- **功能**：  
  接受一个**字符串形式的 shell 命令**（如 `"ls -l | grep .c > out.txt"`），并**在子 shell 中执行它**。支持 shell 的全部特性，包括：
  - 管道（`|`）
  - 重定向（`>`, `<`, `>>`）
  - 通配符（`*`, `?`）
  - 环境变量展开（`$HOME`）

- **内部实现机制**：  
  PPT明确指出，`system()` **本质上是 `fork()` + `exec()` + `wait()` 的封装**：
  1. 调用 `fork()` 创建子进程；
  2. 在子进程中调用 `/bin/sh -c "command"`（即通过 `execl` 或 `execle` 启动 shell 并传入命令字符串）；
  3. 父进程调用 `wait()` 等待 shell 进程结束；
  4. 返回 shell 进程的退出状态。

- **用途与局限性**：
  - **优点**：使用极其简单，一行代码即可执行复杂命令；
  - **缺点**：
    - **安全性风险高**：若命令字符串包含用户输入且未严格校验，易导致**命令注入漏洞**（如输入 `"; rm -rf /"`）；
    - **性能开销大**：每次调用都启动一个完整的 shell 进程；
    - **控制粒度粗**：无法直接获取子进程 PID 或精细控制信号处理。
  - **建议**：仅用于**可信环境**下的简单任务；在需要安全性和性能的场景，应使用 `fork` + `exec` 手动实现。

PPT通过对比 `xsh0`（手动解析+直接 exec）与 `system()`（交由 shell 解析），强调了理解底层进程机制的重要性——`system()` 虽方便，但其能力与风险均源于对 shell 的依赖。

## 四、进程控制：小结

- 深入理解 `fork()` 的复制语义与 COW 机制；
- 掌握命令行参数与环境变量的位置及三种访问方式；
- 熟悉 `exec` 六种形式及其设计原因；
- 理解僵尸进程成因与 `wait` 的必要性；
- 掌握孤儿进程处理机制；
- 能编写简易 shell（`xsh0`）；
- 了解 `system()` 的作用与局限。

---