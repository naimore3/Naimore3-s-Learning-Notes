# 第14章 进程间通信（IPC）

## 一、概述
- 进程间通信（IPC）的基本概念
- UNIX/Linux 提供的三种经典 IPC 机制：
  - 信号灯（Semaphore）
  - 共享内存（Shared Memory）
  - 消息队列（Message Queue）

---

## 二、信号灯（Semaphore）

### 1. 基本原理

信号灯（Semaphore）是 UNIX/Linux 系统中用于实现**进程间同步与互斥**的重要机制之一，属于经典的 IPC（Inter-Process Communication）组件。其核心作用在于：

- **控制多进程对共享资源的互斥访问**：确保同一时刻只有一个进程能访问临界资源，防止数据竞争。
- **实现进程间的同步协调**：例如在“生产者-消费者”模型中，协调生产与消费节奏。

PPT 强调了 **“策略与机制分离”** 的设计哲学：
- 内核仅提供**信号灯机制**（如创建、操作、删除等系统调用）；
- **具体使用逻辑**（如 P/V 操作的顺序、资源保护范围）由用户程序自行设计和实现。

因此，若程序未正确使用信号灯（如遗漏 V 操作、操作顺序错误），将可能导致：
- **信息访问不安全**（数据不一致、竞态条件）；
- **死锁**（多个进程互相等待对方释放资源而永久阻塞）。

> 注：UNIX 的信号灯功能比教科书中的简单 PV 原语更强大，支持信号灯组、原子批量操作等特性。

---

### 2. P操作与V操作

PPT 明确指出，Linux 信号灯机制通过 `semop()` 系统调用实现 **P 操作** 和 **V 操作**，其行为由 `sembuf` 结构体中的 `sem_op` 字段决定：

- **P 操作（申请资源）**：
  - 当 `sem_op < 0` 时，表示执行 P 操作；
  - 若信号灯当前值 ≥ |sem_op|，则直接减去 |sem_op|；
  - 否则，调用进程**阻塞睡眠**，直到信号灯值足够（即有其他进程执行 V 操作释放资源）。

- **V 操作（释放资源）**：
  - 当 `sem_op > 0` 时，表示执行 V 操作；
  - 将信号灯值增加 `sem_op`，并可能唤醒等待该信号灯的其他进程。

- **特殊操作（等待为零）**：
  - 当 `sem_op == 0` 时，不修改信号灯值；
  - 进程会**阻塞**，直到信号灯值变为 **0**；
  - 常用于**同步点**（如等待所有任务完成）。

这些操作均由内核保证**原子性**，避免中间状态被其他进程干扰。

---

### 3. 信号灯的创建

PPT 给出创建或获取信号灯组的系统调用：

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(int key, int nsems, int flags);
```

各参数含义如下：

- **`key`**：  
  一个整型键值，用于唯一标识一个信号灯组。通常通过 `ftok()` 函数生成，也可设为 `IPC_PRIVATE`（仅限父子进程共享）。

- **`nsems`**：  
  指定该信号灯组中包含的**信号灯个数**（如“生产者-消费者”问题中需 3 个：empty、full、mutex）。  
  > 注意：若获取已存在的信号灯组，`nsems` 必须 ≤ 已存在组的大小，且通常设为 0。

- **`flags`**：  
  控制创建行为，常用组合：
  - `IPC_CREAT`：若不存在则创建；
  - `IPC_EXCL | IPC_CREAT`：仅当不存在时才创建（类似文件 O_EXCL）；
  - 权限位（如 `0666`）可与标志位按位或。

- **返回值**：  
  成功时返回**信号灯组 ID（sem_id）**；失败返回 `-1` 并设置 `errno`。

---

### 4. 信号灯的删除

PPT 提供了通过 `semctl()` 删除信号灯组的方法：

```c
int semctl(int sem_id, int snum, int cmd, ... /* union semun arg */);
```

- **`sem_id`**：由 `semget()` 返回的信号灯组 ID；
- **`snum`**：信号灯在组内的编号（从 0 开始）；删除整个组时通常设为 `0`；
- **`cmd`**：控制命令，删除使用 `IPC_RMID`；
- **`arg`**：根据 `cmd` 不同，可能需要额外参数。对于 `IPC_RMID`，该参数**可忽略**（PPT 中写作 `0`，实际应传入任意值或省略）。

> ⚠️ 注意：虽然 PPT 示例写为 `semctl(sem_id, 0, IPC_RMID, 0)`，但严格来说，`semctl` 的第四个参数在 `IPC_RMID` 下未被使用，部分系统要求传入 `union semun` 类型（尽管内容无关）。实践中常通过强制类型转换或忽略处理。

删除后，所有对该信号灯组的后续操作将失败，且内核释放相关资源。

---

### 5. 信号灯操作

PPT 重点介绍了执行 P/V 操作的核心系统调用：

```c
int semop(int sem_id, struct sembuf *ops, int nops);
```

- **`sem_id`**：目标信号灯组 ID；
- **`ops`**：指向 `struct sembuf` 数组的指针；
- **`nops`**：数组中元素个数（即本次操作涉及的信号灯数量）。

#### `struct sembuf` 结构详解（来自 PPT）：

```c
struct sembuf {
    short sem_num;  // 信号灯在组中的索引（0, 1, 2, ...）
    short sem_op;   // 操作值（<0: P, >0: V, =0: wait-for-zero）
    short sem_flg;  // 操作标志
};
```

- **`sem_flg` 常见取值**：
  - `0`：默认行为（阻塞等待）；
  - `IPC_NOWAIT`：若无法立即完成操作，则返回错误（不阻塞）；
  - `SEM_UNDO`：内核记录操作，在进程异常终止时自动**撤销**该进程对信号灯的修改（防止死锁）。

#### 原子性保证

PPT 特别强调：  
> “一次 `semop()` 调用指定的多个信号灯的操作，Linux 内核要么把多个操作一下全部做完，要么什么都不做。”

这意味着即使操作多个信号灯（如同时对 `mutex` 和 `empty` 执行 P 操作），也能保证**整体原子性**，避免中间状态导致死锁或不一致。这是解决复杂同步问题（如“哲学家就餐”）的关键特性。

--- 

综上，该部分内容完整覆盖了信号灯的理论基础、核心操作语义及关键系统调用，体现了 Linux IPC 机制在灵活性与可靠性之间的平衡设计。

## 三、共享内存（Shared Memory）

### 1. 特点

根据PPT内容，共享内存是Linux系统中**速度最快**的进程间通信（IPC）机制，其核心特点如下：

- **多个进程共享同一段物理内存空间**：  
  不同进程通过各自的虚拟地址映射到相同的物理内存区域，从而实现数据的直接共享，无需内核在进程间复制数据。

- **通信效率极高**：  
  PPT明确指出：“使用共享内存在多进程间传送数据，速度快”，并强调它是“**最快的进程间通信方式**”。这是因为数据仅存在于内存中，读写操作如同访问本地变量，避免了传统 I/O（如管道、消息队列）中的多次内存拷贝和上下文切换开销。

- **不提供同步与互斥机制**：  
  共享内存本身**仅提供存储区域**，**不包含任何访问控制逻辑**。PPT特别提醒：“进程必须自行解决对共享内存访问的互斥和同步问题”。  
  因此，在实际应用中，**必须配合信号灯（Semaphore）或其他同步机制**（如互斥锁、文件锁）来防止多个进程同时修改数据导致的竞态条件或数据不一致。

---

### 2. 应用场景

PPT列举了两个典型应用场景，突出共享内存的高效性与非侵入性：

- **高速数据交换**：  
  当多个进程需要频繁、大量地交换数据时（如图像处理、实时数据采集系统），共享内存可显著提升性能。由于数据无需在内核缓冲区与用户空间之间来回拷贝，通信延迟极低。

- **运行状态监视（非侵入式监控）**：  
  PPT以协议处理程序为例说明：
  - 协议处理程序在运行过程中，将**有限状态机的状态**和**统计信息**写入共享内存；
  - 用户可随时启动一个独立的**监视程序**，从共享内存中读取这些信息，以“窥视当前的状态，了解通信状况”；
  - **关键优势**：监视程序的启动与终止**完全不影响主通信进程的执行效率**，因为共享内存访问开销极小，且无需主进程主动响应查询请求。

这一场景体现了共享内存在**解耦监控与业务逻辑**方面的独特价值。

---

### 3. 共享内存操作

PPT详细介绍了共享内存生命周期中的三个核心系统调用：

#### （1）创建或获取共享内存段
```c
#include <sys/shm.h>
int shmget(int key, int nbytes, int flags);
```
- **功能**：创建一个新的共享内存段，或获取一个已存在的共享内存段。
- **参数说明**：
  - `key`：标识符（通常由 `ftok()` 生成），用于唯一标识该共享内存段；
  - `nbytes`：请求的共享内存大小（以字节为单位）；
  - `flags`：控制标志，如 `IPC_CREAT`（不存在则创建）、权限位（如 `0666`）。
- **返回值**：成功时返回**共享内存段 ID（shm_id）**；失败返回 `-1`。

> 注意：若获取已存在的段，`nbytes` 可设为 0。

#### （2）将共享内存映射到进程地址空间
```c
void *shmat(int shm_id, void *shmaddr, int shmflg);
```
- **功能**：将指定的共享内存段**附加（attach）** 到调用进程的虚拟地址空间，返回一个可直接读写的指针。
- **参数说明**：
  - `shm_id`：由 `shmget()` 返回的共享内存 ID；
  - `shmaddr`：建议映射地址（通常设为 `NULL` 或 `0`，由系统自动选择）；
  - `shmflg`：映射选项，如 `SHM_RDONLY`（只读）或 `0`（读写）。
- **返回值**：成功时返回指向共享内存的**用户空间指针**；失败返回 `(void *) -1`。

此后，进程可通过该指针像操作普通数组或结构体一样读写共享数据。

#### （3）控制共享内存段（如删除）
```c
int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
```
- **功能**：对共享内存段执行控制操作，如查询状态、修改权限、**删除**等。
- **常用命令**：
  - `IPC_RMID`：**立即标记该共享内存段为“待删除”**。  
    > PPT示例为 `shmctl(shm_id, IPC_RMID, 0)`，但严格来说第三个参数应为 `struct shmid_ds *` 类型（尽管在 `IPC_RMID` 下可传 `NULL` 或强制转换）。  
    > 实际行为：即使仍有进程 attached，内核也会在**最后一个进程 detach 后**自动释放物理内存。
  - `IPC_STAT` / `IPC_SET`：获取/设置共享内存属性。

> ⚠️ 注意：共享内存不会因创建进程退出而自动销毁，必须显式调用 `shmctl(..., IPC_RMID, ...)` 才能释放资源，否则会成为“孤儿”IPC对象，占用系统资源。

---

综上，PPT对共享内存的介绍紧扣其“高效但裸露”的特性，强调其在高性能通信中的价值，同时反复警示开发者必须**主动管理同步问题**，通常需与信号灯机制协同使用（如后续“生产者-消费者”案例所示）。

## 四、“生产者-消费者”问题

### 1. 问题描述

PPT明确指出，“生产者-消费者”问题是进程间通信（IPC）中的经典同步案例，用于演示如何协调多个进程对共享资源的并发访问。其核心设定如下：

- **数据结构**：使用 **N 个缓冲区组成的环形队列（circular buffer）** 作为生产者与消费者之间交换数据的媒介。
- **角色行为**：
  - **生产者进程**：不断生成数据并写入缓冲区；
  - **消费者进程**：从缓冲区中取出数据进行处理。
- **关键挑战**（PPT强调需同时解决以下三类问题）：
  - **缓冲区满**：当所有 N 个缓冲区都被填满时，生产者必须**暂停写入**，避免覆盖未消费的数据；
  - **缓冲区空**：当所有缓冲区都为空时，消费者必须**暂停读取**，避免读取无效数据；
  - **互斥访问**：多个生产者或多个消费者（或多对多场景）可能同时操作缓冲区，必须确保对缓冲区的**读写操作是原子的**，防止数据结构被破坏。

该问题综合体现了**同步**（协调生产与消费节奏）与**互斥**（保护临界区）两大 IPC 核心需求。

---

### 2. 解决方案

PPT提出了一套基于 **共享内存 + 信号灯** 的高效解决方案，具体设计如下：

- **共享内存**：  
  用于存放整个**环形缓冲区结构体**（包括缓冲区数组、读写指针 in/out、缓冲区大小等元数据）。由于多个进程需频繁读写该结构，使用共享内存可实现零拷贝高速访问。

- **三个信号灯协同工作**（构成信号灯组）：
  - **`empty` 信号灯**：  
    表示**当前可用的空缓冲槽数量**，初始值为 `N`。  
    - 生产者在写入前执行 **P(empty)**，确保有空位；  
    - 消费者在读取后执行 **V(empty)**，释放一个空位。
  - **`full` 信号灯**：  
    表示**当前已填充的有效数据项数量**，初始值为 `0`。  
    - 消费者在读取前执行 **P(full)**，确保有数据可读；  
    - 生产者在写入后执行 **V(full)**，通知有新数据可用。
  - **`mutex` 信号灯**：  
    作为**二元互斥锁**（初始值为 `1`），保护对环形队列元数据（如 in/out 指针）的修改。  
    - 所有对共享缓冲区结构的访问（无论是生产还是消费）都必须包裹在 **P(mutex) / V(mutex)** 之间。

> PPT特别说明：这三个信号灯通常通过一次 `semget()` 调用创建为一个包含 3 个元素的信号灯组，便于统一管理。

此方案确保了：
- 缓冲区不会溢出（由 `empty` 控制）；
- 不会读取空数据（由 `full` 控制）；
- 多进程并发访问缓冲区结构时的线程安全（由 `mutex` 保证）。

---

### 3. 程序组成

PPT展示了一个完整的实现框架，包含以下模块：

- **`ctl.h`（公共头文件）**：  
  定义共享内存中环形缓冲区的结构体（如 `struct shared_buffer { int buffer[N]; int in, out; }`）、信号灯键值（key）、缓冲区大小 N 等常量，供所有源文件包含。

- **`ctl.c`（控制程序）**：  
  负责 IPC 资源的生命周期管理：
  - **创建阶段**：调用 `shmget()` 创建共享内存段，调用 `semget()` 创建包含 3 个信号灯的信号灯组，并初始化 `empty=N`, `full=0`, `mutex=1`；
  - **清理阶段**：调用 `shmctl(..., IPC_RMID, ...)` 和 `semctl(..., IPC_RMID, ...)` 删除共享内存和信号灯组，释放系统资源。

- **`producer-consumer.c`（主逻辑程序）**：  
  实现生产者与消费者的业务逻辑：
  - 可通过命令行参数指定角色（如 `-p` 启动生产者，`-c` 启动消费者）；
  - 启动后 attach 到共享内存，获取信号灯 ID；
  - 循环执行：
    - **生产者**：`P(empty) → P(mutex) → 写入 buffer[in] → in=(in+1)%N → V(mutex) → V(full)`
    - **消费者**：`P(full) → P(mutex) → 读取 buffer[out] → out=(out+1)%N → V(mutex) → V(empty)`
  - 支持启动**多个生产者和多个消费者实例**，验证多进程并发下的正确性。

- **系统命令 `ipcs`**：  
  PPT建议使用该命令在运行时或结束后**查看当前系统的 IPC 资源状态**（如共享内存段、信号灯组是否存在），用于调试和验证资源是否被正确释放。若程序异常退出未清理 IPC 对象，可通过 `ipcrm` 手动删除。

---

综上，PPT通过“生产者-消费者”问题，将前文介绍的**共享内存**与**信号灯**机制有机结合，提供了一个典型、完整且可运行的 IPC 应用范例，充分体现了 Linux IPC 机制在解决实际并发问题中的强大能力与工程实践方法。

## 五、内存映射文件（Memory-Mapped Files）

### 1. 内存映射 I/O 原理

PPT指出，内存映射文件（Memory-Mapped Files）是一种将**普通磁盘文件的一部分或全部**直接映射到**进程的虚拟地址空间**的技术。其核心机制基于操作系统的**虚拟内存管理子系统**，具体原理如下：

- **映射而非加载**：  
  调用 `mmap()` 并不会立即将整个文件内容读入物理内存，而是由内核在页表中建立虚拟地址到文件数据块的映射关系。
  
- **按需调页（Demand Paging）**：  
  当进程首次访问映射区域中的某一页时，触发**缺页异常（page fault）**，内核才从磁盘将对应文件块加载到物理内存，并建立映射。这种方式避免了“一次性加载大文件”的开销，特别适合处理大型文件。

- **指针式读写**：  
  一旦映射成功，进程可像操作普通内存一样，通过返回的指针直接**读取或修改文件内容**，无需调用传统的 `read()` 或 `write()` 系统调用。例如：
  ```c
  char *mapped = mmap(...);
  mapped[0] = 'A';  // 直接修改文件第一个字节
  ```

- **写回机制**：  
  对于 `MAP_SHARED` 映射，修改会**自动同步回底层文件**（由内核在适当时机完成，也可通过 `msync()` 强制刷盘）。

该机制本质上是将**文件 I/O 转化为内存访问**，极大简化了编程模型并提升了性能。

---

### 2. 优点

PPT强调了内存映射文件相较于传统 I/O 的三大优势：

- **高性能（速度快）**：  
  传统 `read/write` 模型涉及**两次数据拷贝**：  
  （1）磁盘 → 内核缓冲区；（2）内核缓冲区 → 用户空间缓冲区。  
  而 `mmap` 利用虚拟内存机制，**省去了第二次拷贝**，数据直接在用户空间可见，显著降低 CPU 开销和延迟。

- **天然支持多进程共享**：  
  若多个进程对**同一个文件的同一区域**执行 `mmap(..., MAP_SHARED, ...)`，它们将共享**相同的物理内存页**。这使得内存映射文件成为**实现共享内存的一种便捷方式**，尤其适用于需要持久化共享数据的场景（如配置文件、数据库日志等）。

- **仍需同步机制**：  
  PPT特别提醒：虽然多个进程可通过映射同一文件实现数据共享，但**内核不提供任何访问控制**。若多个进程同时写入同一位置，仍会导致**数据竞争**。因此，**必须配合信号灯、文件锁或其他同步原语**来保证互斥与一致性。

> 补充说明：与 System V 共享内存（`shmget`）不同，内存映射文件具有**文件后备（file-backed）** 特性，即使所有进程退出，数据仍保留在磁盘上（除非映射的是匿名文件或 `/dev/zero`）。

---

### 3. 相关系统调用

PPT列出了两个核心系统调用，用于创建和释放内存映射：

#### （1）创建映射：`mmap()`
```c
#include <sys/mman.h>
void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
```

- **参数详解**：
  - `addr`：建议映射起始地址（通常设为 `NULL`，由内核自动选择）；
  - `len`：要映射的字节数；
  - `prot`：内存保护标志，常用组合：
    - `PROT_READ`：可读；
    - `PROT_WRITE`：可写；
    - 通常组合为 `PROT_READ | PROT_WRITE`。
  - `flags`：映射类型，关键选项：
    - `MAP_SHARED`：**共享映射**——修改对其他映射同一文件的进程可见，并最终写回文件；
    - `MAP_PRIVATE`：私有写时复制映射（不用于 IPC）。
  - `fd`：已打开的文件描述符（需具备与 `prot` 匹配的权限，如写映射需 `O_RDWR` 打开）；
  - `offset`：文件内的起始偏移量（必须是页大小的整数倍）。

- **返回值**：
  - 成功：返回映射区域的**起始虚拟地址**；
  - 失败：返回特殊值 `MAP_FAILED`（即 `(void *) -1`），并设置 `errno`。

#### （2）解除映射：`munmap()`
```c
int munmap(void *addr, size_t len);
```
- **功能**：解除由 `mmap()` 建立的映射；
- **参数**：
  - `addr`：必须是 `mmap()` 返回的地址；
  - `len`：必须与映射时指定的长度一致；
- **注意**：解除映射后，原指针失效，继续访问将导致段错误（Segmentation Fault）。

> PPT未提及但实践中重要：对于 `MAP_SHARED` 映射，若需确保修改立即写入磁盘，可调用 `msync(addr, len, MS_SYNC)` 强制同步。

---

综上，PPT将内存映射文件定位为一种**高效、灵活且兼具 I/O 与 IPC 能力**的机制。它不仅优化了文件访问性能，还为进程间共享数据提供了另一种基于文件系统的实现路径，是 Linux 高级编程中的重要工具。

## 六、文件和记录的锁定

### 1. 问题背景

PPT指出，在多进程环境下，当多个进程**并发访问同一个普通文件**（如数据库文件、配置文件或票务库存文件）时，若缺乏协调机制，极易引发**数据竞争（Race Condition）**。典型案例如“**售票程序**”：

- 多个售票进程同时读取剩余票数（如 1 张）；
- 各自判断“有票”，均执行“减 1”操作；
- 最终票数变为 -2，导致超售。

此类问题本质上属于经典的 **“读者-写者问题”（Readers-Writers Problem）**：
- **读者（查询进程）**：只读取数据，可允许多个并发；
- **写者（售票进程）**：修改数据，必须独占访问。

因此，PPT强调：必须引入**文件或记录级别的互斥与同步机制**，以确保数据一致性。

---

### 2. 锁类型

Linux 提供基于 `fcntl()` 的**记录锁（Record Locking）** 机制，支持对文件的**任意字节范围**加锁。PPT明确区分了两种核心锁类型：

- **共享锁（Shared Lock / Read Lock）**  
  - 标志：`F_RDLCK`  
  - 语义：
    - **允许多个进程同时持有**同一区域的读锁（即并发读）；
    - **排斥任何写锁**请求（即有读锁时，写操作必须等待）。
  - 适用场景：只读操作（如查询余额、查看状态）。

- **互斥锁（Exclusive Lock / Write Lock）**  
  - 标志：`F_WRLCK`  
  - 语义：
    - **完全排他**：一旦某进程持有某区域的写锁，其他所有进程（无论读或写）对该区域的加锁请求都将被阻塞或拒绝。
  - 适用场景：修改数据的操作（如扣减库存、更新账户）。

> 补充说明：锁作用于**文件的字节区间**，而非整个文件。例如可仅对包含票数的 4 字节整数加锁，提高并发粒度。

---

### 3. 锁操作（咨询式锁定）

PPT重点介绍了使用 `fcntl()` 系统调用实现文件锁的方式，并强调其为**咨询式锁定（Advisory Locking）**：

- **含义**：  
  内核**不会强制阻止**未加锁的进程读写文件；锁的有效性依赖于**所有相关进程自觉遵守加锁协议**。若某进程绕过 `fcntl()` 直接读写，仍可破坏数据一致性。

- **核心系统调用**：
  ```c
  int fcntl(int fd, int cmd, struct flock *lock);
  ```

- **`struct flock` 结构体**（PPT给出完整定义）：
  ```c
  struct flock {
      short l_type;   // 锁类型：F_RDLCK / F_WRLCK / F_UNLCK
      short l_whence; // 起始位置基准：SEEK_SET（文件头）、SEEK_CUR（当前位置）、SEEK_END（文件尾）
      long  l_start;  // 相对于 l_whence 的偏移量（字节）
      long  l_len;    // 锁定长度（字节）；若为 0，表示从 l_start 到文件末尾
      // 注意：部分系统还包含 l_pid 字段（用于 GETLK 查询持有者）
  };
  ```

- **关键命令（cmd）**：
  - `F_SETLKW`（Lock + Wait）：  
    尝试加锁；若无法立即获得锁（如已被他人占用），则**阻塞当前进程**，直到锁可用。
  - `F_SETLK`（Lock + No Wait）：  
    尝试加锁；若无法立即获得，则**立即返回失败**（`errno = EAGAIN` 或 `EACCES`），不阻塞。

> PPT虽未展开，但实践中还可使用 `F_GETLK` 查询某区域是否已被锁定及持有者信息。

---

### 4. 应用示例

PPT通过两个典型程序说明文件锁的实际应用：

- **售票程序（使用写锁）**：  
  - 在执行“读取票数 → 判断 → 扣减 → 写回”这一系列操作前，**先对票数所在区域加写锁（`F_WRLCK`）**；
  - 确保整个“读-改-写”过程是**原子的**，防止其他售票进程同时修改；
  - 操作完成后释放锁（设 `l_type = F_UNLCK` 并调用 `fcntl(fd, F_SETLK, &lock)`）。

- **查询程序（使用读锁）**：  
  - 在读取票数前，**加读锁（`F_RDLCK`）**；
  - 允许多个查询进程**同时读取**，提升并发性能；
  - 读取完成后立即释放读锁；
  - 重要特性：读锁期间，**售票程序的写锁请求会被阻塞**，直到所有读锁释放，从而保证查询结果的一致性。

> 示例代码逻辑（简化）：
> ```c
> // 售票（写）
> lock.l_type = F_WRLCK;
> fcntl(fd, F_SETLKW, &lock);  // 阻塞直到获得写锁
> read(fd, &tickets, sizeof(tickets));
> if (tickets > 0) tickets--;
> lseek(fd, 0, SEEK_SET);
> write(fd, &tickets, sizeof(tickets));
> lock.l_type = F_UNLCK;
> fcntl(fd, F_SETLK, &lock);   // 释放锁
> 
> // 查询（读）
> lock.l_type = F_RDLCK;
> fcntl(fd, F_SETLKW, &lock);  // 可与其他读锁共存
> read(fd, &tickets, sizeof(tickets));
> printf("剩余: %d\n", tickets);
> lock.l_type = F_UNLCK;
> fcntl(fd, F_SETLK, &lock);
> ```

---

综上，PPT将文件和记录锁定定位为一种**轻量级、细粒度且适用于普通文件的同步机制**。尽管其“咨询式”特性要求程序自律，但在遵循协议的前提下，能有效解决多进程对文件数据的并发访问问题，尤其适合无法使用共享内存或消息队列的场景（如跨用户、跨会话的持久化数据协调）。

## 七、小结

- **IPC 核心机制**：信号灯、共享内存、消息队列
- **组合使用**：信号灯 + 共享内存 → 高效解决生产者-消费者问题
- **内存映射文件**：高效 I/O 与共享内存的统一方案
- **文件锁定**：轻量级、基于文件的互斥同步机制（咨询式）
- **关键原则**：无论采用何种 IPC，**同步与互斥必须由程序正确实现**

--- 

此大纲完整覆盖了PPT中的全部技术要点，并保持原有逻辑结构，便于学习与复习。