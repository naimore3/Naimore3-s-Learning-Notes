# 套接字编程

## 一、概述

### 1. Socket 概述

根据PPT内容，**套接字（Socket）** 被明确定义为**应用程序与网络之间的应用程序编程接口（API）**。它是进程在网络中发送和接收报文的软件接口。在Linux系统中，Socket被抽象为一种特殊的文件，遵循“一切皆文件”的UNIX哲学，使得对网络通信的操作（如 read/write）与对普通文件的操作保持一致。

PPT强调，**进行通信的是进程（Process），而不是程序（Program）**。进程是运行中的程序实例，位于端系统（如主机）中。不同端系统上的进程通过**跨越计算机网络交换报文（message）** 实现通信。

在典型的网络应用架构中，通信的两个进程通常被划分为：
- **客户机（Client）**：主动发起通信的一方；
- **服务器（Server）**：被动等待并响应请求的一方。

此外，PPT详细描述了**协议栈的分层结构及其对应的数据单元**，这是理解网络通信的基础：
- **应用层**：处理的是**报文（Message）**，即应用程序生成或消费的原始数据；
- **传输层**：
  - TCP 协议将应用层报文分割为**报文段（Segment）**；
  - UDP 协议则封装为**数据报（Datagram）**；
- **网络层**：将传输层的数据单元进一步封装为**数据报（Packet）**，添加IP头部用于路由；
- **链路层**：最终将网络层的数据报封装成**帧（Frame）**，以便在物理链路上传输。

这种逐层封装（加头）和解封装（去头）的过程，构成了端到端通信的核心机制。

### 2. TCP 与 UDP 对比

PPT对TCP和UDP两种核心传输层协议进行了清晰对比，突出了它们在设计哲学和应用场景上的根本差异：

| 特性 | TCP | UDP |
|------|-----|-----|
| **连接方式** | **面向连接**：通信前需通过三次握手建立连接，通信结束后需四次挥手释放连接。 | **无连接**：发送数据前无需建立连接，每个数据报独立发送。 |
| **可靠性** | **可靠**：提供确认、重传、排序和差错校验机制，确保数据按序、完整地交付。 | **不可靠**：不保证数据送达，可能**丢包、错报、乱序**，且无重传机制。 |
| **传输单位** | **字节流（Byte Stream）**：将数据视为连续的字节流，**不保留报文边界**，应用层需自行处理消息边界（即“粘包”问题）。 | **数据报（Datagram）**：每个`sendto`调用对应一个独立的数据报，**保留报文边界**。 |
| **流量控制** | **支持**：通过滑动窗口机制防止发送方淹没接收方。 | **不支持**：发送速率不受接收方缓冲区状态影响。 |
| **广播/组播** | **不支持**：仅支持点对点（单播）通信。 | **支持**：天然支持向多个目标同时发送数据（广播和组播）。 |

PPT还特别指出，UDP因其简单、低开销的特性，常用于对实时性要求高、能容忍少量丢包的场景，如音视频流、在线游戏等。

### 3. 网络字节顺序

PPT明确指出了**网络编程中字节序的重要性**。不同CPU架构采用不同的字节序（Endianness）来存储多字节数据：
- **Little Endian（小尾）**：低位字节存储在低地址。典型代表是 **Intel x86** 架构。
- **Big Endian（大尾）**：高位字节存储在低地址。典型代表是 **PowerPC、SPARC、Motorola** 等架构。

为了确保不同主机之间能够正确解析数据，**网络协议规定统一使用 Big Endian 作为标准字节序**，这被称为**网络字节顺序（Network Byte Order）**。

因此，在将本地主机上的整数写入网络数据包之前，必须将其从**主机字节序**转换为**网络字节序**；反之，在从网络数据包中读取整数后，必须将其从**网络字节序**转换回**主机字节序**。

PPT列出了标准C库提供的转换函数：
- **32位整数（long）**：
  - `htonl()`：Host TO Network Long
  - `ntohl()`：Network TO Host Long
- **16位整数（short）**：
  - `htons()`：Host TO Network Short
  - `ntohs()`：Network TO Host Short

这些函数会自动判断当前主机的字节序，并在必要时进行字节翻转，是编写可移植网络程序的必备工具。

## 二、TCP 客户-服务器程序

### 1. 客户端程序（client.c）

根据PPT内容，TCP客户端程序的执行流程清晰且线性，其核心在于主动发起连接并进行数据交换。具体步骤如下：

1. **`socket()` 系统调用**  
   客户端首先调用 `socket()` 创建一个套接字，该调用返回一个**文件描述符**（file descriptor）。此时，该套接字尚未绑定任何本地或远程地址，即“端点名未指定”。PPT强调，套接字在UNIX/Linux系统中被抽象为一种特殊文件，因此通过文件描述符进行操作。

2. **`connect()` 系统调用**  
   客户端调用 `connect()` 向服务器发起连接请求。此调用需要指定**远端端点名**（即服务器的IP地址和端口号）。PPT明确指出，`connect()` 是一个**阻塞调用**：进程会在此处挂起，直到TCP三次握手成功完成、连接建立，函数才返回。若连接失败（如服务器不可达），则返回错误。

3. **`write()` / `read()` 数据交互**  
   连接建立后，客户端通过 `write()` 向服务器发送数据，通过 `read()` 接收服务器响应。PPT特别说明了这两个调用的阻塞特性：
   - 若**发送速率大于网络通信速率**，导致内核发送缓冲区满，则 `write()` 会阻塞，直到有足够空间。
   - 若接收缓冲区为空，`read()` 也会阻塞，等待数据到达。

4. **`close()` 关闭连接**  
   通信结束后，客户端调用 `close()` 关闭套接字，释放相关资源，并触发TCP连接的正常终止流程（四次挥手）。

整个客户端流程体现了“主动连接、单次会话”的典型模式。

### 2. 服务端程序（server0.c）

PPT详细描述了TCP服务器端的标准初始化和通信流程，其核心是被动监听并接受连接。具体步骤如下：

1. **`socket()` 系统调用**  
   服务器首先调用 `socket()` 创建一个用于监听的套接字，同样返回一个文件描述符。

2. **`bind()` 系统调用**  
   服务器必须调用 `bind()` 将套接字**绑定到一个本地端点名**（即本机的IP地址和一个众所周知的端口号）。PPT提到，`bind()` 也可用于客户端（例如指定本地出口地址），但在服务器端是必需的。

3. **`listen()` 系统调用**  
   调用 `listen()` 将套接字置为**监听状态**，准备接收客户端的连接请求。PPT强调，`listen()` **本身不会阻塞进程**，它只是向内核发出一个通知，告知其开始为该套接字维护一个“未完成连接队列”和“已完成连接队列”。

4. **`accept()` 系统调用**  
   服务器调用 `accept()` 从“已完成连接队列”中取出一个新连接。PPT明确指出，这是一个**阻塞调用**：如果队列为空，服务器进程将在此处睡眠，**等待新连接到来**。一旦有客户端完成三次握手，`accept()` 返回一个新的**通信套接字文件描述符**，专门用于与该客户端进行后续的数据交换。原始的监听套接字继续保持监听状态。

5. **`read()` / `write()` 与客户端交互**  
   服务器使用 `accept()` 返回的新套接字进行 `read()` 和 `write()` 操作，与特定客户端通信。其阻塞行为与客户端相同。

6. **`close()` 关闭连接**  
   与客户端通信结束后，服务器关闭由 `accept()` 返回的通信套接字。

> **重要限制**：PPT特别注明，`server0.c` 是一个**单连接服务器**模型。因为它在 `accept()` 之后直接进入与单一客户端的交互循环，在此期间无法处理其他新的连接请求。这导致它**无法并发处理多个客户端**，是后续引入多进程或多路复用技术的根本原因。

## 三、多进程并发处理

### 1. 多进程服务器（server1.c / server1a.c）

PPT指出，为克服 `server0.c` 无法并发处理多个客户端的缺陷，可采用**多进程模型**。其核心思想是：每当 `accept()` 成功建立一个新连接后，服务器立即调用 `fork()` 创建一个子进程，由该子进程专门负责与该客户端的后续通信，而父进程则立即回到 `accept()` 继续监听新的连接请求。

- **父进程职责**：循环调用 `accept()`，接受新连接，并为每个连接 `fork()` 出一个子进程。
- **子进程职责**：使用 `accept()` 返回的**通信套接字**与客户端交互，完成后退出。

PPT特别强调了两个**关键问题**：
- **文件描述符管理**：子进程在开始通信前，**必须关闭监听套接字**（即用于 `accept()` 的那个套接字）。因为子进程不需要监听新连接，保留它会导致资源浪费，且在父进程重启时可能因端口被占用而失败。
- **僵尸进程回收**：子进程退出后会变成僵尸进程（Zombie），占用系统资源。PPT明确指出“**必须执行此操作,否则进程僵尸问题**”。解决方法包括：
  - 父进程显式调用 `waitpid()` 回收子进程；
  - 或注册 `SIGCHLD` 信号处理函数，在信号处理程序中调用 `wait()` 或 `waitpid()` 进行异步回收。

### 2. 端点名相关系统调用

PPT介绍了两个用于获取通信双方地址信息的系统调用：
- **`getsockname(int sockfd, struct sockaddr *name, int *namelen)`**：获取与套接字 `sockfd` 关联的**本地端点名**（即本机IP和端口）。
- **`getpeername(int sockfd, struct sockaddr *name, int *namelen)`**：获取与套接字 `sockfd` 对端的**远端端点名**（即对端的IP和端口）。

PPT特别提醒，参数 `namelen` 是一个**传入传出型参数**：
- **调用前**：需将其指向的整数初始化为 `name` 缓冲区的大小（以字节为单位），告知内核缓冲区容量。
- **调用后**：内核将其修改为实际写入 `name` 缓冲区的有效数据字节数。

### 3. read/write 系统调用语义

PPT深入剖析了 `read()` 和 `write()` 在TCP通信中的真实含义及其与底层协议的交互时序：
- **与 TCP 时序关系**：
  - `write()` 成功返回仅表示应用层数据已成功**拷贝至内核的TCP发送缓冲区**，并不意味着数据已通过网络发送或已被对方接收。
  - `read()` 返回也仅表示从**内核的TCP接收缓冲区**中取出了数据，这些数据可能早已到达并缓存。

- **故障与流控**：
  - PPT明确指出，诸如**网络断开、对方主机崩溃重启**等故障，**不会立即通知应用程序**。这是因为TCP是可靠协议，会尝试重传。
  - 为探测此类“静默”故障，TCP提供了 **Keepalive 机制**，但其**默认超时时间长达两小时**。PPT说明，可通过 `getsockopt()`/`setsockopt()` 系统调用来调整保活探测的间隔、重传次数等参数。

- **“粘包”问题**：由于TCP提供的是**无结构的字节流服务**，不保留应用层消息的边界。因此，连续的多次 `write()` 调用的数据，在接收方可能被一次 `read()` 全部读出（粘包），也可能一次 `write()` 的数据被分多次 `read()` 读出（拆包）。应用层必须自行设计协议来解析消息边界。

### 4. read/write 的其他版本（适用于 UDP）

PPT提到，除了基本的 `read()`/`write()`，套接字还提供了功能更丰富的I/O函数，尤其适用于UDP：
- **`send()` / `recv()`**：与 `write()`/`read()` 功能类似，但增加了一个 `flags` 参数，可用于控制特殊行为（如带外数据）。
- **`sendto()` / `recvfrom()`**：
  - `sendto()` 允许在发送数据时**显式指定目标地址**（`struct sockaddr *to`）。
  - `recvfrom()` 在接收数据时能**同时获取发送方的地址信息**（通过 `struct sockaddr *from` 参数）。
  - PPT强调，这两个函数**常用于UDP通信**，因为UDP是无连接的，每次通信都可能涉及不同的对端。

### 5. shutdown() 系统调用

PPT解释，`shutdown()` 提供了比 `close()` 更精细的连接控制能力，因为它可以**关闭全双工连接中的单向通信**：
- **`SHUT_RD` (0)**：关闭接收方向。此后任何 `read()` 调用都将返回0（表示EOF）。
- **`SHUT_WR` (1)**：关闭发送方向。此后任何 `write()` 调用都会导致进程收到 `SIGPIPE` 信号（若未处理则进程终止）。
- **`SHUT_RDWR` (2)**：同时关闭两个方向，效果等同于 `close()`。

PPT还对比了不同协议下的行为差异：
- **TCP**：完全支持**半关闭**（half-close），即可以只关闭一个方向，这在某些协议（如HTTP）中很有用。
- **UDP**：由于UDP本身无连接，`shutdown()` 的作用有限。内核仅做标记，例如关闭接收方向后，内核将丢弃新到达的数据报，但**无法阻止对端继续发送数据**到网络上。

### 6. Socket 控制

PPT介绍了用于精细化控制套接字行为的系统调用：
- **`getsockopt()` / `setsockopt()`**：用于获取或设置套接字的各种选项。PPT虽未列举所有选项，但提到了**Keepalive**的配置，并暗示了其他常用选项（如 `SO_REUSEADDR` 用于解决“Address already in use”错误）的存在。

- **非阻塞 I/O**：
  - PPT说明，可通过 `fcntl()` 系统调用将套接字设置为非阻塞模式：  
    ```c
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NDELAY);
    ```
  - 在非阻塞模式下：
    - 当**发送缓冲区满**时，`write()` 会**立即返回 -1**，并将 `errno` 设置为 `EWOULDBLOCK`（或 `EAGAIN`）。
    - 当**接收缓冲区为空**时，`read()` 同样会**立即返回 -1**，`errno` 为 `EWOULDBLOCK`。
  - 这种模式是实现高性能、高并发服务器（如结合 `select` 或 `epoll`）的基础。

## 四、单进程并发处理

### 1. select：多路 I/O 复用

PPT指出，`select` 系统调用的引入是为了解决**单进程如何同时等待多个事件发生**的问题。它允许用户进程一次性告知内核多个文件描述符（fd）及其关注的事件类型，当其中任意一个或多个事件就绪时，`select` 返回；否则，进程进入睡眠状态等待。

- **函数原型**：
  ```c
  int select(int maxfdp1, fd_set *rfds, fd_set *wfds, fd_set *efds, struct timeval *timeout);
  ```
  其中 `maxfdp1` 是所有被监控的文件描述符中的最大值加 1。

- **功能**：实现**多路 I/O 复用**，使单个进程能并发处理多个网络连接或其他 I/O 源（如管道、终端等）。

- **“准备好”含义**（PPT重点解释）：
  - **读就绪（rfds）**：对某 fd 调用 `read()` **不会阻塞**。这包括以下情况：
    - 接收缓冲区中有数据可读；
    - 对端已关闭连接（`read` 将返回 0）；
    - 发生了网络错误。
  - **写就绪（wfds）**：对某 fd 调用 `write()` **至少可以成功写入 1 个字节**（即发送缓冲区有空闲空间）。
  - **异常就绪（efds）**：PPT特别说明，在 TCP 协议中，“异常情况”**仅指带外数据**（Out-of-Band, OOB）到达。**对端正常关闭连接或网络故障不被视为“异常”**。

此外，PPT强调，`select` 的集合参数（`rfds`, `wfds`, `efds`）是**传入传出型参数**：调用前由用户填充关注的 fd 集合，返回后内核会将其修改为**仅包含就绪的 fd**。

### 2. fd_set 集合操作

PPT介绍了用于操作 `fd_set` 类型（位图集合）的一组标准宏：
- **`FD_ZERO(fd_set *fds)`**：将集合 `fds` 初始化为空集（清零所有位）。
- **`FD_SET(int fd, fd_set *fds)`**：将文件描述符 `fd` 加入集合 `fds`。
- **`FD_CLR(int fd, fd_set *fds)`**：从集合 `fds` 中移除文件描述符 `fd`。
- **`FD_ISSET(int fd, fd_set *fds)`**：检查 `fd` 是否仍在集合 `fds` 中（通常在 `select` 返回后使用，判断该 fd 是否就绪）。

这些宏是使用 `select` 前准备和解析 fd 集合的必备工具。

### 3. timeout 参数

PPT详细说明了 `select` 最后一个参数 `timeout` 的三种取值及其行为：
- **`NULL`**：`select` 将**无限期阻塞**，直到至少有一个被监控的 fd 就绪。
- **`{tv_sec: 0, tv_usec: 0}`**（即 `{0, 0}`）：`select` **立即返回**，无论是否有 fd 就绪。这是一种**非阻塞轮询**方式。
- **`{tv_sec: sec, tv_usec: usec}`**：`select` 最多等待指定的秒数和微秒数。若超时前无 fd 就绪，则返回 0。

PPT还补充了一个重要细节：尽管 `timeval` 结构支持微秒级精度，但**实际定时精度受限于系统时钟中断频率，通常在 10 毫秒左右**。

### 4. 单进程并发服务器（server2.c）

PPT以 `server2.c` 为例，展示了如何利用 `select` 构建一个**单进程并发服务器**：
- 服务器维护一个**监听套接字**（用于接受新连接）和一个**客户端套接字集合**（用于与已连接的客户端通信）。
- 在主循环中，服务器将监听套接字和所有客户端套接字都加入 `select` 的 `rfds` 集合。
- 调用 `select` 后：
  - 如果**监听套接字就绪**，说明有新客户端连接，服务器调用 `accept()` 接受连接，并将新返回的通信套接字加入客户端集合。
  - 如果**某个客户端套接字就绪**，说明该客户端有数据可读，服务器调用 `read()` 处理其请求。
- 通过这种方式，**单个进程即可并发处理多个客户端连接**，避免了多进程模型的资源开销和复杂性。

### 5. libevent 库简介

PPT在最后简要介绍了 `libevent`，作为 `select` 等底层 I/O 多路复用机制的高级封装：
- **定位**：一个用 C 语言编写的、**轻量级、开源、高性能**的事件通知库。
- **跨平台**：支持 **Linux、Windows、BSD、macOS** 等多种操作系统。
- **核心能力**：
  - **自动选择最优的 I/O 多路复用技术**：在 Linux 上使用 `epoll`，在 BSD/macOS 上使用 `kqueue`，在旧系统上回退到 `select`。
  - **事件驱动模型**：不仅支持 I/O 事件，还支持**定时器事件**和**信号事件**。
- **应用场景**：可作为构建高性能网络应用（如 Memcached、Tor）的底层网络库，极大地简化了异步编程的复杂度。

## 五、UDP 通信

### 1. 客户端（udpclient.c）

PPT详细说明了UDP客户端的两种典型使用方式，并强调了关键注意事项：

- **可选 `connect()` 调用**：  
  UDP是无连接协议，但客户端仍可调用 `connect()`。PPT明确指出，此操作**不会产生任何网络流量**（即不发送数据包），其作用仅仅是**在内核中记录下默认的远端端点名**（IP地址和端口号）。此后，对该套接字的 `write()` 或 `send()` 调用将自动将数据发送到该预设地址，无需再指定目标。

- **直接使用 `sendto()`**：  
  客户端也可以完全不调用 `connect()`，而是在每次发送时通过 `sendto()` **显式指定目标地址**。这种方式更为灵活，允许同一个套接字向多个不同的服务器发送数据。PPT指出，如果每次都使用 `sendto`，那么之前的 `connect` 调用就是**不必要的**。

- **重要注意事项**：  
  PPT特别强调一个易错点：**在套接字获得本地端点名之前，不应执行 `read`、`recv` 或 `recvfrom` 等接收操作**。对于未显式调用 `bind()` 的UDP客户端，其本地端口是由系统在**第一次发送数据**（通过 `connect` 或 `sendto`）时**动态分配**的。只有在此之后，套接字才具备完整的本地地址信息，才能合法地接收回应数据。

### 2. 服务端（udpserver.c / udpserver2.c）

PPT描述了UDP服务器的标准工作模式及其增强功能：

- **通常不调用 `connect`**：  
  由于UDP服务器需要与多个不同的客户端通信，它**一般不会调用 `connect()`**，以保持其无连接的灵活性。

- **使用 `recvfrom()` 接收数据**：  
  服务器通过 `recvfrom()` 系统调用来接收客户端发来的数据报。该函数不仅能读取数据，还能**同时获取发送方的地址信息**（IP和端口），这是实现对特定客户端响应的关键。

- **使用 `sendto()` 进行回复**：  
  服务器在处理完请求后，使用 `sendto()` 将响应数据发回给客户端。其目标地址参数**直接使用 `recvfrom()` 返回的客户端地址**，从而实现精准回复。

- **结合 `select` 实现超时控制**：  
  PPT提到，UDP服务器可以利用 `select` 系统调用实现**超时机制**。例如，服务器可以设置一个定时器，如果在指定时间内（如 N 秒）没有收到任何客户端数据，则执行超时后的动作（如退出或记录日志）。这通常通过将 `select` 的 `timeout` 参数设为非空值来实现，并配合 `time(0)` 或 `gettimeofday()` 进行时间计算。

### 3. UDP 通信特点

PPT总结了UDP协议区别于TCP的核心特性，这些特性直接影响编程模型：

- **无连接、不可靠、无流控**：  
  UDP通信前无需建立连接；协议本身**不保证数据报的可靠传输**，数据可能丢失、重复或乱序；同时，**没有内置的流量控制机制**，发送方速率不受接收方处理能力制约。

- **`read` 在无数据时阻塞**：  
  与TCP类似，当对UDP套接字调用 `read()`（或 `recv()`）而接收缓冲区中**没有数据报时，进程会阻塞等待**，直到有数据到达或套接字被关闭。

- **无“粘包”问题**：  
  PPT明确指出，UDP以**数据报**（Datagram）为单位进行传输。**每一次 `sendto()` 调用对应一个独立、完整的数据报**，接收方的一次 `recvfrom()` 调用也恰好读取一个完整的数据报。因此，UDP**天然保留了应用层消息的边界**，不存在TCP中的“粘包”或“拆包”问题，简化了应用层协议的设计。

## 六、Socket 编程小结
- 协议栈实现层次：
  - 用户态：应用层
  - 内核态：传输层、网络层
  - 硬件：链路层、物理层
- Socket 是**特殊文件**，统一了设备、管道、网络的访问接口
- 端点名 = IP 地址 + 端口号
- TCP 服务器需多个 socket：
  - 1 个监听 socket（用于 `accept`）
  - N 个通信 socket（每个客户端 1 个）
- 网络故障感知依赖协议机制（如 Keepalive、ACK 超时）
- 并发模型选择：
  - 多进程：简单但资源开销大
  - 单进程 + `select`：轻量但编程复杂
- UDP 适合短小、实时、容忍丢失的场景

--- 
