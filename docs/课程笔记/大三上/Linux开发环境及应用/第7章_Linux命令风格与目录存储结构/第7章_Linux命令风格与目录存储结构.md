# 第7章：Linux命令风格与目录存储结构

## 一、Linux命令获取信息的方式和风格

### 1. 命令获取信息的方法

根据PPT内容，Linux系统命令与用户程序（ap）在操作系统内核视角下并无本质区别——**两者都属于用户态程序**。这意味着无论是系统自带的`ls`、`grep`，还是用户自行编写的可执行程序，在运行机制上地位平等。

这些程序在运行时通常需要获取以下三类信息：

- **配置信息**：如服务器地址、语言环境、默认行为偏好等；
- **处理方式（选项参数）**：决定程序如何处理数据，例如是否显示详细输出、是否递归处理子目录等；
- **被处理的对象**：即操作的目标，如文件路径、设备名、网络地址等。

PPT强调，若将这些信息**硬编码**（hard-coded）进程序源码（例如使用 `#define SERVER "180.249.151.131"`），会导致程序缺乏灵活性——一旦部署后就无法更改，违背了软件设计中“配置与代码分离”的基本原则。因此，Linux生态普遍采用更灵活的运行时信息获取机制。

---

### 2. 运行时获取信息的常见方式（按易变性从小到大排序）

PPT明确指出，Linux程序在运行时获取信息的方式按**易变性由低到高**可分为五类，并对每种方式的适用场景、优缺点进行了说明。

#### （1）硬编码（不推荐）

- **定义**：在源代码中直接写死配置值。
- **示例**：  
  ```c
  #define SERVER "180.249.151.131"
  main() { ... }
  ```
- **问题**：  
  PPT明确批评这种方式“**太不灵活**”，因为程序一旦编译完成，其行为就完全固定，无法适应不同运行环境的需求。
- **结论**：仅适用于教学演示或极端静态场景，**生产环境中应避免**。

#### （2）配置文件

- **适用场景**：较复杂的程序（如Web服务器、数据库、Shell环境）通常提供配置文件。
- **分类**：
  - **系统级配置**：影响所有用户，如 `/etc/profile`；
  - **用户级配置**：仅影响特定用户，如 `~/.bash_profile` 或 `~/.vimrc`。
- **特点**：
  - 同一个可执行文件，因读取不同用户的配置文件而表现出不同行为；
  - 配置信息**持久化存储**，适合长期不变或低频变更的设置；
  - 修改后通常需重启程序或重新加载配置才能生效，**变更不够便捷**。
- **PPT评价**：提供了良好的灵活性，但不适合频繁变动的参数。

#### （3）环境变量

- **定位**：用于传递“**与运行环境相关**”的少量、通用配置信息。
- **典型变量**（PPT列举）：
  - `LANG`：语言与区域设置；
  - `HOME`：用户主目录；
  - `TERM`：终端类型；
  - `PATH`：可执行文件搜索路径；
  - `CLASSPATH`：Java类库路径；
  - `CVSROOT`：CVS版本控制系统根路径。
- **工作机制**：
  - 程序通过标准库函数（如C语言的 `getenv()`）读取环境变量；
  - 用户可通过Shell命令（如 `export VAR=value`）动态设置；
  - 同一可执行文件在不同环境中因环境变量不同而行为不同。
- **优势**（PPT强调）：
  - **性能开销小**：相比读取配置文件，访问内存中的环境变量更快；
  - **跨命令共享**：多个命令可继承同一组环境变量，保持行为一致性。
- **局限**：不适合存储大量或结构化数据。

#### （4）命令行参数

- **时机**：在**程序启动前**由操作员通过命令行指定。
- **作用范围**：仅对当前命令实例有效，**不影响后续命令**。
- **PPT重点介绍了三种主流风格**：

  **① dd 风格（param=value 形式）**  
  - 特点：参数以 `key=value` 形式出现，无前导符号。  
  - 示例：  
    ```bash
    dd if=sysdisk.img of=/dev/sdb          # 拷贝镜像到硬盘
    dd if=/dev/urandom of=test.dat bs=1024 count=512  # 生成512KB测试文件
    ```
  - 参数含义：`if`（输入文件）、`of`（输出文件）、`bs`（块大小）、`count`（块数量）。

  **② find / gcc 风格（长单词选项）**  
  - 特点：以单个连字符 `-` 开头，后接多字符选项名。  
  - 示例：  
    ```bash
    find src -name '*.c' -type f -exec dos2unix --keepdate {} \;
    gcc -O0 -Wall -g -masm=intel -Wa,-ahl -c shudu.c
    ```
  - 说明：选项可带参数（如 `-name '*.c'`），也可组合多个独立选项。

  **③ ls / grep 风格（现代主流，支持长短选项）**  
  - 特点：
    - **短选项**：单字符，以 `-` 开头（如 `-a`, `-l`）；
    - **长选项**：多字符，以 `--` 开头（如 `--all`, `--human-readable`）；
    - 同一功能常同时提供两种形式（如 `-h` 与 `--human-readable`）；
    - 短选项可**连写**（如 `ls -Fashw80`）；
    - 选项可**置于参数前后**（如 `ls /home -l` 或 `ls -l /home`）；
    - 使用 `--` 显式标记选项结束，后续内容均视为操作对象。
  - 示例对比：  
    ```bash
    ls --classify --all --size --human-readable --width=80 /home/jiang  # 全长选项
    ls -Fashw80 /home/jiang                                            # 短选项连写
    ls -F -a -s -h -w 80 /home/jiang                                   # 短选项分开
    ls -F -w80 /home/jiang -has                                        # 选项穿插
    ```
  - **实现机制**：PPT指出，此类风格的选项解析通常由C标准库中的 `getopt_long()` 函数统一处理，便于开发者实现一致的命令行接口。

#### （5）交互式键盘输入（Linux命令中极少使用）

- **定义**：程序启动后，通过标准输入（stdin）与用户进行人机交互以获取信息。
- **PPT观点**：在**Linux命令行工具中极少采用**此方式，因其违背“非交互、可脚本化”的Unix哲学。
- **技术实现**：
  - C语言中可通过 `scanf()`、`fgets()` 等函数读取用户输入；
  - 适用于交互式应用程序（如文本编辑器、游戏），但**不适用于自动化脚本场景**。
- **对比**：与前四种方式相比，交互式输入**延迟高、不可预测、难以自动化**，故Linux核心命令几乎不采用。

---

综上，PPT通过对比五种信息获取方式，阐明了Linux命令设计的核心理念：**优先使用命令行参数和环境变量实现灵活、高效、可脚本化的配置机制，避免硬编码和交互式输入**。这一思想深刻影响了Linux工具链的设计风格与使用习惯。

## 二、Linux文件系统

### 1. 文件系统的创建与安装

PPT明确指出，Linux采用**统一的树状目录结构**，所有存储设备（包括本地硬盘、U盘、光盘、网络文件系统等）都必须**挂载（mount）到该目录树中的某个子目录下**，才能被访问。这与Windows使用独立盘符（如C:\、D:\）的方式有本质区别。

- **根文件系统（root filesystem）**  
  - 是整个Linux文件系统层次结构的起点，挂载在 `/`。
  - 由内核在启动时加载，**无法被卸载（umount）**，是系统运行的基础。
  - 包含启动和运行基本命令所必需的目录（如 `/bin`, `/sbin`, `/etc`, `/dev` 等）。

- **子文件系统（Sub Filesystems）**  
  - 指除根文件系统外的所有其他文件系统实例。
  - 来源多样：物理设备（如 `/dev/sdb1`）、虚拟设备（如 tmpfs）、网络文件系统（如 NFS、CIFS）等。
  - 挂载点必须是**已存在的空目录**（通常位于 `/mnt` 或 `/media` 下）。
  - 每个子文件系统可采用**不同的文件系统类型**（如 ext4、xfs、ntfs、iso9660），拥有**独立的元数据结构**（如各自的超级块和i节点区）。

- **关键操作命令（PPT重点列举）**：
  - `mkfs /dev/sdb`：在指定块设备上**创建新的文件系统**（实际常需指定类型，如 `mkfs.ext4 /dev/sdb1`）；
  - `mount /dev/sdb /mnt`：将设备 `/dev/sdb` 挂载到目录 `/mnt`，此后访问 `/mnt` 即访问该设备内容；
  - `mount`（无参数）：**列出当前所有已挂载的文件系统及其挂载点、类型、选项**；
  - `umount /dev/sdb` 或 `umount /mnt`：通过设备名或挂载点**卸载文件系统**（需确保无进程正在使用）；
  - `df`：显示各文件系统的**磁盘空间使用情况**；
    - `df -h`：以**人类可读格式**（如 KB、MB、GB）展示容量和剩余空间，便于运维。

> PPT强调：挂载的本质是将一个独立的文件系统“嫁接”到全局目录树中，使得用户可通过统一路径访问异构存储资源。

---

### 2. 文件系统的存储结构

PPT从底层磁盘布局出发，详细解析了Linux文件系统（以传统类Unix文件系统如ext2/ext3为例）的内部组织方式。

#### （1）整体结构（按磁盘块划分）

Linux文件系统在磁盘上按固定大小的**块（block）** 组织，典型结构如下：

| 块号 | 名称         | 说明 |
|------|--------------|------|
| 0    | 引导块（Boot Block） | **仅根文件系统有效**，存放引导加载程序（如 GRUB stage1），用于系统启动；非根文件系统此块通常为空。 |
| 1    | 超级块（Superblock） | 存储**整个文件系统的元信息**，包括：总块数、空闲块数量与链表、i节点总数与空闲列表、块大小、文件系统状态（clean/dirty）等。 |
| ≥2   | i节点区 + 数据块区 | 后续块分为两大部分：i节点区（存储元数据）和数据块区（存储文件内容）。 |

- **`mkfs` 的作用**：初始化超级块，建立空闲块和i节点的管理结构。
- **`df` 的实现原理**：通过读取超级块中的空闲块信息，计算并显示可用空间。

#### （2）i节点区（inode区）

- **核心概念**：每个文件（包括普通文件、目录、设备文件等）在文件系统中都有一个唯一的 **i节点（inode）** 与之对应。
- **i节点包含的关键元数据**（PPT逐项列出）：
  - 文件类型（普通文件、目录、符号链接、设备等）；
  - 访问权限（rwx）；
  - 所属用户（UID）和用户组（GID）；
  - **硬链接计数（link count）**；
  - 文件大小（以字节为单位）；
  - 三个时间戳：
    - `atime`：最后访问时间；
    - `mtime`：最后内容修改时间；
    - `ctime`：最后状态变更时间（如权限、属主变化）；
  - **指向数据块的指针数组**（直接、间接、双重间接、三重间接），实现逻辑地址到物理块的映射。
- **重要特性**：
  - **i节点不包含文件名**！文件名仅存在于目录项中；
  - i节点大小固定（早期为64字节，现代ext4为256字节），编号从1开始（0号保留）；
  - i节点号（inode number）是文件在文件系统内的唯一标识。

#### （3）文件存储区（数据块区）

- 存放所有文件的**实际数据内容**。
- **特别说明**：**目录本身也是文件**，其内容即“目录表”，也存储在此区域。
- 因此，目录的“大小”反映的是其目录表占用的字节数，而非其所含文件的总大小。

#### （4）目录的存储结构

- 目录在磁盘上表现为一个**特殊的数据文件**，其内容是由若干 **目录项（directory entry）** 构成的线性表。
- **每个目录项包含两个字段**：
  - **文件名（filename）**：用户可见的名称；
  - **i节点号（inode number）**：指向该文件元数据的索引。
- 当执行 `ls` 命令时：
  - 首先读取目录文件的内容（即目录项列表）；
  - 对每个目录项，根据i节点号去i节点区查找对应元数据（如权限、大小、类型）；
  - 最终组合显示文件名及其属性。
- **`ls -l` 显示的目录大小**（如 `drwxr-xr-x 2 user group 4096 ...` 中的4096）即该目录文件（目录表）本身占用的字节数。

#### （5）目录表与i节点的两级结构（设计目的：提高检索效率）

PPT通过对比说明了Linux采用**两级存储结构**的优势：

- **若采用一级结构**（文件名与全部元数据共存于目录项中）：
  - 目录项体积大（因包含完整权限、时间、指针等）；
  - 单个磁盘块能容纳的目录项数量少；
  - 列出大目录时需读取大量磁盘块，效率低下。

- **Linux采用的两级结构**：
  - **目录项极简**：仅含“文件名 + i节点号”；
  - **i节点集中存储**：所有元数据统一放在i节点区；
  - **优势**：
    - 目录项小 → 单块可存更多条目 → 减少I/O次数；
    - 支持**硬链接**（多个目录项指向同一i节点）；
    - 元数据访问局部性好，利于缓存。

> 这一设计是Unix/Linux文件系统高效处理海量小文件的关键。

#### （6）查看i节点信息

- **核心命令**：`stat filename`
- **输出内容**（PPT强调包含以下关键字段）：
  - `Size`：文件字节大小；
  - `Blocks`：实际占用的512字节块数（注意：稀疏文件可能 `Size > Blocks × 512`）；
  - `Inode`：i节点号；
  - `Links`：硬链接数；
  - `Access/Modify/Change`：三个时间戳；
  - `Uid/Gid`：属主与属组；
  - `Access`：权限位（如 `-rw-r--r--`）。
- **用途**：用于调试文件属性、排查权限问题、理解硬链接机制等。

---

综上，PPT通过对文件系统创建、挂载机制及底层存储结构的剖析，揭示了Linux如何通过**统一挂载模型**和**高效的两级元数据设计**，实现对异构存储设备的透明管理和高性能文件访问。这一部分为理解后续的硬链接、符号链接及系统调用奠定了基础。

## 三、硬连接（Hard Link）

### 1. 定义

根据PPT内容，**硬连接（Hard Link）** 是Linux文件系统中一种基于i节点机制的文件引用方式。其核心原理是：

- **多个目录项（即多个文件名）指向同一个i节点**；
- 由于i节点唯一标识了文件的元数据和数据块位置，因此所有硬连接**共享完全相同的文件内容和属性**；
- 文件系统通过维护一个**硬连接计数（link count）** 来记录当前有多少个目录项引用该i节点。

> 换言之，硬连接不是“副本”，而是对同一份物理数据的**多个入口名称**。从用户视角看，它们是“不同的文件名”；从系统视角看，它们是“同一个文件”。

---

### 2. 创建与特性

PPT明确指出硬连接的创建方法及其关键限制条件：

- **创建命令**：  
  ```bash
  ln source_file hard_link_name
  ```
  执行后，`hard_link_name` 成为 `source_file` 的另一个硬连接，两者具有相同的i节点号。

- **核心特性**（PPT逐条强调）：
  1. **仅适用于普通文件**  
     - **不能对目录创建硬连接**（这是出于防止目录树出现环路的安全设计）；
     - 特殊文件（如设备文件、管道、套接字）通常也不支持。
  
  2. **必须位于同一文件系统内**  
     - 因为i节点号仅在单个文件系统内部唯一；
     - 跨设备（如从 `/dev/sda1` 到 `/dev/sdb1`）无法共享i节点，故硬连接不可跨挂载点或分区。

  3. **所有硬连接地位完全平等**  
     - 不存在“源文件”与“链接文件”的主从关系；
     - 任意一个硬连接被删除（`rm`），只要**link count > 0**，文件数据和i节点仍保留；
     - 只有当link count降为0且无进程打开该文件时，系统才会回收其数据块。

> PPT举例说明：若对 `file.txt` 创建硬连接 `copy.txt`，随后删除 `file.txt`，`copy.txt` 依然可正常访问原内容，因为底层i节点未被释放。

---

### 3. 目录的硬连接

PPT特别解释了**目录本身也存在硬连接机制**，这是理解目录结构和link count的关键：

- **每个目录默认拥有两个硬连接**：
  - `.`（点）：代表当前目录自身，是一个指向本目录i节点的目录项；
  - `..`（双点）：代表父目录，是一个指向上级目录i节点的目录项（根目录 `/` 的 `..` 指向自身）。

- **目录的硬连接数计算公式**：  
  \[
  \text{目录的 link count} = 2 + \text{直属子目录的数量}
  \]
  - 初始值为2（来自 `.` 和 `..`）；
  - 每创建一个**子目录**，该子目录中的 `..` 项会指向当前目录，从而使其link count加1；
  - 普通文件或符号链接的创建**不会增加**父目录的link count。

> **示例**：  
> 若目录 `/home/user` 下有子目录 `docs` 和 `src`，则：  
> - `/home/user` 的link count = 2（`.` 和 `..`）+ 2（来自 `docs/..` 和 `src/..`）= **4**；  
> - 执行 `ls -ld /home/user` 可看到第二列数字为4。

> PPT指出，这一机制使得系统能准确追踪目录的引用关系，也是 `find`、`du` 等工具判断目录嵌套深度的基础。

---

综上，PPT通过硬连接的定义、创建规则及目录特例，深入揭示了Linux文件系统如何利用i节点实现高效、安全的文件引用机制。硬连接不仅是节省存储空间的手段，更是理解文件生命周期、目录结构和系统行为的重要概念。

## 四、符号连接（Symbolic Link / 软连接）

### 1. 定义与实现

根据PPT内容，**符号连接（Symbolic Link）**，又称**软连接（Soft Link）**，是Linux中一种特殊的文件类型，其本质与硬连接有根本区别：

- **实现方式**：  
  符号连接本身是一个**独立的文件**，其**文件内容仅包含一个路径字符串**（即目标文件或目录的路径名）。该路径可以是绝对路径，也可以是相对路径。

- **创建命令**：  
  ```bash
  ln -s target linkname
  ```
  其中 `target` 是被指向的目标（可以不存在），`linkname` 是新建的符号连接文件名。

- **显示特征**：  
  使用 `ls -l` 查看时，符号连接具有以下显著标识：
  - 文件类型首字符为 `l`（如 `lrwxrwxrwx`）；
  - 权限位通常显示为 `rwxrwxrwx`（仅为形式，实际权限由目标文件决定）；
  - 行末以 `->` 明确指示所指向的目标路径。  
    示例：  
    ```bash
    lrwxrwxrwx 1 user group 12 Jun 10 10:00 mylink -> /etc/passwd
    ```

> PPT强调：符号连接**拥有自己的i节点**，其数据块中存储的不是用户数据，而是目标路径字符串。

---

### 2. 路径解析规则

PPT特别指出符号连接路径解析的**关键细节**，这是初学者常混淆之处：

- **绝对路径目标**：  
  若符号连接的内容是绝对路径（如 `/home/user/data.txt`），则无论从何处访问该链接，系统都直接按此绝对路径定位目标。

- **相对路径目标**：  
  **解析基准是符号连接文件自身所在的目录**，而非当前工作目录（current working directory）。  
  这一规则至关重要，PPT通过具体示例加以说明：

  > **示例场景**：  
  > 当前位于目录 `/home/user`，执行命令：  
  > ```bash
  > ln -s d1/dlb d1/dx
  > ```  
  > 此命令在 `d1/` 子目录下创建一个名为 `dx` 的符号连接，其内容为字符串 `d1/dlb`。  
  > 
  > **解析过程**：  
  > - `dx` 位于 `/home/user/d1/`；  
  > - 其目标路径 `d1/dlb` 是相对路径；  
  > - 系统以 `dx` 所在目录（即 `/home/user/d1/`）为基准进行拼接；  
  > - 最终解析为：`/home/user/d1/d1/dlb`。  

  因此，若误以为相对路径基于当前工作目录，极易导致“目标不存在”或“指向错误位置”的问题。

> PPT提醒：设计符号连接时，若需跨目录引用，**优先使用绝对路径**可避免此类歧义。

---

### 3. 与硬连接的比较

PPT通过对比表格清晰阐明了符号连接与硬连接在多个维度上的本质差异：

| 特性             | 硬连接（Hard Link）                          | 符号连接（Symbolic Link）                     |
|------------------|---------------------------------------------|-----------------------------------------------|
| **实现层次**     | 文件系统**数据结构层**：多个目录项共享同一i节点 | **软件算法层**：通过路径字符串重定向访问目标       |
| **适用对象**     | **仅普通文件**（不能用于目录）                | **文件和目录均可**                             |
| **跨文件系统**   | **不支持**（i节点号仅在单个文件系统内有效）    | **支持**（路径可跨越不同挂载点或设备）           |
| **删除原文件影响** | i节点的link count减1；只要>0，文件仍可访问     | 链接变为“**悬空（dangling）**”，访问时报“No such file or directory” |
| **系统开销**     | **无额外开销**（直接访问i节点）               | 内核需**解析路径字符串**，可能涉及多次目录查找，有轻微性能开销 |
| **循环风险**     | **无**（目录禁止硬连接，天然无环）            | **可能存在循环引用**（如 A → B → A），内核通过最大解析深度计数器防止死循环 |

> PPT总结：  
> - **硬连接**适用于同一文件系统内对普通文件的高效别名管理；  
> - **符号连接**则提供了更大的灵活性，尤其适合跨文件系统、指向目录或需要“可断开”引用的场景（如软件版本切换、配置文件集中管理等）。

---

综上，PPT通过对符号连接的定义、路径解析机制及与硬连接的系统性对比，完整揭示了其作为Linux文件系统重要抽象工具的设计思想与实用价值。正确理解符号连接的行为，对于编写健壮脚本、管理复杂项目结构以及排查“文件找不到”类问题具有重要意义。

## 五、Linux系统调用（System Call）

### 1. 基本概念

PPT明确指出，**系统调用（System Call）是用户空间应用程序与Linux内核进行交互的唯一合法接口**。所有对硬件资源、文件系统、进程控制等底层操作，都必须通过系统调用来完成。

- **表现形式**：  
  系统调用在C语言中以标准函数的形式提供，例如：
  - `open()`、`read()`、`write()`、`close()`（文件I/O）
  - `fork()`、`exec()`、`exit()`（进程管理）
  - `stat()`、`chmod()`、`chown()`（文件属性操作）

- **数量规模**：  
  Linux内核提供了约**300个系统调用**，覆盖了操作系统核心功能的方方面面。

- **与库函数的本质区别**（PPT重点强调）：
  | 类型         | 调用机制                     | 执行环境   | 示例                |
  |--------------|------------------------------|------------|---------------------|
  | **系统调用** | 通过**软中断（如 INT 0x80 或 syscall 指令）** 切入内核态 | 内核态     | `read()`, `write()` |
  | **库函数**   | 普通函数调用（`CALL` 指令）    | 用户态     | `strcpy()`, `malloc()` |

  > 特别说明：许多标准库函数（如 `printf()`）**内部封装了系统调用**（如 `write()`），但其本身不是系统调用。这种分层设计提高了可移植性和开发效率。

---

### 2. 错误处理机制

由于系统调用直接操作底层资源，失败是常见情况。PPT详细介绍了Linux统一的错误报告机制：

- **返回值约定**：
  - **成功**：返回 ≥ 0 的值（如 `read()` 返回读取字节数，`open()` 返回文件描述符）；
  - **失败**：统一返回 **-1**。

- **错误码存储**：  
  失败时，内核会将具体的错误原因编码写入一个**全局变量 `errno`**（需包含头文件 `<errno.h>`）。
  - 常见错误码包括：
    - `EACCES`（权限不足）
    - `ENOENT`（文件或目录不存在）
    - `EIO`（I/O错误）
    - `ENOMEM`（内存不足）
    - `EINTR`（系统调用被信号中断）

- **错误信息输出方式**：
  - **`strerror(errno)`**：将 `errno` 的数值转换为人类可读的字符串（如 `"Permission denied"`）；
  - **`perror(const char *s)`**：直接打印带前缀的错误信息（如 `perror("open")` 输出 `open: Permission denied`）；
  - **`printf("%m")`**（GNU扩展）：在格式化输出中自动替换为当前 `errno` 对应的错误消息，无需显式调用 `strerror`。  
    示例：
    ```c
    if (open("protected.txt", O_RDONLY) == -1)
        printf("Failed to open file: %m\n");  // 自动显示错误原因
    ```

> PPT提醒：`errno` **仅在系统调用返回 -1 时有效**；成功调用不会清零 `errno`，因此不能依赖其“非零即错”的逻辑。

---

### 3. 访问i节点与目录

PPT聚焦于如何通过系统调用和配套库函数获取文件元数据（i节点信息）及遍历目录结构。

#### （1）获取文件状态：`stat` / `fstat`

- **`stat(const char *path, struct stat *buf)`**  
  通过**文件路径名**获取其i节点信息，适用于已知文件名的场景。
  
- **`fstat(int fd, struct stat *buf)`**  
  通过**已打开的文件描述符（fd）** 获取i节点信息，避免重复路径解析，效率更高。

- 两者均将结果填充到 `struct stat` 结构体中。

#### （2）`struct stat` 关键字段

PPT列出了该结构体的核心成员及其含义：

```c
struct stat {
    dev_t    st_dev;     // 文件所在设备的主/次设备号
    ino_t    st_ino;     // i节点号（文件在文件系统内的唯一标识）
    mode_t   st_mode;    // 文件类型（S_IFREG, S_IFDIR等）与权限位（rwx）
    nlink_t  st_nlink;   // 硬连接数（link count）
    uid_t    st_uid;     // 文件属主的用户ID
    gid_t    st_gid;     // 文件所属组的组ID
    off_t    st_size;    // 文件字节大小（仅对普通文件有效）
    blkcnt_t st_blocks;  // 实际占用的512字节块数（注意：稀疏文件可能 st_size > st_blocks*512）
    struct timespec st_atim; // 最后访问时间（atime）
    struct timespec st_mtim; // 最后内容修改时间（mtime）
    struct timespec st_ctim; // 最后状态变更时间（ctime，如权限、属主变化）
};
```

> **特别说明**：  
> - 通过 `st_mode & S_IFMT` 可提取文件类型（如判断是否为目录）；  
> - `st_blocks` 反映真实磁盘占用，对监控存储使用至关重要。

#### （3）目录访问

PPT指出，**不能像普通文件一样用 `open/read` 直接读取目录内容**。Linux提供了专用的目录流操作函数：

- **`opendir(const char *name)`**  
  打开指定目录，返回 `DIR*` 类型的目录流指针（类似 `FILE*`）。

- **`readdir(DIR *dirp)`**  
  从目录流中读取下一个目录项，返回 `struct dirent*` 指针，其关键字段包括：
  - `ino_t d_ino`：该目录项对应的i节点号；
  - `char d_name[]`：文件名（不含路径）。

- **`closedir(DIR *dirp)`**  
  关闭目录流，释放资源。

> 这些函数由C标准库（glibc）实现，底层仍调用系统调用（如 `getdents`），但为开发者提供了更安全、可移植的接口。

#### （4）编程应用

PPT强调，掌握上述接口是**深入理解Linux命令实现原理的基础**：

- **组合使用 `readdir` + `stat`** 可构建功能强大的文件工具：
  - 自定义 `ls`：列出目录内容并显示权限、大小、时间等；
  - 自定义 `find`：递归遍历目录树，按条件筛选文件；
  - 自定义 `du`：统计目录磁盘占用；
  - 安全版 `rm -rf`：增加确认逻辑或回收站机制。

- **教学意义**：  
  通过亲手实现这些工具，开发者能真正理解 `ls -l` 背后的i节点查询、硬链接计数、时间戳含义等核心概念，从而摆脱“黑盒”操作，具备系统级调试能力。

---

综上，PPT通过对系统调用的概念、错误处理规范及文件/目录访问接口的系统讲解，为开发者搭建了从用户程序通往内核的桥梁。这部分内容不仅是Linux系统编程的基石，也是理解操作系统行为、编写高效可靠程序的关键所在。