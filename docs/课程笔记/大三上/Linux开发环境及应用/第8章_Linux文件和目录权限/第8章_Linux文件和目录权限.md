# 第8章：Linux文件和目录权限

## 一、文件的权限

### 1. 权限的基本概念

Linux 文件系统通过**三级用户模型**实现对文件访问的精细控制，确保系统安全性和多用户协作的可行性。根据 PPT 内容，这三级用户分别是：

- **文件主（User/Owner）**：创建文件的用户，对该文件拥有最高控制权。
- **同组用户（Group）**：与文件主属于同一用户组的其他用户。
- **其他用户（Other）**：既不是文件主、也不在文件所属组中的所有其他用户。

每个文件在 inode（索引节点）中记录了其**唯一的属主 UID（User ID）**和**所属组 GID（Group ID）**。这些数字 ID 在系统中通过 `/etc/passwd` 和 `/etc/group` 文件映射为可读的用户名和组名。

对于普通文件（非目录、非设备等），系统定义了三种基本权限：

- **读（r）**：允许读取文件内容（如使用 `cat`、`less` 等命令）。
- **写（w）**：允许修改或覆盖文件内容（如使用 `echo >>`、`vi` 编辑等）。
- **执行（x）**：允许将该文件作为程序运行（对脚本或二进制程序而言）。

值得注意的是，权限的作用对象是**进程**而非用户本身。当一个进程试图访问文件时，系统会根据该进程的 UID/GID 与文件的 UID/GID 进行比对，并依据上述三级权限模型决定是否授权访问。

此外，PPT 特别强调：**超级用户 root 不受任何文件权限限制**，可以无视 r/w/x 设置直接访问任意文件。

---

### 2. 文件删除的特殊说明

PPT 中明确指出一个常被误解的关键点：**文件能否被删除，不取决于文件自身的写权限，而取决于其所在目录的写权限**。

这是因为“删除文件”本质上是**从目录中移除该文件的目录项（directory entry）**，属于对目录结构的修改操作。因此：

- 即使一个文件被设置为只读（如 `chmod u-w file`），只要其所在目录对当前用户具有写权限，该文件仍可被删除。
- 反之，若目录无写权限（如 `chmod u-w .`），即使文件本身可写，也无法被删除或重命名。

PPT 通过演示案例验证了这一点：
```bash
$ chmod u-w mydata          # 文件设为只读
$ who >> mydata             # 写入失败
mydata: The file access permissions do not allow the specified action.
$ rm mydata                 # 但可删除（因目录可写）
rm: Remove mydata? y
```
此行为凸显了 Linux 中“目录是一种特殊文件”的设计理念——目录的内容是文件名到 inode 的映射表，修改该表即需目录的写权限。

---

### 3. 两类可执行文件

PPT 将可执行文件分为两类，并详细说明了它们的运行机制：

#### （1）程序文件（二进制可执行文件）
- 是由编译器生成的、符合操作系统加载格式（如 ELF）的**CPU 指令集合**。
- 可被内核直接识别并加载到内存中执行，无需中间解释器。
- 典型例子包括 `/bin/ls`、`/usr/bin/gcc` 等系统命令。

#### （2）脚本文件（文本文件）
- 本质是纯文本文件，包含一系列命令或代码。
- **不能由内核直接执行**，必须通过解释器（interpreter）运行。
- 默认解释器为 `/bin/sh`（POSIX shell）。
- 用户可通过在文件**第一行**添加 **shebang（`#!`）** 显式指定解释器，例如：
  ```bash
  #!/bin/bash    # 使用 Bash 解释
  #!/usr/bin/python3  # 使用 Python3
  #!/usr/bin/bc   # 使用 bc 计算器
  ```
  > 注意：`#!` 必须是文件开头的前两个字符，且路径必须是绝对路径。

当用户执行脚本时，系统会：
1. 读取脚本首行的 `#!` 指令；
2. 启动指定的解释器程序；
3. 将脚本文件作为参数传递给该解释器；
4. 由解释器创建新进程并逐行解析执行脚本内容。

因此，脚本的“执行”实际上是**解释器进程在运行**，而非脚本自身成为可执行进程。这也意味着脚本文件必须同时具备：
- **x 权限**（允许被当作程序调用）；
- **r 权限**（解释器需读取其内容）。

PPT 强调，这种机制使得用户甚至可以编写自己的应用程序作为解释器，极大增强了系统的灵活性。

## 二、目录的权限

### 1. 目录的读写权限

在 Linux 中，**目录本质上是一种特殊类型的文件**，其内容是一张“目录表”（directory table），记录了该目录下所有文件和子目录的名称及其对应的 inode 编号。因此，对目录的权限控制直接决定了用户能否操作这张表。

- **读权限（r）**  
  - 允许用户**列出目录中的内容**，例如执行 `ls` 命令。
  - 若目录无读权限（如 `chmod u-r dir`），即使知道其中某个文件名，也无法通过 `ls` 查看目录项；`ls dir` 将失败并提示“Permission denied”。
  - 注意：仅有读权限而无执行权限时，虽然能看到文件名，但**无法访问这些文件的内容或元数据**（见第2节）。

- **写权限（w）**  
  - 允许用户**修改目录表**，即：
    - 创建新文件或子目录（`touch newfile`, `mkdir subdir`）
    - 删除已有文件或目录（`rm file`, `rmdir subdir`）
    - 重命名文件（`mv oldname newname`）
  - **关键说明**：  
    - 修改**文件内容**（如 `echo "data" >> file`）仅依赖于**文件自身的写权限**，与所在目录的写权限无关。
    - 因此，“目录无写权限”**不等于**“目录下所有文件都不能写”。只要文件本身可写，内容仍可被修改。
  - PPT 强调：删除文件的能力由**目录的写权限**决定，而非文件本身的权限（这与前一节“文件删除”逻辑一致）。

---

### 2. 目录的执行权限（x）

目录的**执行权限（x）** 是最容易被误解但至关重要的权限位。它并不表示“运行目录”，而是表示**允许进入（cd）或遍历（traverse）该目录**。

- **作用机制**：
  - 当系统解析一个路径（如 `/a/b/c`）时，必须逐级访问每个父目录。
  - 对每一级目录（`/`、`/a`、`/a/b`），进程都必须拥有 **x 权限**，才能“穿过”该目录到达下一级。
  - 最终目标文件（`c`）则需具备相应的 r/w/x 权限以完成具体操作。

- **典型示例**：
  - 执行 `cat /home/user/docs/report.txt` 要求：
    - `/`、`/home`、`/home/user`、`/home/user/docs` 均有 **x 权限**
    - `report.txt` 有 **r 权限**
  - 执行 `cd ../st8` 要求：
    - 当前目录（`.`）有 x 权限（用于访问 `..`）
    - 父目录（`..`）有 x 权限（用于查找 `st8`）
    - `st8` 目录本身有 x 权限（才能成功进入）

- **权限组合行为**（PPT 演示案例）：
  - **有 r 无 x**：可 `ls` 列出文件名，但无法 `cat file` 或 `cd subdir`（因无法解析路径）。
  - **有 x 无 r**：无法 `ls`，但若已知文件名，可直接访问其内容（如 `cat dir/known_file` 成功）。
  - **有 w 无 x**：无法创建或删除文件，因为写操作也需先“进入”目录。

因此，**x 权限是路径解析的基础**，缺少它将导致“路径不可达”。

---

### 3. STICKY 权限（粘着位）

STICKY 位（sticky bit）是一个特殊的权限标志，用字母 `t`（当其他用户有 x 权限时）或 `T`（无 x 权限时）表示，设置在目录的“其他用户”执行位上。

- **历史用途**（已废弃）：
  - 早期 Unix 系统中，对可执行文件设置 sticky 位可使其常驻内存，加快后续执行速度。
  - 现代 Linux 内核已忽略文件上的 sticky 位，**仅对目录有效**。

- **现代用途**：
  - 用于**公共可写目录**（如 `/tmp`、`/var/tmp`），防止用户误删或恶意删除他人文件。
  - **规则**：若目录设置了 sticky 位（且具有写权限），则：
    - 只有**文件的属主**、**目录的属主**或 **root 用户** 可以删除或重命名该目录中的文件。
    - 即使其他用户对该目录有写权限，也不能删除不属于自己的文件。

- **典型示例**：
  - `/tmp` 目录权限通常为 `drwxrwxrwt`（即 `1777`）：
    - 所有用户可读、写、进入；
    - 但用户 A 创建的文件，用户 B 无法删除（除非 B 是 root 或文件属主）。
  - 设置方法：`chmod +t /path/to/dir` 或 `chmod 1755 dir`

PPT 强调，sticky 位是实现安全共享目录的关键机制，广泛应用于多用户环境。

---

### 4. 权限验证的顺序

Linux 在进行文件访问权限检查时，遵循严格的**优先级匹配规则**，确保权限判定清晰且无歧义。

- **前提**：
  - 每个文件关联一个 UID（属主）和 GID（所属组）。
  - 每个进程在其 PCB（进程控制块）中记录了：
    - 实际 UID（RUID）和 GID（RGID）
    - 有效 UID（EUID）和 GID（EGID）——用于权限检查

- **权限匹配顺序**（按优先级从高到低）：
  1. **文件主匹配**：若进程的 EUID == 文件的 UID → 使用 **文件主（u）权限**
  2. **组匹配**：若 EUID ≠ 文件 UID，但进程的 EGID ∈ 文件的 GID（包括辅助组）→ 使用 **组（g）权限**
  3. **其他用户**：以上均不满足 → 使用 **其他（o）权限**

- **重要原则**（PPT 特别强调）：
  - **权限不叠加**：即使文件主同时属于某个组，只要 UID 匹配，就**仅使用文件主权限**，不会“额外加上”组权限。
    - 例如：文件权限为 `rw-r-----`，属主为 `liu`，`liu` 同时在 `staff` 组。当 `liu` 访问时，只看 `rw-`，即使组权限是 `r--`，也不会获得额外权限。
  - **root 特权**：超级用户（UID=0）**绕过所有权限检查**，可无视 r/w/x 设置访问任意文件或目录。

这一机制保证了权限模型的确定性和安全性，是理解 Linux 访问控制的核心基础。

## 三、权限相关命令

### 1. 确定文件的权限

在 Linux 中，查看文件或目录的权限是管理访问控制的第一步。PPT 明确指出以下两种常用方式：

- **查看普通文件权限**：使用 `ls -l` 命令  
  该命令以长格式列出文件信息，第一列即为权限字段（如 `-rw-r--r--`），其中：
  - 第一个字符表示文件类型（`-` 普通文件，`d` 目录，`l` 符号链接等）
  - 接下来的 9 位分为三组，分别对应 **文件主（u）**、**同组用户（g）** 和 **其他用户（o）** 的 r/w/x 权限。

- **查看目录自身的权限**：使用 `ls -ld 目录名`  
  若仅用 `ls -l 目录名`，系统会列出目录**内部内容**的权限；而加上 `-d` 选项后，显示的是**目录本身**的权限（即对目录 inode 的访问控制）。  
  示例：
  ```bash
  $ ls -ld /tmp
  drwxrwxrwt 10 root root 4096 Jun 10 10:00 /tmp
  ```
  此输出表明 `/tmp` 是一个具有 sticky 位（末尾 `t`）的公共可写目录。

---

### 2. `chmod`：修改权限

`chmod`（change mode）是修改文件或目录权限的核心命令，支持两种语法形式。

#### （1）字母形式（符号模式）

- **语法结构**：`chmod [ugoa][+-=][rwxst] 文件名`
  - 用户类别：
    - `u`：文件主（user/owner）
    - `g`：所属组（group）
    - `o`：其他用户（others）
    - `a`：所有用户（all，等价于 `ugo`）
  - 操作符：
    - `+`：添加指定权限
    - `-`：移除指定权限
    - `=`：精确设定权限（覆盖原有）
  - 权限位：
    - `r`、`w`、`x`：基本读、写、执行权限
    - `s`：设置 SUID（对 u）或 SGID（对 g）
    - `t`：设置 sticky 位（仅对目录，作用于 o 位）

- **典型示例**（来自 PPT）：
  ```bash
  chmod u+rw *               # 为当前目录下所有文件的属主添加读写权限
  chmod go-rwx *.[ch]        # 移除 .c 和 .h 文件对组和其他用户的全部权限
  chmod a+x batch            # 允许所有用户执行 batch 脚本
  chmod u=rx try2            # 将 try2 的属主权限设为仅读和执行（覆盖原权限）
  ```

> 注意：`s` 和 `t` 位的设置需谨慎，通常用于特殊场景（如 SUID 程序、公共目录）。

#### （2）数字形式（八进制模式）

- **原理**：将每类用户的权限转换为三位二进制数，再转为八进制数字。
  - `r = 4`，`w = 2`，`x = 1`
  - 权限组合相加：如 `rw- = 4+2+0 = 6`，`r-x = 4+0+1 = 5`

- **格式**：`chmod XYZ 文件名`，其中：
  - `X`：文件主权限（0–7）
  - `Y`：组权限（0–7）
  - `Z`：其他用户权限（0–7）

- **示例解析**：
  ```bash
  chmod 644 xyz
  ```
  - `6` → `110` → `rw-`
  - `4` → `100` → `r--`
  - 最终权限：`-rw-r--r--`

- **重要限制**：  
  只有**文件的属主**或 **root 用户** 才能执行 `chmod` 修改权限。普通用户无法更改他人文件的权限，即使对该文件所在目录有写权限。

---

### 3. `umask` 命令：控制初始权限

`umask`（user file-creation mask）用于**控制新创建文件和目录的默认权限**，是 shell 的内建命令，也是每个进程的属性之一。

- **作用机制**：  
  `umask` 定义了一个“屏蔽掩码”，在创建文件时从最大可能权限中**减去**被屏蔽的位。
  - 普通文件的最大权限为 `666`（即 `rw-rw-rw-`，无执行位）
  - 目录的最大权限为 `777`（即 `rwxrwxrwx`）

- **常见用法**：
  ```bash
  umask        # 显示当前掩码（如 0022）
  umask 022    # 设置掩码为 022
  ```

- **权限计算示例**：
  - `umask 022`：
    - 文件：`666 - 022 = 644` → `rw-r--r--`
    - 目录：`777 - 022 = 755` → `rwxr-xr-x`
  - `umask 077`：
    - 文件：`666 - 077 = 600` → `rw-------`
    - 目录：`777 - 077 = 700` → `rwx------`

- **持久化设置**：  
  用户通常在登录脚本（如 `$HOME/.bash_profile` 或 `$HOME/.bashrc`）中设置 `umask`，以确保每次会话都使用一致的安全策略。

> PPT 强调：`umask` **不影响已存在文件**的权限，仅作用于**新建**的文件和目录。

---

### 4. 系统调用 `umask`

除了 shell 命令，程序可通过系统调用直接操作 `umask`，实现更精细的权限控制。

- **C 函数原型**：
  ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  mode_t umask(mode_t mask);
  ```
  - 功能：设置当前进程的文件创建掩码，并返回**之前的 umask 值**。
  - 参数 `mask` 为八进制权限掩码（如 `022`）。

- **权限生效逻辑**：  
  当程序调用 `open()`、`creat()` 或 `mkdir()` 创建文件/目录时，实际权限由以下公式决定：
  ```
  实际权限 = (指定权限) & (~umask)
  ```
  - 示例：
    ```c
    umask(077);                     // 屏蔽组和其他权限
    int fd = open("data.txt", O_CREAT | O_WRONLY, 0666);
    // 实际权限 = 0666 & ~077 = 0600 → rw-------
    ```

- **关键注意事项**（PPT 重点说明）：
  - `umask` **仅影响新创建的文件**，对已有文件无作用。
  - 子进程会**继承父进程的 umask**，因此在守护进程或服务程序中常需显式设置 `umask(0)` 或 `umask(022)` 以避免权限过严或过松。

通过结合 `umask` 命令与系统调用，开发者和系统管理员可在不同层级灵活控制文件系统的安全边界。

## 四、设定文件和目录权限 — 演示案例

本节通过一系列贴近实际操作的演示，直观展示了 Linux 中文件与目录权限的行为逻辑。这些案例紧扣权限模型的核心原则：**文件内容的读写由文件自身权限决定，而文件的创建、删除、重命名等操作则依赖于所在目录的权限**。

---

### 1. 文件的读写权限演示

PPT 通过以下操作验证了普通文件权限的作用范围：

- **设置只读**：
  ```bash
  chmod u-w file
  ```
  - 此时文件对属主变为只读（如权限变为 `-r--r--r--`）。
  - 尝试追加内容将失败：
    ```bash
    echo "test" >> file   # 报错：Permission denied
    ```
  - **但该文件仍可被删除**，前提是其所在目录对当前用户具有写权限。  
    > 原因：删除是修改目录表的操作，与文件自身的写权限无关。

- **完全移除读写权限**：
  ```bash
  chmod u-rw file
  ```
  - 属主既不能读也不能写该文件。
  - 执行 `cat file` 将失败，提示“Permission denied”。
  - 即便如此，只要目录可写，仍可执行 `rm file` 删除它。

> 此演示清晰说明：**文件的“存在性”由目录控制，“内容访问”由文件自身控制**。

---

### 2. 目录的写权限演示

通过限制当前目录的写权限，PPT 展示了目录写权限的实际影响：

- **命令**：
  ```bash
  chmod u-w .
  ```

- **效果**：
  - ❌ 无法创建新文件（`touch newfile` 失败）
  - ❌ 无法删除已有文件（`rm oldfile` 失败）
  - ❌ 无法重命名文件（`mv a b` 失败）
  - ❌ 无法创建子目录（`mkdir subdir` 失败）

- **关键例外**：
  - ✅ **可以修改已有文件的内容**，只要该文件本身具有写权限。  
    例如：
    ```bash
    echo "update" >> existing.txt   # 成功（若 existing.txt 可写）
    ```
  - 原因：修改文件内容不涉及目录结构变更，仅需文件自身的 w 权限。

> 这一案例有力地澄清了常见误解：“目录不可写 = 目录下所有文件不可改”——实际上，**文件内容的可写性独立于目录权限**。

---

### 3. 目录的读权限演示

- **操作**：
  ```bash
  chmod u-r dir
  ```

- **结果**：
  - 执行 `ls dir` 失败，提示“Permission denied”。
  - 无法获取目录中任何文件或子目录的列表。
  - 即使知道某个文件名（如 `dir/secret.txt`），若同时缺少执行权限（x），也无法访问其内容（见下一节）。

> 读权限决定了是否能“看到”目录中的条目，是目录信息可见性的开关。

---

### 4. 目录的执行权限演示

执行权限（x）对目录而言意味着“可遍历”（traversable）。PPT 通过两种典型组合说明其作用：

#### （1）有读写权限，但无执行权限（rwx → rw-）
- **现象**：
  - ✅ `ls dir` 成功，能列出所有文件名。
  - ❌ 但无法访问其中任何文件的内容：
    ```bash
    cat dir/file.txt   # 失败：Permission denied
    cd dir             # 失败：Permission denied
    ```
- **原因**：  
  路径解析需要逐级“进入”目录，缺少 x 权限导致系统无法定位到目标文件的 inode，即使知道文件名也无济于事。

#### （2）有执行权限，但无读写权限（rwx → --x）
- **现象**：
  - ❌ `ls dir` 失败（无 r 权限，看不到内容列表）
  - ❌ 无法创建或删除文件（无 w 权限）
  - ✅ **但若已知确切文件路径，可直接访问其内容**：
    ```bash
    cat ttt/ccp.c      # 成功（假设 ttt 有 x 权限，ccp.c 有 r 权限）
    ```
- **应用场景**：  
  这种配置常用于保护隐私目录（如用户家目录），允许授权用户通过完整路径访问特定资源，但禁止浏览目录结构。

> 综合来看，**x 权限是路径可达性的前提，r 权限是内容可见性的前提，w 权限是结构可变性的前提**。三者相互独立，共同构成目录访问控制的完整体系。

--- 

这些演示案例不仅验证了理论规则，也为系统管理员和开发者提供了排查权限问题的实践依据。

## 五、SUID 权限

### 1. 三级权限的局限性

Linux 的基本权限模型（文件主、组、其他用户）虽然强大，但在某些场景下显得过于粗放，无法满足特定的安全需求。主要问题包括：

- **全开放或完全禁止**：对于敏感资源（如 `/etc/passwd` 或 `/etc/shadow`），要么给予某用户组全部访问权限，要么完全禁止访问，缺乏中间态。
- **典型应用场景**：
  - 普通用户需要修改密码（涉及写入 `/etc/shadow`，通常仅 root 可写）
  - 用户 `liu` 拥有一份工资表 `list.txt`（权限设为 `600`），希望同事 `liang` 能查询自己的工资记录，但不允许查看他人信息。

在这些情况下，简单的 r/w/x 权限不足以实现既安全又灵活的访问控制。

---

### 2. SUID 解决方案

**Set User ID（SUID）** 是 Linux 提供的一种特殊权限机制，允许普通用户以文件属主的身份执行程序，从而突破常规权限限制。

- **设置方法**：使用 `chmod u+s program` 命令为可执行文件添加 SUID 位。
- **权限显示**：例如 `-rws--x--x`，其中 `s` 替代了属主的执行位 `x`。
  
**运行效果**：
- 当用户执行带有 SUID 的程序时，该进程的**有效 UID（EUID）临时变更为文件的属主 UID**，而非启动进程的实际用户。
- 进程仍保留其**实际 UID（RUID）**，用于识别发起请求的用户身份。
- 程序内部逻辑决定了如何利用 EUID 访问受限资源，并返回相应结果给调用者。

PPT 强调，尽管 EUID 提升了权限，但程序行为依然受制于开发者设计——必须谨慎处理敏感操作，避免滥用特权导致安全隐患。

---

### 3. 进程的 UID 机制

为了深入理解 SUID 的工作原理，有必要了解 Linux 进程管理中的 UID 相关概念：

- **实际 UID（Real UID, RUID）**：指创建进程的真实用户ID，代表发起请求的用户。
- **有效 UID（Effective UID, EUID）**：用于系统调用中的权限检查，默认与 RUID 相同。
- **保存的 UID（Saved UID, SUID）**：存储原始 EUID，在切换回原状态时使用（不常用）。

当一个程序具有 SUID 标志时，其运行过程中会发生以下变化：
- **EUID = 文件属主的 UID**，使得进程能够以更高的权限执行任务。
- 所有依赖 EUID 的系统调用（如 `open()`、`chown()`）都将基于此提升后的身份进行权限验证。
- 实际上，这意味着即使普通用户启动了该程序，也能像文件属主那样访问受限资源。

---

### 4. 应用示例

PPT 中给出的具体例子生动展示了 SUID 的实际应用价值：

假设用户 `liu` 创建了一个名为 `query` 的程序，旨在让同事 `liang` 安全地查询个人工资信息（存储于 `list.txt`）。具体步骤如下：

1. 设置 `list.txt` 权限，确保只有 `liu` 可读：
   ```bash
   chmod 600 list.txt
   ```

2. 编译并设置 `query` 程序权限，使其对所有人可执行，且携带 SUID 属性：
   ```bash
   chmod 711 query      # 所有人可执行，但无权读取或修改
   chmod u+s query      # 添加 SUID，使执行时 EUID = liu
   ```

3. 用户 `liang` 执行 `query`：
   - 成功读取 `list.txt` 中与自己相关的行，因为此时 `query` 运行时的 EUID 等于 `liu`，具备访问权限。
   - 尝试直接 `cat list.txt` 则会失败，提示“Permission denied”，因为 `liang` 并非文件所有者。

这一案例充分体现了 SUID 在平衡安全性与功能性方面的独特优势，即通过限定范围内的权限提升，实现了精细的资源共享与保护。然而，由于 SUID 程序本质上扩大了攻击面，因此应严格遵循最小化原则，仅在必要时启用，并定期审计相关代码。