# Chapter5: Process Scheduling
## 一、章节目标（CHAPTER OBJECTIVES）
1. 介绍进程调度（P-scheduling），明确其作为多道程序设计操作系统基础的定位
2. 描述各类CPU调度算法（资源分配：原因、对象、时机）
3. 分析主流操作系统的调度算法实现
4. 探讨选择特定系统CPU调度算法的评估准则

## 5.1 基本概念（Basic Concepts）
### 5.1.1 调度的必要性
系统中多个进程需并发运行，为避免单个进程独占CPU及I/O设备等关键资源，需通过调度实现资源公平分配；同时，进程需复用CPU（或CPU核心）及其他外设资源，按有序方式占用CPU执行，防止资源闲置导致系统效率下降🔶3-11、🔶3-12、。

### 5.1.2 CPU调度定义
CPU调度是操作系统的核心操作，具体指从内存就绪队列中选择具备运行条件的进程或线程，为其分配CPU资源并启用执行；核心操作包含“选择+分配+启用”，且全程在 kernel 态执行，因调度频率高（毫秒级），该操作又称“短期调度”🔶3-17、🔶3-18、🔶3-19、。

### 5.1.3 进程执行周期
进程的完整执行周期由“CPU突发（CPU burst）”与“I/O突发（I/O burst）”交替组成：当进程处于CPU突发阶段时，其状态为运行态；当进入I/O突发阶段时，状态转为等待态🔶3-24、🔶3-25、。根据突发特征，进程可分为两类：
- **CPU密集型进程（计算密集型）**：拥有少量但持续时间长的CPU突发，I/O操作频次低🔶3-34、；
- **I/O密集型进程**：拥有大量但持续时间短的CPU突发，同时搭配长时长的I/O突发（如数据库访问、磁盘读写场景）🔶3-36、。

### 5.1.4 调度执行主体
调度由操作系统的“调度器（Scheduler）”与“分配器（Dispatcher）”协同完成，两者分工明确：
- **调度器**：负责从内存就绪进程中筛选目标进程，维护就绪队列结构，采用预设调度算法（如FCFS、RR等）实现选择逻辑；
- **分配器**：接收调度器的选择结果，将CPU控制权移交至选中进程，核心执行三项操作——进程上下文切换、从内核态切换至用户态、跳转至用户程序的对应位置以重启执行🔶3-42、🔶3-43、🔶3-45、。

### 5.1.5 调度触发时机
调度的触发场景按“是否抢占CPU”分为两类，分别对应不同的进程状态转换：
- **非抢占式触发**：仅当CPU空闲时触发，具体场景包括进程正常终止、进程从运行态切换至等待态（如发起I/O请求）🔶3-60、🔶3-62、；
- **抢占式触发**：CPU非空闲时强制触发，具体场景包括进程从运行态切换至就绪态（如中断发生、时间片耗尽）、进程从等待态切换至就绪态（如I/O操作完成）🔶3-63、🔶3-64、。

### 5.1.6 CPU模式切换与调度延迟
- **CPU模式切换**：调度过程会导致CPU在用户态与内核态之间切换——进程正常执行时处于用户态，而调度器、分配器的操作需在 kernel 态完成🔶3-70、；
- **调度延迟（Dispatch Latency）**：指分配器停止当前进程、启动新进程的总耗时，对应文档中`[t₀, t₃]`时间段，该延迟包含上下文切换、模式切换等操作的耗时，是衡量调度效率的关键指标🔶3-81、🔶3-82、。

## 5.2 调度准则（Scheduling Criteria）
### 5.2.1 核心优化目标
调度准则的核心是平衡系统整体性能与单个进程体验，按优化维度分为**系统级准则**与**进程级准则**两类，均为操作系统调度算法设计的核心依据：
- **系统级准则**：聚焦整个系统的资源利用效率，目标包括最大化CPU利用率（避免CPU空闲）、最大化吞吐量（提升单位时间内完成的进程数量）；
- **进程级准则**：聚焦单个进程的执行体验，目标包括最小化周转时间（缩短进程从提交到完成的总时长）、最小化等待时间（减少进程在就绪队列的闲置时长）、最小化响应时间（提升交互式系统的反馈速度）🔶3-94、🔶3-95、🔶3-96、🔶3-97、🔶3-99、🔶3-100、🔶3-101。

### 5.2.2 其他准则
除核心目标外，调度算法还需考虑多维度辅助准则，以适配不同场景需求：
- 公平性：确保所有进程获得公平的CPU资源，避免低优先级进程长期被忽视；
- 资源利用率：最大化内存、I/O设备等非CPU资源的使用效率；
- 实时性：满足实时系统中任务的截止时间要求；
- 能耗：在移动设备等场景中，通过调度优化降低CPU能耗🔶3-102、🔶3-103。

### 5.2.3 各准则定义与计算
#### 5.2.3.1 CPU利用率
- **定义**：衡量CPU被有效利用的程度，特指用户进程占用CPU的时间占总CPU时间（用户进程+操作系统进程占用时间）的比例；
- **计算逻辑**：  
  \[
  \text{CPU利用率} = \frac{\text{用户进程运行在CPU的总时间}}{\text{用户进程+操作系统进程运行在CPU的总时间}} \times 100\%
  \]  
  其中，用户进程包括应用程序（如办公软件）、非OS系统程序（如编译程序），操作系统进程包括调度进程、内存分配进程等🔶3-108、🔶3-110、🔶3-112。

#### 5.2.3.2 吞吐量
- **定义**：衡量系统的任务处理效率，指单位时间内完成执行并终止的进程数量；
- **计算逻辑**：  
  \[
  \text{吞吐量} = \frac{\text{在时间段}[T_1,T_2]内终止的进程数}{\text{时间段}[T_1,T_2]的长度}
  \]  
  例如，1分钟内完成4个进程的执行，则吞吐量为4个/分钟🔶3-129、🔶3-130、🔶3-131、🔶3-134。

#### 5.2.3.3 周转时间
- **定义**：描述单个进程的生命周期时长，指进程从提交到系统（进入就绪队列）到完全执行完成（进入终止态）的总时间；
- **时间范围**：涵盖进程在就绪态、运行态、等待态（如I/O等待）等所有状态的持续时间总和，即进程在系统中停留的全部时长🔶3-139、🔶3-140、🔶3-143、🔶3-144。

#### 5.2.3.4 等待时间
- **定义**：衡量进程的闲置成本，指进程在生命周期内，在就绪队列中等待CPU分配的总时长；
- **计算逻辑**：不包含进程在运行态的执行时间与等待态的I/O等待时间，仅累计进程处于就绪队列的所有时间段（如`[t0,t1] + [t3,t4] + [t6,t7]`，对应进程就绪状态的间隔）🔶3-146、🔶3-147、🔶3-148、🔶3-155。

#### 5.2.3.5 响应时间
- **定义**：专为交互式系统设计的准则，指从用户提交请求（如点击按钮、输入查询）到系统首次产生响应（如界面刷新、返回部分结果）的时间；
- **关键特点**：仅关注“首次响应”的触发时间，而非响应完全输出的总时间，例如数据库查询中“开始返回第一条结果”的时间即为响应时间，而非所有结果输出完毕的时间🔶3-160、🔶3-161、🔶3-162、🔶3-163。

### 5.2.4 例题：CPU利用率计算
#### 例题条件
在长度为100ms的时间段T内，CPU的运行情况如下：
- 用户应用进程：P₁（45ms）、P₂（35ms）；
- 非OS系统程序（编译进程）：P₃（17ms）；
- 操作系统进程：调度进程P₄（2ms）、内存分配进程P₅（1ms）🔶3-117、🔶3-118、🔶3-124。

#### 计算过程
1. 计算用户进程总运行时间：用户应用进程+非OS系统程序 = 45ms + 35ms + 17ms = 97ms；
2. 计算总CPU时间：时间段T的长度 = 100ms（操作系统进程时间已包含在总时间内）；
3. 代入公式计算：  
   \[
   \text{CPU利用率} = \frac{97ms}{100ms} \times 100\% = 97\%
   \]

#### 例题答案
选项B（97%）🔶3-124、🔶3-126。

## 5.3 调度算法（Scheduling Algorithms）
### 5.3.1 先来先服务（First-Come First-Served, FCFS）
- **核心原理**：按照进程请求CPU的先后顺序分配CPU资源，就绪队列采用先进先出（FIFO）结构，先请求CPU的进程优先获得执行权🔶3-248、🔶3-259、🔶3-261。
- **实现逻辑**：新创建的进程直接插入就绪队列的尾部，调度器每次从就绪队列的头部选择进程，为其分配CPU直至进程完成CPU突发或进入等待态🔶3-262、🔶3-263、🔶3-264。
- **关键特点**：属于非抢占式调度算法，进程一旦获得CPU，需执行完当前CPU突发或主动放弃（如请求I/O）才能释放；其平均等待时间通常不是最小的，且当进程CPU突发时间差异较大时，平均等待时间波动显著；相对而言，对CPU突发时间较短的进程更友好，可减少短进程的等待延迟🔶3-293、🔶3-294、🔶3-295、🔶3-297。
- **例题应用**：针对3个进程（P1CPU突发24ms、P23ms、P33ms），当进程按“P1→P2→P3”到达时，甘特图为“P1(0-24)→P2(24-27)→P3(27-30)”，平均等待时间为(0+24+27)/3=17ms；当到达顺序变为“P2→P3→P1”时，甘特图为“P2(0-3)→P3(3-6)→P1(6-30)”，平均等待时间降至(6+0+3)/3=3ms，验证“短进程优先到达可优化等待时间”的结论🔶3-267、🔶2-268、🔶3-283、🔶3-288。

### 5.3.2 短作业优先（Shortest-Job-First, SJF）
- **核心原理**：调度器始终选择“下一个CPU突发时间最短”的就绪进程分配CPU；若多个进程的CPU突发时间相同，则采用FCFS规则排序🔶3-301、🔶3-302、🔶3-303。
- **实现逻辑**：分为两种模式：
  1. **非抢占式SJF**：进程一旦获得CPU，需完整执行完当前CPU突发，期间不会被其他进程抢占🔶3-308、🔶3-309；
  2. **抢占式SJF（又称最短剩余时间优先，Shortest-Remaining-Time-First, SRTF）**：若新到达的进程CPU突发时间短于当前运行进程的剩余突发时间，则立即抢占CPU，将当前进程放回就绪队列，新进程开始执行🔶3-310、🔶3-311、🔶3-315。
- **关键特点**：在给定的进程集合中，SJF算法能实现“平均等待时间最小化”，是理论上的最优调度算法🔶3-316、🔶3-317。
- **CPU突发时间预测**：由于无法提前知晓进程的CPU突发时间，实际中通过“指数平均法”基于历史突发时间预测下一次突发时长，公式为\(\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_n\)（\(t_n\)为第n次实际突发时间，\(\tau_n\)为第n次预测值，\(\alpha\)为权重系数，0≤α≤1）🔶3-335、🔶3-337、🔶3-341。
- **例题应用**：针对4个进程（P1到达0.0ms/突发7ms、P2到达2.0ms/突发4ms、P3到达4.0ms/突发1ms、P4到达5.0ms/突发4ms）：
  1. 非抢占式SJF的甘特图为“P1(0-7)→P3(7-8)→P2(8-12)→P4(12-16)”，平均等待时间为(0+6+3+7)/4=4ms🔶3-321、🔶3-322、🔶3-324；
  2. 抢占式SJF（SRTF）的甘特图为“P1(0-2)→P2(2-4)→P3(4-5)→P2(5-7)→P1(7-11)→P4(11-15)”，平均等待时间降至(9+1+0+2)/4=3ms🔶3-327、🔶3-328、🔶3-331。

### 5.3.3 优先级调度（Priority Scheduling）
- **核心原理**：为每个进程分配一个优先级（通常用整数表示，数值越小优先级越高），调度器始终选择优先级最高的就绪进程分配CPU🔶3-345、🔶3-346、🔶3-347。
- **实现逻辑**：根据“是否允许抢占”分为两种模式：
  1. **非抢占式优先级调度**：新到达的高优先级进程不会抢占当前运行进程，仅插入就绪队列头部，等待当前进程释放CPU🔶3-354、🔶3-355；
  2. **抢占式优先级调度**：若新到达进程的优先级高于当前运行进程，则立即抢占CPU，将当前进程放回就绪队列，新进程开始执行🔶3-352、🔶3-353。
- **优先级类型**：
  1. **静态优先级**：进程创建时确定优先级，整个生命周期内保持不变，由操作系统根据进程类型（如系统进程/用户进程）或用户设定（如nice值）分配🔶3-376、🔶3-377；
  2. **动态优先级**：进程的优先级随运行状态动态调整，例如Linux系统中，长期等待的进程优先级会逐步提升，避免饥饿🔶3-378、🔶3-379。
- **问题与解决**：低优先级进程可能因高优先级进程持续占用CPU而长期无法执行，即“饥饿（Starvation）”问题；解决方案为“老化（Aging）”机制——随着时间推移，逐步提高长期等待进程的优先级，使其最终能获得CPU资源🔶3-392、🔶3-393、🔶3-395、🔶3-396。
- **例题应用**：针对5个进程（P1突发10ms/优先级3、P2突发1ms/优先级1、P3突发2ms/优先级4、P4突发1ms/优先级5、P5优先级2），按优先级调度的甘特图为“P2(0-1)→P5(1-?)→P1(?-?)→P3(?-?)→P4(?-?)”，高优先级进程（P2、P5）优先执行，验证“优先级决定调度顺序”的逻辑🔶3-367、🔶3-368、🔶3-371、🔶3-372。

### 5.3.4 轮转调度（Round Robin, RR）
- **核心原理**：将CPU时间划分为固定长度的“时间片（Time Quantum，通常为10-100ms）”，就绪进程按FIFO顺序排队；调度器为队首进程分配一个时间片，若进程在时间片内完成CPU突发，则直接终止；若时间片耗尽仍未完成，则被抢占CPU，插入就绪队列尾部，等待下一轮调度🔶3-404、🔶3-405、🔶3-406、🔶3-409、🔶3-410。
- **关键特点**：属于抢占式调度算法，平均等待时间通常高于SJF，但能保证进程快速获得响应，尤其适用于分时系统（如Linux、Windows桌面系统），可平衡多个交互式进程的响应需求🔶3-411、🔶3-412、🔶3-413。
- **时间片与性能的关系**：
  1. 时间片过大（如远大于进程平均CPU突发时间）：RR调度会退化为FCFS，短进程的等待时间增加🔶3-423、🔶3-424；
  2. 时间片过小（如小于上下文切换时间）：会导致上下文切换频率剧增，系统开销（如保存/恢复PCB）占比过高，反而降低CPU利用率🔶3-425、🔶3-426、🔶3-427。
- **例题应用**：针对3个进程（P1突发53ms、P2突发17ms、P3突发68ms、P4突发24ms），当时间片为20ms时，甘特图为“P1(0-20)→P2(20-37)→P3(37-57)→P4(57-77)→P1(77-97)→P3(97-117)→P4(117-121)→P1(121-134)→P3(134-154)→P3(154-162)”，进程按FIFO顺序轮流占用时间片，验证“超时抢占、循环调度”的逻辑🔶3-416、🔶3-417、🔶3-418、🔶3-420。

### 5.3.5 多级队列（Multilevel Queue）
- **核心原理**：将就绪队列按“进程类型”划分为多个独立子队列（如前台交互式队列、后台批处理队列、系统进程队列）；不同子队列采用不同的调度算法，同时需定义“队列间的调度规则”，确保各类型进程的资源需求得到满足🔶3-442、🔶3-443、🔶3-445。
- **实现逻辑**：
  1. **队列内调度**：根据进程类型选择适配算法，例如前台交互式队列采用RR（保证响应速度），后台批处理队列采用FCFS（降低调度开销）🔶3-448、🔶3-449、🔶3-450；
  2. **队列间调度**：分为两种模式——①固定优先级调度（如前台队列优先级高于后台队列，优先调度前台进程，易导致后台进程饥饿）；②时间片分配（如80%CPU时间分配给前台队列，20%分配给后台队列，避免饥饿）🔶3-459、🔶3-461、🔶3-463、🔶3-465。
- **关键特点**：实现简单，能针对性满足不同类型进程的调度需求，但进程一旦进入某子队列，生命周期内无法迁移，灵活性较低🔶3-453、🔶3-454、🔶3-466。

### 5.3.6 多级反馈队列（Multilevel Feedback Queue）
- **核心原理**：在多级队列基础上增加“进程队列迁移”机制，进程可根据执行情况（如时间片使用情况、CPU突发特征）在不同队列间升级或降级，同时通过“老化”避免低优先级进程饥饿；调度器的行为由5个核心参数定义：队列数量、各队列的调度算法、进程升级规则（如短突发进程升至高优先级队列）、进程降级规则（如超时进程降至低优先级队列）、新进程的初始队列分配规则🔶3-470、🔶3-471、🔶3-474。
- **实现逻辑**：以“三级反馈队列”为例（Q0：时间片8ms、Q1：时间片16ms、Q2：FCFS）：新进程先进入Q0，若在8ms内完成CPU突发则终止；若超时则降级至Q1；Q1中若16ms内未完成则降级至Q2；Q2中按FCFS执行至完成，确保长进程最终能得到执行🔶3-482、🔶3-486、🔶3-487、🔶3-493、🔶3-495。
- **例题应用**：针对两级反馈队列（Q0：时间片10ms、Q1：FCFS，Q0优先级高于Q1），进程P0（到达0.0ms/突发6.0ms）、P1（到达4.0ms/突发15.0ms）、P2（到达8.0ms/突发4.0ms）、P3（到达12.0ms/突发13.0ms）的甘特图为“P0(0-6)→P1(6-16)→P2(16-20)→P1(20-25)→P3(25-35)→P3(35-45)”，P1因Q0时间片超时降级至Q1，P3进入Q0后超时降级，验证“队列迁移与优先级调度”的逻辑🔶3-499、🔶3-500、🔶3-501、🔶3-508、🔶3-511。

### 5.3.7 最高响应比优先（Highest Response Rate First, HRRF）
- **核心原理**：通过“响应比”平衡短进程与长进程的调度需求，响应比公式为\(\text{响应比} = 1 + \frac{\text{等待时间}}{\text{估计计算时间}}\)（响应比=响应时间/估计计算时间，响应时间=等待时间+估计计算时间）；调度器采用非抢占式策略，每次从就绪队列中选择响应比最高的进程分配CPU🔶3-515、🔶3-517、🔶3-521、🔶3-527、🔶3-528。
- **关键特点**：
  1. 对短进程友好：短进程的“估计计算时间”小，即使等待时间短，响应比也较高，优先被调度；
  2. 避免长进程饥饿：长进程的“等待时间”会随时间增加，当等待时间足够长时，响应比会超过短进程，最终能获得CPU资源🔶3-531、🔶3-532；
  3. 平均周转时间介于SJF与FCFS之间，兼顾效率与公平🔶3-533。
- **例题应用**：针对4个进程（P1到达0.0ms/突发20ms、P2到达5.0ms/突发15ms、P3到达10.0ms/突发5ms、P4到达15.0ms/突发10ms）：
  1. P1先执行（0-20ms），执行期间P2、P3、P4到达；
  2. P1完成后，计算各进程响应比：P2=1+15/15=2、P3=1+10/5=3、P4=1+5/10=1.5，选择P3执行（20-25ms）；
  3. P3完成后，计算响应比：P2=1+20/15≈2.33、P4=1+10/10=2，选择P2执行（25-40ms）；
  4. P2完成后，P4执行（40-50ms），验证“响应比决定调度顺序”的逻辑🔶3-536、🔶3-537、🔶3-538、🔶3-539。

## 5.4 线程调度（Thread Scheduling）
### 5.4.1 线程调度类型
线程调度的核心差异源于管理主体的不同，据此分为内核级线程与用户级线程两类，两者的调度逻辑与依赖组件完全不同：
- **内核级线程（Kernel-Level Thread, KLT）**：由操作系统内核直接创建、管理与调度，内核通过维护线程控制块（TCB）记录线程状态、优先级等信息，调度决策由内核完成，典型示例为Windows系统的线程🔶3-543、🔶3-544；
- **用户级线程（User-Level Thread, ULT）**：由用户级线程库（而非内核）负责创建与调度，内核无法感知用户级线程的存在，调度过程完全在用户态完成，典型示例为早期的绿线程（Green Threads）🔶3-543、🔶3-545。

### 5.4.2 用户级线程的两级调度
由于用户级线程无法直接获取CPU资源（需依赖内核线程），需通过“本地调度+全局调度”的两级机制实现资源分配，确保用户线程能间接获得CPU执行权：
- **本地调度（Local Scheduling，对应进程竞争范围PCS）**：由用户级线程库负责，从进程内就绪的用户线程中筛选合适的线程，将其映射到空闲的轻量级进程（Lightweight Process, LWP）——LWP是内核线程的用户态代理，为用户线程提供与内核交互的接口🔶3-547、🔶3-548；
- **全局调度（Global Scheduling，对应系统竞争范围SCS）**：由操作系统内核负责，从系统内就绪的内核线程（含关联LWP的内核线程）中选择一个，为其分配CPU资源，内核线程执行时，绑定的用户线程也随之在CPU上运行🔶3-549、🔶3-550。

### 5.4.3 竞争范围（Contention Scope）
竞争范围定义了线程争夺CPU资源的边界，与线程映射模型强相关，分为进程竞争范围与系统竞争范围两类：
- **进程竞争范围（Process-Contention Scope, PCS）**：
  - 适用模型：多对一（Many-to-One）与多对多（Many-to-Many）线程映射模型；
  - 竞争边界：线程仅在所属进程内部竞争CPU资源（即竞争进程内的LWP），调度决策由线程库根据程序员设定的线程优先级完成，支持高优先级用户线程抢占低优先级线程🔶3-554、🔶3-555、🔶3-556；
- **系统竞争范围（System-Contention Scope, SCS）**：
  - 适用模型：一对一（One-to-One）线程映射模型，典型系统为Windows、Linux与Solaris；
  - 竞争边界：线程在整个系统范围内竞争CPU资源，调度决策由操作系统内核完成，内核从所有就绪的内核线程中选择优先级最高的线程分配CPU🔶3-554、🔶3-562、🔶3-563。

### 5.4.4 Pthread调度API
POSIX Pthreads线程库提供标准化API，支持开发者配置线程的调度范围（PCS/SCS），实现对线程调度的精细化控制：
- **线程创建与调度范围指定**：通过`pthread_create()`API创建线程时，可通过`pthread_attr_t`类型的属性参数指定调度范围——`PTHREAD_SCOPE_PROCESS`表示采用PCS调度，`PTHREAD_SCOPE_SYSTEM`表示采用SCS调度；该API的参数包括线程ID指针、属性指针、线程执行函数指针与函数参数，创建成功返回0，失败返回错误码🔶3-572、🔶3-573、🔶3-584；
- **竞争范围的设置与获取**：通过`pthread_attr_setscope(pthread_attr_t *attr, int scope)`设置线程的竞争范围，通过`pthread_attr_getscope(pthread_attr_t *attr, int scope)`获取已设置的竞争范围；若函数执行错误（如参数非法），返回非零值🔶3-578、🔶3-579；
- **示例代码**：文档提供多线程创建与调度范围配置的示例，例如通过`pthread_attr_init()`初始化属性、设置SCS调度范围（`pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM)`），再循环创建5个线程并通过`pthread_join()`等待线程执行完成，代码中还包含调度范围的查询逻辑（通过`pthread_attr_getscope()`判断当前范围是PCS还是SCS）🔶3-597、🔶3-599、🔶3-602。

## 5.5 多处理器调度（Multiple-Processor Scheduling）
### 5.5.1 两级调度流程
多处理器系统中，CPU资源分配需通过“进程分配→单CPU调度”的两级流程完成，确保进程与处理器的高效匹配：
- **步骤1：将进程分配给CPU/处理器**：操作系统先判断“哪个处理器适合执行目标进程”，需结合处理器类型（如是否带集成显卡）、当前负载等因素，例如将游戏任务分配给具备集成显卡的Intel i9系列CPU，而非无显卡的E5系列CPU🔶3-606、🔶3-607、🔶3-622；
- **步骤2：在单个CPU上调度进程**：为目标CPU分配进程后，采用单处理器环境下的调度算法（如FCFS、RR、SJF），从该CPU的就绪队列中选择进程执行，完成最终的CPU资源分配🔶3-606、🔶3-609。

### 5.5.2 多处理器调度方式
根据处理器特性与协作逻辑，多处理器调度分为三类方式，其中对称多处理（SMP）是当前主流：
- **同构处理器调度**：多处理器系统中所有处理器的架构与功能一致（如同为Intel i7-13700K），调度时需结合任务特性选择适配的处理器，确保任务需求与处理器能力匹配（如计算密集型任务分配给核心数多的处理器）🔶3-620、🔶3-621、🔶3-622；
- **非对称多处理（Asymmetric Multiprocessing, AMP）**：系统中存在“主处理器（Master）”与“从处理器（Slave）”之分——主处理器负责调度决策、I/O操作与系统数据结构访问，从处理器仅执行用户程序，无需参与调度，适用于功能简单的嵌入式多处理器系统🔶3-623、🔶3-624；
- **对称多处理（Symmetric Multiprocessing, SMP）**：所有处理器地位平等，均具备自调度能力，可访问共享的系统就绪队列，或维护各自的私有就绪队列；进程可在任意处理器上执行，无需区分主从，是当前PC、服务器等通用多处理器系统的主流调度方式🔶3-625、🔶3-626、🔶3-628。

### 5.5.3 关键技术
为提升多处理器调度效率，需通过“处理器亲和性”减少进程迁移开销，通过“负载均衡”确保资源利用率：
- **处理器亲和性（Processor Affinity）**：为避免进程在不同处理器间频繁迁移（增加上下文切换与缓存失效开销），尽量让进程在同一处理器上持续执行：
  1. **硬亲和（Hard Affinity）**：通过系统调用指定进程可运行的处理器子集，进程仅能在该子集内的处理器上执行，严格限制迁移范围🔶3-631、🔶3-637、🔶3-638；
  2. **软亲和（Soft Affinity）**：操作系统尽量让进程在当前运行的处理器上继续执行，但允许在负载过高时迁移至其他处理器；Linux调度器默认实现软亲和，同时通过`sched_setaffinity()`系统调用支持硬亲和🔶3-631、🔶3-640、🔶3-643；
- **负载均衡（Load Balancing）**：在SMP系统中，需确保各处理器负载均匀，避免部分处理器过载、部分处理器闲置：
  1. **推迁移（Push Migration）**：系统定期检查各处理器负载，若发现某处理器过载（如CPU利用率达90%以上），主动将部分进程“推”至负载较低的处理器🔶3-646、🔶3-649、🔶3-650；
  2. **拉迁移（Pull Migration）**：空闲处理器（如CPU利用率低于10%）主动“拉取”其他繁忙处理器的就绪进程，自行执行以提升自身利用率🔶3-646、🔶3-652、🔶3-653。

### 5.5.4 多核处理器与多线程
多核处理器通过“超线程技术”提升核心利用率，同时需通过两级调度协调软件线程与硬件资源：
- **超线程（Hyperthreading，硬件线程）**：在单个物理核心上模拟多个逻辑处理器（如Intel CPU的2个逻辑核/物理核），逻辑处理器共享物理核心的执行引擎与缓存，但拥有独立寄存器；当一个逻辑处理器因内存停顿（如等待内存数据）闲置时，另一个逻辑处理器可利用核心资源执行，提升物理核心的利用率🔶3-699、🔶3-700、🔶3-701、🔶3-751；
- **调度层级**：多核多线程系统的调度分为两级，确保软件线程与硬件资源的精准匹配：
  1. **OS级调度**：操作系统将应用程序的软件线程分配给处理器的逻辑处理器（如将5个软件线程分配给8个逻辑处理器中的5个）🔶3-714、🔶3-716；
  2. **CPU级调度**：物理核心内部决定“哪个逻辑处理器（硬件线程）优先占用核心资源执行”，例如Intel Itanium双核CPU通过“动态紧迫值（0-7，值越高优先级越高）”选择逻辑线程🔶3-714、🔶3-718、🔶3-726；
- **典型示例**：
  1. UltraSPARC T3 CPU：含16个物理核心，每个核心支持8个硬件线程，共128个逻辑处理器，CPU级采用时间片轮转算法调度硬件线程🔶3-704、🔶3-723、🔶3-724；
  2. Intel Itanium双核CPU：每个硬件线程分配动态紧迫值，当触发线程切换事件（如内存停顿）时，选择紧迫值最高的线程在核心上执行🔶3-726、🔶3-727、🔶3-731。

## 5.6 实时系统调度（Real-time CPU Scheduling）
### 5.6.1 实时系统定义
实时系统是一类“事件驱动且时间关键”的系统，需在外部事件失效前（即截止期内）完成响应与处理，根据对截止期的保障能力，分为硬实时系统与软实时系统两类：
- **硬实时系统（Hard Real-time Systems）**：核心任务必须在截止期前完成执行，若超时会导致系统功能失效（如工业控制系统中的设备控制任务、航空电子系统中的导航任务），调度器需通过资源预留与可调度性分析，确保任务满足截止期要求🔶3-759、🔶3-767、🔶3-862、🔶3-867；
- **软实时系统（Soft Real-time Systems）**：无法保证实时进程的调度时间，即使任务超时，仅可能影响用户体验（如视频播放卡顿、语音延迟），但不会导致系统崩溃，调度器通常赋予实时进程最高优先级，但不做严格的截止期保障🔶3-759、🔶3-765、🔶3-853、🔶3-856。

### 5.6.2 延迟优化
实时系统的核心需求是“最小化事件响应延迟”，需重点优化两类延迟——中断延迟与调度延迟，确保事件触发后能快速处理：
- **中断延迟（Interrupt Latency）**：指从外部中断到达处理器，到中断服务程序（ISR）开始执行的时间，需避免中断被长时间屏蔽，确保紧急事件（如设备故障信号）能快速触发处理🔶3-832、🔶3-833、🔶3-834；
- **调度延迟（Dispatch Latency）**：指调度器停止当前运行进程、切换并启动目标实时进程的总耗时，分为两个阶段：
  1. **冲突阶段**：抢占内核态运行的低优先级进程，释放目标高优先级进程所需的资源；
  2. **调度阶段**：为高优先级进程分配资源，启动进程执行，对应文档中“事件响应间隔”内的关键耗时环节🔶3-832、🔶3-835、🔶3-842、🔶3-846。

### 5.6.3 调度算法
实时系统的调度算法需围绕“截止期保障”设计，主流算法包括优先级抢占式调度、单调速率调度、最早截止期优先调度与比例分享调度，各算法适配不同场景需求：
#### 5.6.3.1 优先级抢占式调度（Priority-based Preemptive Scheduling）
- **核心逻辑**：为实时进程分配最高优先级，调度器支持“内核态抢占”——即使当前进程处于内核态执行（如系统调用），若高优先级实时进程就绪，也可立即抢占CPU；
- **适用场景**：软实时系统（如桌面端实时音频处理），虽能提升响应速度，但仅保证优先级排序，无法严格保障截止期🔶3-853、🔶3-854、🔶3-859。

#### 5.6.3.2 单调速率调度（Rate Monotonic Scheduling, RMS）
- **核心逻辑**：专为周期性实时任务设计，优先级与任务周期成反比——周期越短（任务触发频率越高），优先级越高；若多个任务周期相同，采用FCFS规则排序；
- **关键特性**：是周期性任务的最优静态优先级调度算法，但CPU利用率存在上限（如n个任务时利用率≤n(2^(1/n)-1)），无法保证所有情况下任务都能满足截止期🔶3-885、🔶3-890、🔶3-891、🔶3-900；
- **示例**：周期50ms的任务P₁（CPU突发20ms）优先级高于周期100ms的任务P₂（CPU突发35ms），P₁优先执行以满足高频需求🔶3-894。

#### 5.6.3.3 最早截止期优先调度（Earliest Deadline First, EDF）
- **核心逻辑**：采用动态优先级策略，优先级与任务截止期成正比——截止期越早（任务越紧迫），优先级越高；任务就绪时需向调度器宣告截止期，调度器动态调整优先级；
- **关键特性**：
  1. 理论最优：在CPU利用率≤100%的情况下，可保证所有任务满足截止期；
  2. 灵活性高：无需任务具备周期性，支持非周期实时任务（如突发性的设备故障处理）🔶3-910、🔶3-911、🔶3-917、🔶3-924；
- **示例**：周期50ms（截止期50ms）的P₁（突发25ms）与周期80ms（截止期80ms）的P₂（突发35ms），调度器根据实时截止期调整优先级——P₂在时间50ms后截止期（80ms）早于P₁的下一个截止期（100ms），故P₂优先执行🔶3-932、🔶3-940。

#### 5.6.3.4 比例分享调度（Proportional Share Scheduling）
- **核心逻辑**：将CPU时间划分为T个固定“份额”，接纳控制器（Admission Controller）根据进程需求分配N个份额（N<T），确保进程获得N/T比例的CPU时间；若进程需求超过剩余份额，接纳控制器直接拒绝该进程，避免影响其他实时任务；
- **示例**：CPU划分为100份额，进程A需50、B需15、C需20，接纳控制器分配三者共85份额，拒绝需30份额的进程D（85+30>100）🔶3-968、🔶3-969、🔶3-971、🔶3-976。

### 5.6.4 POSIX实时调度标准
POSIX.1b标准为实时线程调度提供标准化接口，定义了明确的调度类与API，确保跨POSIX兼容系统的调度一致性：
- **调度类**：
  1. **SCHED_FIFO**：采用FIFO调度策略，同优先级线程无时间片，高优先级线程可抢占低优先级线程，低优先级线程需等待高优先级线程阻塞/终止后才能执行；
  2. **SCHED_RR**：与SCHED_FIFO逻辑类似，但同优先级线程采用时间片轮转调度，避免单个线程独占CPU🔶3-990、🔶3-993、🔶3-994、🔶3-996；
- **核心API**：
  - `pthread_attr_getsched_policy(pthread_attr_t *attr, int *policy)`：获取线程的调度策略；
  - `pthread_attr_setsched_policy(pthread_attr_t *attr, int policy)`：设置线程的调度策略（如指定为SCHED_FIFO或SCHED_RR）🔶3-998。

### 5.6.5 例题：实时进程截止期满足情况分析
#### 例题条件
4个实时进程的触发事件、到达时间、CPU突发时间、截止期与优先级如下（优先级数值越小优先级越高）：
| 事件 | 进程 | 到达时间 | CPU突发时间 | 截止期 | 优先级 |
|------|------|----------|------------|--------|--------|
| 1    | P₁   | 0.0ms    | 4.0ms      | 7.0ms  | 3      |
| 2    | P₂   | 3.0ms    | 2.0ms      | 5.5ms  | 1      |
| 3    | P₃   | 4.0ms    | 2.0ms      | 12.0ms | 4      |
| 4    | P₄   | 6.0ms    | 4.0ms      | 11.0ms | 2      |
🔶3-771、🔶3-773、🔶3-776。

#### 1. FCFS调度下的截止期满足情况
- **甘特图**：P₁(0.0-4.0)→P₂(4.0-6.0)→P₃(6.0-8.0)→P₄(8.0-12.0)；
- **截止期分析**：
  - P₁：完成时间4.0ms＜7.0ms，满足；
  - P₂：完成时间6.0ms＞5.5ms，超时；
  - P₃：完成时间8.0ms＜12.0ms，满足；
  - P₄：完成时间12.0ms＞11.0ms，超时；
- **结论**：仅P₁、P₃满足截止期，P₂、P₄超时，无法满足实时需求🔶3-780、🔶3-781、🔶3-810。

#### 2. 优先级抢占式调度下的截止期满足情况
- **甘特图**：P₁(0.0-3.0)→P₂(3.0-5.0)→P₁(5.0-7.0)→P₄(7.0-11.0)→P₃(11.0-13.0)；
- **截止期分析**：
  - P₁：完成时间7.0ms＝7.0ms，满足；
  - P₂：完成时间5.0ms＜5.5ms，满足；
  - P₃：完成时间13.0ms＞12.0ms（因优先级最低，等待高优先级进程完成），但实际场景中可通过动态优先级调整优化；
  - P₄：完成时间11.0ms＝11.0ms，满足；
- **结论**：核心实时进程（P₁、P₂、P₄）均满足截止期，仅低优先级的P₃轻微超时，整体符合实时系统需求🔶3-789、🔶3-800、🔶3-801。

## 5.7 操作系统示例（Operating-system examples）
### 5.7.1 Linux调度
Linux的调度机制随内核版本迭代不断优化，核心目标是平衡实时性、公平性与系统效率，不同内核版本采用差异化的调度器设计：
- **2.5内核：O(1)调度器**  
  该版本采用“常数时间调度”设计，核心特点包括：  
  1. **优先级划分**：将优先级分为实时优先级（0-99）与分时优先级（100-140），数值越小优先级越高，实时进程优先级高于分时进程；  
  2. **双优先级数组**：维护“活跃（active）”与“过期（expired）”两个优先级数组，活跃数组存储仍有时间片的就绪进程，过期数组存储时间片耗尽的进程；当活跃数组为空时，两数组交换角色，确保调度效率为O(1)；  
  3. **时间片管理**：进程拥有时间片时处于活跃状态，时间片耗尽后转入过期状态，需等待所有活跃进程用完时间片才能重新获得执行权；但该调度器对交互式进程响应时间优化不足🔶3-1008、🔶3-1009、🔶3-1010、🔶3-1019、🔶3-1022。

- **2.6.23+内核：完全公平调度器（Completely Fair Scheduler, CFS）**  
  CFS以“公平分配CPU时间”为核心，替代O(1)调度器，关键设计包括：  
  1. **虚拟运行时间（vruntime）**：为每个进程维护虚拟运行时间，计算时结合进程优先级（低优先级进程vruntime衰减更快），正常优先级进程的vruntime等于实际运行时间；调度器始终选择vruntime最小的进程执行，确保高优先级进程获得更多CPU时间；  
  2. **红黑树管理**：所有就绪进程按vruntime作为关键字存入红黑树（平衡二叉搜索树），左most节点为vruntime最小的进程，调度器通过缓存的`rb_leftmost`变量快速获取目标进程，时间复杂度为O(logN)；  
  3. **调度类与目标延迟**：支持“默认”与“实时”两类调度，通过`nice值（-20至+19）`计算目标延迟（进程应至少运行一次的时间间隔），目标延迟随活跃进程数增加动态调整，避免调度开销过高🔶3-1025、🔶3-1026、🔶3-1030、🔶3-1042、🔶3-1050、🔶3-1052。

- **实时调度**  
  Linux遵循POSIX.1b实时标准，具体规则为：  
  1. **静态优先级**：实时进程采用静态优先级，优先级范围0-99，高于普通进程（100-139）；  
  2. **nice值映射**：普通进程的`nice值`与全局优先级对应，`nice=-20`映射为全局优先级100，`nice=+19`映射为139，nice值越小，进程优先级越高；  
  3. **调度策略**：支持SCHED_FIFO（FIFO调度）与SCHED_RR（同优先级时间片轮转），确保实时进程的截止期需求🔶3-1056、🔶3-1057、🔶3-1059、🔶3-1060、🔶3-1069。

### 5.7.2 Windows调度
Windows采用“优先级抢占式调度”机制，通过精细化的优先级管理与调度扩展，适配桌面、服务器等场景需求：
- **核心调度机制**  
  1. **优先级分级**：采用32级优先级（0-31），其中优先级0为内存管理线程（系统专属），1-15为“可变类”（普通进程），16-31为“实时类”（实时进程）；调度器始终选择最高优先级的就绪线程执行，高优先级线程可抢占低优先级线程；  
  2. **线程执行规则**：线程获得CPU后，会持续执行直至三种情况：主动阻塞（如I/O请求）、时间片耗尽、被更高优先级线程抢占🔶3-1071、🔶3-1072、🔶3-1073、🔶3-1075、🔶3-1077、🔶3-1078。

- **优先级动态调整**  
  Windows通过动态调整优先级优化响应性与公平性，规则包括：  
  1. **时间片耗尽**：线程时间片用完后，优先级会降低，但不会低于“基准优先级”（进程调度类对应的默认优先级）；  
  2. **等待完成**：线程因等待事件（如I/O完成、信号量）重新就绪时，优先级会根据等待类型提升（如I/O等待完成后优先级提升更显著）；  
  3. **前台窗口优化**：前台应用窗口的线程会获得3倍优先级提升，确保交互式操作（如点击、输入）的响应速度🔶3-1094、🔶3-1098、🔶3-1099。

- **调度类与相对优先级**  
  1. **调度类**：Win32 API定义6类进程调度类，包括`REALTIME_PRIORITY_CLASS`（实时类）、`HIGH_PRIORITY_CLASS`（高优先级类）、`NORMAL_PRIORITY_CLASS`（普通优先级类）等，仅实时类优先级固定，其余为可变类；  
  2. **相对优先级**：每个调度类下的线程有7种相对优先级（如`TIME_CRITICAL`、`HIGHEST`、`NORMAL`），线程的最终数值优先级由“调度类+相对优先级”组合生成（如实时类+TIME_CRITICAL对应优先级31）🔶3-1085、🔶3-1086、🔶3-1091、🔶3-1092、🔶3-1108。

- **扩展：用户态调度（User-Mode Scheduling, UMS）**  
  Windows 7引入UMS，允许应用程序在用户态独立创建与管理线程，无需依赖内核调度：  
  1. **核心优势**：对于大量线程（如数千个）的应用（如高并发服务器），UMS可减少内核态与用户态的切换开销，提升调度效率；  
  2. **实现依赖**：UMS调度器通常集成于编程语言库（如C++ Concurrent Runtime, ConcRT），应用通过库接口管理线程生命周期🔶3-1100、🔶3-1101、🔶3-1102、🔶3-1103。

### 5.7.3 Solaris调度
Solaris通过“多调度类+全局优先级映射”实现灵活调度，适配不同类型任务（如实时、交互式、批处理）的需求：
- **调度类（Scheduling Classes）**  
  Solaris支持6类调度，进程同一时间仅属于一个调度类，各类功能与适配场景如下：  
  1. **时间共享（Time Sharing, TS）**：默认调度类，适用于普通用户进程（如办公软件），采用多级反馈队列调度；  
  2. **交互式（Interactive, IA）**：适用于交互式进程（如终端操作），优先级低于TS；  
  3. **实时（Real Time, RT）**：适用于实时任务（如工业控制），优先级高，确保截止期；  
  4. **系统（System, SYS）**：适用于系统进程（如内核服务），优先级高于TS/IA；  
  5. **公平分享（Fair Share, FSS）**：按用户或组的资源配额分配CPU时间，适用于多用户共享系统；  
  6. **固定优先级（Fixed Priority, FP）**：优先级固定，适用于对优先级有明确要求的进程🔶3-1112、🔶3-1113、🔶3-1114、🔶3-1115、🔶3-1116、🔶3-1117、🔶3-1118、🔶3-1119。

- **全局优先级映射**  
  Solaris将各类调度的优先级统一映射为“全局优先级”，决定进程的执行顺序，从高到低依次为：  
  中断线程（最高，优先级169）→实时（RT）线程（100-159）→系统（SYS）线程（60-99）→公平分享（FSS）线程→固定优先级（FP）线程→时间共享（TS）线程→交互式（IA）线程（最低，0-59）；调度器始终选择全局优先级最高的就绪线程执行🔶3-1130、🔶3-1131、🔶3-1132。

- **时间共享（TS）调度细节**  
  TS类采用“多级反馈队列”调度，通过“调度表”配置核心参数，确保交互式进程响应性：  
  1. **调度表配置**：调度表定义不同优先级对应的“时间片长度”“时间片耗尽后的优先级调整”“睡眠唤醒后的优先级调整”（如优先级0-5的时间片为200ms，时间片耗尽后优先级不变；优先级40-45的时间片为40ms，耗尽后优先级降30）；  
  2. **队列迁移**：进程时间片耗尽后会降级至低优先级队列，睡眠唤醒后会根据等待类型升级优先级（如I/O等待唤醒后优先级提升更显著），避免进程饥饿🔶3-1122、🔶3-1126、🔶3-1127、🔶3-1134。

## 5.8 算法评估（Algorithm Evaluation）
### 5.8.1 评估核心逻辑
CPU调度算法的评估需遵循“先定准则，再选策略”的核心逻辑——首先明确评估所依据的准则（如CPU利用率、吞吐量、等待时间等），再根据系统场景（如实时系统、分时系统）选择适配的评估策略，确保评估结果能真实反映算法在目标场景下的性能表现🔶3-1142、🔶3-1143、🔶3-1144。

### 5.8.2 四种评估策略
#### 5.8.2.1 确定性建模与分析评估（Deterministic Modeling and Analytical Evaluation）
该策略基于“预定工作负载”开展评估，即提前定义一组确定的进程参数（如到达时间、CPU突发时间、优先级），通过数学计算或逻辑分析，直接推导不同调度算法在该工作负载下的性能指标（如平均等待时间、吞吐量）；其优势是实现简单、结果可复现，无需依赖硬件环境，适用于初步筛选算法或验证算法的理论性能🔶3-1145、🔶3-1146、🔶3-1147。

#### 5.8.2.2 排队模型（Queuing Models）
通过构建“进程-CPU”的排队理论模型，将进程视为“顾客”、CPU视为“服务台”，基于概率分布（如进程到达间隔的泊松分布、CPU突发时间的指数分布）模拟系统负载，再通过排队论公式（如Little公式）计算算法的性能指标；该策略适用于分析算法在“随机负载”下的长期平均性能，但模型假设（如分布类型）可能与实际系统存在偏差，精度受模型简化程度影响🔶3-1148。

#### 5.8.2.3 实际系统实现（Implementation on Practical Systems）
将待评估的调度算法部署到真实操作系统或硬件环境中，通过运行实际应用（如Web服务、科学计算任务），直接观测并记录算法的性能数据（如CPU利用率、响应时间）；其优势是评估结果与实际场景高度贴合，能反映算法在真实负载与硬件约束下的表现，但实现成本高（需修改OS内核或开发适配模块），且评估结果受硬件配置（如CPU核心数、内存大小）影响较大🔶3-1145、🔶3-1149。

#### 5.8.2.4 模拟评估（Evaluation by Simulation）
通过开发仿真程序模拟操作系统的调度逻辑与硬件环境（如CPU、就绪队列、I/O设备），输入模拟的进程工作负载（可自定义或从实际系统采集），运行调度算法并统计性能指标；该策略兼顾灵活性与精度——可灵活调整工作负载、硬件参数（如时间片大小、CPU核心数），且无需修改真实系统，适用于对比多种算法在不同场景下的性能差异，是调度算法评估中最常用的策略之一🔶3-1145、🔶3-1150、🔶3-1151。

## 十、附录（Appendix）
1. 附录5-1 基于指数平均的CPU burst预测
   - 公式：τₙ₊₁=αtₙ+(1-α)τₙ（tₙ为第n次实际突发时间，τₙ₊₁为下次预测值，0≤α≤1）
   - 公式展开与权重分析
2. 附录5-2 Unix的基于优先级的调度
   - 优先级类型：静态优先级（创建后不变）、动态优先级（运行中调整）
   - 进程优先数计算：p_pri = min{127, (p_cpu/16 + p_nice + PUSER)}
   - 优先级特点：值越小优先级越高（范围-127~127），睡眠进程优先级分类