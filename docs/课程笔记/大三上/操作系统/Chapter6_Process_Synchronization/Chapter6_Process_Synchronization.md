# Chapter6: Process Synchronization
# 进程同步（Process Synchronization）章节大纲
## 一、章节目标（CHAPTER OBJECTIVES）
1. 理解进程同步与互斥的核心概念、竞争条件及临界区问题
2. 掌握不同层级的同步机制（软件、硬件、操作系统、编程环境级）
3. 熟练运用信号量、管程解决经典同步问题
4. 了解主流操作系统（Linux、Windows、Solaris）的同步实现
5. 掌握同步算法的应用与例题解析

## 背景与基本概念（Background & Basic Concepts）
### 6.1.1 协作进程与独立进程
文档中明确区分协作进程与独立进程，核心围绕“资源共享”与“数据一致性”展开，两者的交互逻辑与对同步机制的需求存在本质差异：
- **协作进程的条件与共享资源特性**  
  协作进程需满足四类交互条件，其核心特征是共享资源的并发访问限制：  
  1. 协作进程的定义：与独立进程（无交互、不共享资源）不同，协作进程需通过共享资源实现功能协同，共享资源包括数据、CPU、I/O端口、内存等；  
  2. 共享资源访问特性：共享资源无法被多个协作进程同时并行使用，仅支持**互斥访问**（即同一时间仅一个进程可占用资源执行操作），这是由资源的物理特性（如I/O设备单次仅响应一个请求）或逻辑需求（如数据完整性）决定的🔶3-37、🔶3-39、🔶3-40、🔶3-42。

- **共享数据一致性与进程同步必要性**  
  并发访问共享数据易引发一致性问题，需通过进程同步保障逻辑正确性：  
  1. 数据一致性风险：例如数据库系统中，多用户并发读写同一事务记录时，若缺乏同步机制，可能导致数据异常（如余额计算错误、订单状态混乱）；  
  2. 同步的必要性：为维护共享数据一致性，必须通过同步机制（如锁、信号量）确保协作进程按有序方式访问共享资源，避免因并发操作导致的逻辑错误，文档中以数据库事务管理为例，说明同步机制对事务ACID特性的保障作用🔶3-44、🔶3-45、🔶3-46、🔶3-47、🔶3-48。

### 6.1.2 竞争条件（Race Condition）
竞争条件是协作进程并发访问共享资源时的核心风险，文档通过具体案例阐述其定义与危害：
- **竞争条件的定义**  
  当多个进程并发访问并操纵共享数据时，共享数据的最终结果**依赖于进程的执行顺序**（即“哪个进程最后完成操作”），而非预设的逻辑规则，这种场景称为竞争条件。文档中以“生产者-消费者问题中的共享计数器`counter`”为例：若`counter`初始值为5，生产者执行`counter++`（拆分为“取数→加1→存数”）与消费者执行`counter--`（拆分为“取数→减1→存数”）的操作交织时，最终`counter`可能为4或6，而非正确的5，直观体现了执行顺序对结果的影响🔶3-83、🔶3-84、🔶3-85、🔶3-87、🔶3-90、🔶3-91、🔶3-92、🔶3-93。

- **竞争条件的危害与解决方向**  
  1. 核心危害：直接导致共享数据不一致，破坏程序逻辑正确性（如计算结果错误、资源状态混乱），严重时可能引发系统故障（如文件损坏、事务回滚失败）；  
  2. 解决方向：必须引入进程同步机制（如软件算法、硬件指令、信号量），确保共享数据的访问操作“原子化”（即操作完整执行无中断），避免多个进程的操作交织，从根本上规避竞争条件🔶3-94、🔶3-95、🔶3-73、🔶3-74。

### 6.1.3 临界区问题（The Critical-Section Problem）
临界区问题是描述“进程互斥访问共享资源”的经典模型，文档明确其核心概念与进程访问结构：
- **临界区与临界资源的核心概念**  
  临界区问题的核心是界定“需保护的代码段”与“被保护的资源”：  
  1. 临界区（Critical Section）：每个进程中直接访问共享资源（临界资源）的代码段，这部分代码必须互斥执行，否则会引发竞争条件；  
  2. 临界资源（Critical Resources）：被多个进程共享、且需通过临界区访问的资源（如共享内存块、数据库表、打印机），临界资源的互斥访问需求是临界区问题的根源🔶3-98、🔶3-99、🔶3-100、🔶3-101、🔶3-102、🔶3-103、🔶3-104、🔶3-105。

- **进程访问临界资源的通用结构**  
  为解决临界区问题，进程访问临界资源需遵循“进入→执行→退出→剩余”的固定流程，确保互斥与有序：  
  ```c
  do {
      进入段（Entry Section）：申请进入临界区的权限，判断是否可安全访问；
      临界区（Critical Section）：执行访问临界资源的核心操作；
      退出段（Exit Section）：释放临界区权限，允许其他进程申请进入；
      剩余段（Remainder Section）：执行与临界资源无关的其他逻辑；
  } while (1);
  ```  
  文档强调，进入段与退出段是实现同步的关键，需通过特定机制（如Peterson算法、信号量）确保“仅一个进程进入临界区”，剩余段不影响临界资源访问，无需同步控制🔶3-111、🔶3-112、🔶3-113、🔶3-114。

### 6.1.4 临界区问题的必要条件（正确解法需满足）
文档指出，一个正确的临界区问题解法必须同时满足“互斥、进步、有限等待”三大条件，缺一不可：
- **互斥（Mutual Exclusion）**  
  核心约束：若进程`Pi`正在执行针对资源`R`的临界区代码，则其他所有进程不能执行针对`R`的临界区代码；但不同资源的临界区可并行执行（如进程`Pi`访问内存、进程`Pj`访问I/O设备）。这一条件确保共享资源不会被多个进程同时操纵，是解决竞争条件的基础🔶3-117、🔶3-118、🔶3-121、🔶3-122、🔶3-125、🔶3-158、🔶3-159。

- **进步（Progress）**  
  核心约束：当无进程在临界区执行，且存在多个进程请求进入临界区时，仅允许“处于进入段、临界区、退出段”的进程参与“谁进入临界区”的决策，且该决策不能被无限期推迟（即需在有限时间内确定下一个进入临界区的进程）。这一条件避免“资源空闲但进程长期等待”的低效场景，确保系统资源利用率🔶3-117、🔶3-119、🔶3-135、🔶3-136、🔶3-137、🔶3-138、🔶3-139、🔶3-140、🔶3-141、🔶3-160、🔶3-161。

- **有限等待（Bounded Waiting）**  
  核心约束：当一个进程提出进入临界区的请求后，其他进程进入该临界区的次数必须有明确上限，避免该进程因“持续被其他进程插队”而无限期等待（即避免“饥饿”现象）。文档以“优先级调度”为例，说明低优先级进程需通过“老化”机制提升优先级，满足有限等待条件，确保所有进程最终能访问临界资源🔶3-117、🔶3-120、🔶3-147、🔶3-148、🔶3-149、🔶3-150、🔶3-151、🔶3-162。

## 6.2 同步机制（Synchronizing Mechanisms）
### 6.2.1 应用程序级：软件算法（Software Algorithms）
软件算法是用户态下实现进程同步的经典方案，无需依赖硬件或操作系统内核，核心通过共享变量与逻辑判断实现互斥，典型代表为Peterson解法与Bakery算法。

#### 6.2.1.1 Peterson解法
- **适用场景**：仅支持两个进程的同步，是双进程临界区问题的经典软件解决方案🔶3-166、🔶3-167、🔶3-169。
- **共享变量**：  
  1. `boolean flag[2]`：标记进程是否请求进入临界区，初始值均为`false`（`flag[i]=true`表示进程`Pi`需进入临界区）；  
  2. `int turn`：标记“当前轮到哪个进程进入临界区”，初始值可设为0或1🔶3-177、🔶3-178、🔶3-179。
- **核心逻辑**：进程通过“声明请求→让渡优先级→忙等待”三步实现互斥：  
  1. 进程`Pi`先将`flag[i]`设为`true`，声明进入临界区的请求；  
  2. 主动将`turn`设为对方进程`Pj`的标识，让渡优先级；  
  3. 通过`while (flag[j] && turn == j)`忙等待，直至`Pj`释放临界区（`flag[j]`变为`false`或`turn`切换为`i`）🔶3-183、🔶3-184、🔶3-188。
- **关键特点**：  
  1. 正确性：满足临界区问题的三大必要条件（互斥、进步、有限等待）；  
  2. 局限性：存在忙等待（进程在等待期间持续占用CPU），仅适用于双进程场景🔶3-193、🔶3-194、🔶3-195、🔶3-199。

#### 6.2.1.2 Bakery算法
- **适用场景**：支持`n≥2`个进程的同步，解决多进程临界区问题🔶3-215、🔶3-216。
- **核心原则**：通过“票号+进程ID”的字典序决定进入临界区的顺序，确保无冲突：  
  1. 进程进入临界区前申请唯一票号（最大现有票号+1）；  
  2. 票号越小优先级越高，票号相同时，进程ID越小优先级越高（即`(number[j], j) < (number[i], i)`时，`Pj`优先进入）🔶3-217、🔶3-218、🔶3-219、🔶3-220、🔶3-221、🔶3-223。
- **共享变量**：  
  1. `boolean choosing[n]`：标记进程是否正在申请票号，初始值均为`false`（`choosing[i]=true`表示`Pi`正在申请票号）；  
  2. `int number[n]`：存储各进程的票号，初始值均为0（`number[i]>0`表示`Pi`需进入临界区）🔶3-226、🔶3-227。
- **关键特点**：  
  1. 正确性：满足临界区问题的三大必要条件，支持多进程；  
  2. 局限性：存在忙等待（通过`while`循环等待票号优先级），票号可能无限增大但不影响逻辑🔶3-230、🔶3-231、🔶3-232、🔶3-233。


### 6.2.2 硬件级：同步硬件（Synchronization Hardware）
硬件级同步通过CPU提供的原子指令，直接保证共享变量操作的完整性，从硬件层面规避竞争条件，适用于多处理器系统。

#### 6.2.2.1 核心机制
核心是利用“原子硬件指令”（执行过程不可中断）处理共享变量，确保多个进程对共享变量的操作不会交织，从根源上避免竞争条件🔶3-237、🔶238、🔶3-243、🔶3-245。

#### 6.2.2.2 三种实现方案（了解）
1. **TestAndSet指令**：  
   - 功能：原子执行“测试+修改”操作——读取布尔变量`lock`的值，将其设为`true`，并返回原始值；  
   - 互斥逻辑：`lock`初始为`false`，进程通过`while (TestAndSet(&lock))`忙等待，直至`lock`变为`false`（获取互斥权），退出临界区时将`lock`设为`false`🔶3-239、🔶3-1038、🔶3-1039、🔶3-1045、🔶3-1046、🔶3-1047、🔶3-1050。
2. **Swap指令**：  
   - 功能：原子交换两个变量的值（如`Swap(&lock, &key)`）；  
   - 互斥逻辑：`lock`初始为`false`，进程将`key`设为`true`，通过`while (key == true) Swap(&lock, &key)`忙等待，直至`lock`与`key`交换（`key`变为`false`，获取互斥权）🔶3-240、🔶3-1053、🔶3-1054、🔶3-1055、🔶3-1056、🔶3-1061、🔶3-1065。
3. **中断屏蔽**：  
   - 逻辑：进程进入临界区前执行“关中断”指令，禁止CPU响应其他中断（避免进程被抢占），退出临界区后执行“开中断”指令；  
   - 局限性：仅适用于单处理器系统，关中断期间CPU无法处理其他任务，代价高，不适用于多处理器🔶3-241、🔶3-257、🔶3-258、🔶3-259、🔶3-260、🔶3-261、🔶3-262、🔶3-263。

#### 6.2.2.3 关键特点
- 优势：实现简单、效率高，尤其适用于多处理器系统，直接解决共享变量操作的原子性问题；  
- 劣势：存在忙等待（进程等待期间持续占用CPU资源）🔶3-250、🔶3-251、🔶3-252。


### 6.2.3 操作系统级：信号量（Semaphores）
信号量是操作系统内核提供的核心同步工具，通过内核级队列管理等待进程，避免忙等待，支持互斥与同步，是多进程环境的主流同步方案。

#### 6.2.3.1 基本定义与核心操作
- **定义**：内核空间的整数变量，分为两类——二元信号量（值仅0或1，又称互斥锁）、计数信号量（值为非负整数），用于实现进程间的互斥与同步🔶3-266、🔶3-267、🔶3-268、🔶3-269、🔶3-270、🔶3-271、🔶3-272、🔶3-283、🔶3-284、🔶3-285、🔶3-286、🔶3-287、🔶3-288、🔶3-289、🔶3-290、🔶3-291。
- **核心操作**：  
  1. `wait(S)`（又称P操作）：申请资源，`S.value--`，若`S.value < 0`，将进程加入等待队列并阻塞；  
  2. `signal(S)`（又称V操作）：释放资源，`S.value++`，若`S.value ≤ 0`，从等待队列唤醒一个进程🔶3-275、🔶3-276、🔶3-277、🔶3-337、🔶3-338、🔶3-339、🔶3-340、🔶3-341、🔶3-342。

#### 6.2.3.2 分类与无忙等待实现
- **分类**：  
  1. 二元信号量（Mutex Lock）：值仅0或1，用于进程互斥（如保护临界区）；  
  2. 计数信号量：值为非负整数，用于资源计数（如多实例资源的竞争）或同步🔶3-283、🔶3-284、🔶3-285、🔶3-286、🔶3-287、🔶3-288、🔶3-289、🔶3-290、🔶3-291。
- **无忙等待实现**：  
  信号量定义为包含“值（`value`）”与“等待队列（`list`）”的结构体，通过`block()`（挂起进程，转为等待态）和`wakeup(P)`（唤醒进程，转为就绪态）操作管理等待进程，避免忙等待🔶3-328、🔶3-329、🔶3-330、🔶3-331、🔶3-332、🔶3-333。

#### 6.2.3.3 物理意义与三种用法
- **物理意义**：  
  1. `S > 0`：表示当前可用共享资源的数目；  
  2. `S ≤ 0`：表示无可用资源，`|S|`为等待该资源的进程数🔶3-351、🔶3-352、🔶3-353、🔶3-354、🔶3-355、🔶3-356。
- **三种用法**：  
  1. **资源互斥**：定义二元信号量`mutex`（初值1），进程进入临界区前执行`wait(mutex)`，退出后执行`signal(mutex)`，确保临界区互斥访问🔶3-385、🔶3-386、🔶3-387、🔶3-388、🔶3-389、🔶3-405、🔶3-406；  
  2. **资源竞争**：定义计数信号量（初值为资源实例数`m`），多进程通过`wait(S)`申请资源、`signal(S)`释放资源，实现资源竞争的有序分配（如`m=6`个资源实例，`n=10`个进程竞争）🔶3-385、🔶3-390、🔶3-391、🔶3-392、🔶3-393、🔶3-369、🔶3-370、🔶3-371、🔶3-372、🔶3-373、🔶3-377、🔶3-378、🔶3-379、🔶3-380、🔶3-381、🔶3-382；  
  3. **进程同步**：定义二元信号量`sync`（初值0），需后执行的进程`Pj`先执行`wait(sync)`，需先执行的进程`Pi`执行完关键操作后执行`signal(sync)`，确保`Pj`在`Pi`之后执行🔶3-385、🔶3-394、🔶3-395、🔶3-396、🔶3-410、🔶3-411、🔶3-412、🔶3-413、🔶3-414、🔶3-415。

#### 6.2.3.4 潜在问题与注意事项
- **潜在问题**：  
  1. 死锁：多个进程循环等待对方持有的资源（如`P1`持有`S`请求`Q`，`P2`持有`Q`请求`S`）；  
  2. 饥饿：低优先级进程因高优先级进程持续占用资源，无限期等待🔶3-486、🔶3-487、🔶3-488、🔶3-489、🔶3-493、🔶3-494、🔶3-495、🔶3-496、🔶3-497、🔶3-498、🔶3-499、🔶3-500、🔶3-501、🔶3-502、🔶3-503、🔶3-504、🔶3-505、🔶3-506、🔶3-510、🔶3-511、🔶3-512、🔶3-513、🔶3-514、🔶3-515。
- **注意事项**：信号量是内核级机制，用户程序不可直接修改信号量值，需通过`wait()`/`signal()`等系统调用（如Windows的`WaitForSingleObject()`/`ReleaseSemaphore()`、Linux的`down()`/`up()`）间接操作🔶3-359、🔶3-360、🔶3-361、🔶3-362、🔶3-363、🔶3-518、🔶3-519、🔶3-520、🔶3-521。


### 6.2.4 编程环境级：管程（Monitors）
管程是高级同步结构，通过“封装共享资源与访问逻辑”简化同步编程，由编程语言或编程环境提供支持，自动实现互斥，避免信号量操作不当导致的问题。

#### 6.2.4.1 核心定义与组成部分
- **定义**：将“共享变量”与“访问共享变量的并发过程”封装为一个整体，统一管理临界区，确保同一时间仅一个进程在管程内活动，是面向对象思想在同步中的应用🔶3-868、🔶3-869、🔶3-870、🔶3-871、🔶3-878、🔶3-879、🔶3-880、🔶3-881、🔶3-882、🔶3-883。
- **组成部分**：  
  1. 共享变量：代表需保护的共享资源；  
  2. 条件变量：实现进程在管程内的等待与唤醒；  
  3. 并发过程：访问共享变量的函数（对应临界区逻辑）；  
  4. 初始化代码：初始化共享变量与条件变量🔶3-885、🔶3-886、🔶3-887、🔶3-888、🔶3-889、🔶3-890、🔶3-891、🔶3-892、🔶3-893、🔶3-906、🔶3-907、🔶3-908、🔶3-909、🔶3-910。

#### 6.2.4.2 核心特性与条件变量
- **核心特性**：自动实现互斥——管程确保同一时间仅一个进程能执行管程内的并发过程，无需开发者手动设计互斥逻辑，简化编程🔶3-894、🔶3-895、🔶3-898、🔶3-899、🔶3-900。
- **条件变量（Conditional Variables）**：  
  用于解决“进程在管程内需等待特定条件”的问题，仅支持`wait()`与`signal()`两种操作：  
  1. `x.wait()`：挂起当前进程，释放管程控制权，等待其他进程通过`x.signal()`唤醒；  
  2. `x.signal()`：唤醒一个因`x`等待的进程，若无等待进程则该操作无效果🔶3-902、🔶3-903、🔶3-904、🔶3-905、🔶3-918、🔶3-919、🔶3-920、🔶3-921、🔶3-922、🔶3-923、🔶3-924、🔶3-925。

#### 6.2.4.3 关键特点
- 优势：简化同步编程，将分散的临界区逻辑集中管理，避免信号量操作顺序错误导致的死锁；由Java、C++等高级编程语言原生支持（如Java的`synchronized`关键字本质是管程的简化实现）；  
- 适用场景：多进程需频繁访问共享资源的场景（如生产者-消费者问题、哲学家就餐问题）🔶3-872、🔶3-873、🔶3-874、🔶3-875、🔶3-876、🔶3-877、🔶3-927、🔶3-928、🔶3-929、🔶3-931、🔶3-932、🔶3-933、🔶3-934、🔶3-935、🔶3-936、🔶3-937、🔶3-938、🔶3-939、🔶3-940、🔶3-941、🔶3-942、🔶3-943、🔶3-946、🔶3-947、🔶3-948。

## 6.3 经典同步问题（Classical Problems of Synchronization）
经典同步问题是进程同步机制的核心应用场景，通过解决“资源互斥”“进程协作”类问题，验证同步机制的正确性与实用性，主要包括有界缓冲区问题、读写者问题、哲学家就餐问题与理发师问题。


### 6.3.1 有界缓冲区问题（Bounded-Buffer Problem / 生产者-消费者问题）
有界缓冲区问题（又称生产者-消费者问题）是最基础的同步问题，核心解决“生产者向固定大小缓冲区存数据”与“消费者从缓冲区取数据”的协作与互斥，避免缓冲区满时存数据、空时取数据的错误。

#### 6.3.1.1 问题描述
- 场景定义：存在两类进程——生产者（生成数据并放入缓冲区）、消费者（从缓冲区取出数据并处理），缓冲区大小固定为`n`（最多存储`n`个数据项）；  
- 核心约束：  
  1. 生产者不能向已满的缓冲区放入数据；  
  2. 消费者不能从空的缓冲区取出数据；  
  3. 生产者与消费者对缓冲区的访问需互斥（避免同时操作导致数据覆盖或丢失）🔶3-528、🔶3-548、🔶3-554。

#### 6.3.1.2 信号量解法
通过三类信号量协调生产者与消费者的行为，确保约束满足：
- **核心信号量定义**：  
  1. `mutex`（二元信号量）：保护缓冲区的互斥访问，避免多个进程同时操作缓冲区，初值为1；  
  2. `empty`（计数信号量）：记录空缓冲区的数量，生产者需申请空缓冲区才能存数据，初值为`n`（缓冲区总大小）；  
  3. `full`（计数信号量）：记录满缓冲区的数量（即已存储的数据项数），消费者需申请满缓冲区才能取数据，初值为0🔶3-563、🔶3-564、🔶3-565、🔶3-566、🔶3-567、🔶3-568、🔶3-569、🔶3-570、🔶3-571、🔶3-572、🔶3-573、🔶3-574。

- **进程逻辑**：  
  1. **生产者逻辑**：先申请空缓冲区，再申请缓冲区互斥权，存数据后释放互斥权并通知消费者有新数据：  
     ```c
     do {
         produce an item in nextp;  // 生成数据
         wait(empty);               // 申请空缓冲区（无则阻塞）
         wait(mutex);               // 申请缓冲区互斥访问权
         add nextp to buffer;       // 放入缓冲区
         signal(mutex);             // 释放互斥访问权
         signal(full);              // 通知消费者：满缓冲区数+1
     } while (1);
     ```  
  2. **消费者逻辑**：先申请满缓冲区，再申请缓冲区互斥权，取数据后释放互斥权并通知生产者有空闲缓冲区：  
     ```c
     do {
         wait(full);                // 申请满缓冲区（无则阻塞）
         wait(mutex);               // 申请缓冲区互斥访问权
         remove an item from buffer to nextc;  // 取出数据
         signal(mutex);             // 释放互斥访问权
         signal(empty);             // 通知生产者：空缓冲区数+1
         consume the item in nextc; // 处理数据
     } while (1);
     ```  

- **关键注意事项**：`wait`操作顺序不可颠倒——必须先执行`wait(empty)`/`wait(full)`（判断资源是否可用），再执行`wait(mutex)`（申请互斥权）；若先申请互斥权，可能导致进程持有互斥权却因资源不足阻塞，引发其他进程无法访问缓冲区的死锁🔶3-578、🔶3-581、🔶3-582、🔶3-585、🔶3-586、🔶3-588、🔶3-589、🔶3-591。

#### 6.3.1.3 管程解法
通过管程封装缓冲区操作，利用条件变量实现进程等待与唤醒，简化同步逻辑：
- **管程设计**：定义管程`pc`（producer-consumer），内部包含：  
  1. 共享变量：缓冲区`buffer`、缓冲区大小`n`；  
  2. 条件变量：`empty`（缓冲区空时，消费者等待）、`full`（缓冲区满时，生产者等待）；  
  3. 并发过程：`add(int i)`（生产者调用，向缓冲区存数据）、`remove(int i)`（消费者调用，从缓冲区取数据）；  
- **核心逻辑**：  
  - 生产者调用`pc.add(i)`时，若缓冲区满则通过`empty.wait()`挂起，存数据后通过`full.signal()`唤醒等待的消费者；  
  - 消费者调用`pc.remove(i)`时，若缓冲区空则通过`full.wait()`挂起，取数据后通过`empty.signal()`唤醒等待的生产者；  
  管程自动保证同一时间仅一个进程执行`add`或`remove`，无需手动管理互斥🔶3-898、🔶3-899、🔶3-900、🔶3-927、🔶3-928、🔶3-929。


### 6.3.2 读写者问题（Readers-Writers Problem）
读写者问题聚焦“多进程并发访问共享数据”的场景，核心是平衡“读者并发读”与“读写/写写互斥”，避免数据不一致，常见解法为“读者优先”，也可扩展为“写者优先”等变体。

#### 6.3.2.1 问题约束与核心目标
- **问题约束**：共享数据（如文件、数据库表）需支持两类操作——读操作（读者进程）、写操作（写者进程），约束如下：  
  1. 多个读者可同时执行读操作（R-R兼容）；  
  2. 读者与写者不能同时操作（R-W互斥）；  
  3. 多个写者不能同时操作（W-W互斥）🔶3-597、🔶3-598、🔶3-599、🔶3-600、🔶3-601、🔶3-602、🔶3-603；  
- **核心目标**：在满足互斥约束的前提下，协调读写顺序，避免数据不一致（如读操作期间写操作修改数据导致读错）。

#### 6.3.2.2 信号量解法（读者优先）
通过“共享变量+两类信号量”实现读者优先的读写协调，读者优先体现在“已有读者在读时，新读者可直接加入，写者需等待所有读者完成”：
- **共享变量与信号量定义**：  
  1. 共享变量`readcount`：记录当前正在执行读操作的读者数量，初值为0；  
  2. 信号量`wrt`（二元信号量）：保证写操作与读操作的互斥，初值为1；  
  3. 信号量`mutex`（二元信号量）：保护`readcount`的互斥访问（避免多个读者同时修改`readcount`），初值为1🔶3-616、🔶3-617、🔶3-618、🔶3-619、🔶3-620、🔶3-621、🔶3-622、🔶3-623、🔶3-624。

- **进程逻辑**：  
  1. **读者逻辑**：先更新读者计数，若为首个读者则禁止写操作，读完成后更新计数，若为最后一个读者则允许写操作：  
     ```c
     do {
         wait(mutex);               // 申请修改readcount的互斥权
         readcount++;               // 读者数+1
         if (readcount == 1)        // 首个读者：禁止写操作
             wait(wrt);
         signal(mutex);             // 释放readcount互斥权
         
         // 读操作：访问共享数据
         read the shared data;
         
         wait(mutex);               // 申请修改readcount的互斥权
         readcount--;               // 读者数-1
         if (readcount == 0)        // 最后一个读者：允许写操作
             signal(wrt);
         signal(mutex);             // 释放readcount互斥权
     } while (1);
     ```  
  2. **写者逻辑**：申请写操作互斥权，写完成后释放，确保写操作期间无读者或其他写者干扰：  
     ```c
     do {
         wait(wrt);                 // 申请写操作互斥权（无读者/写者时获取）
         
         // 写操作：修改共享数据
         write the shared data;
         
         signal(wrt);               // 释放写操作互斥权
     } while (1);
     ```  

#### 6.3.2.3 扩展问题
基础读写者问题可根据场景需求扩展，常见变体包括：  
- 写者优先：新写者到达时，优先于后续读者执行，避免写者长期等待；  
- 多队读者：多组读者（如两队士兵相向过独木桥），同组读者可并发，不同组读者互斥；  
- 最多`m`个读者同时读：通过计数信号量限制并发读者数量，避免读者过多导致CPU/内存资源过载🔶3-666、🔶3-667、🔶3-668、🔶3-669、🔶3-670、🔶3-671、🔶3-672、🔶3-673、🔶3-674、🔶3-675、🔶3-676、🔶3-677。


### 6.3.3 哲学家就餐问题（Dining-Philosophers Problem）
哲学家就餐问题是“多进程竞争多资源”的经典模型，核心解决“进程需同时获取多个资源才能执行”的互斥与死锁避免，可推广到I/O设备分配、数据库事务等场景。

#### 6.3.3.1 问题描述
- 场景定义：5个哲学家围坐在圆桌旁，交替进行“思考”与“就餐”；圆桌上有5根筷子（每根筷子位于两个哲学家之间），哲学家就餐需同时拿起左右两根筷子，每次仅能拿起一根筷子；  
- 核心约束：  
  1. 哲学家仅能拿起身边的筷子；  
  2. 一次仅能拿起一根筷子；  
  3. 拿到两根筷子后才能就餐，就餐完成后需放下两根筷子🔶3-692、🔶3-693、🔶3-694、🔶3-695、🔶3-696、🔶3-697、🔶3-698、🔶3-699、🔶3-700。

#### 6.3.3.2 错误解法（易死锁）
最直观的错误解法是“每个哲学家先拿左筷子，再拿右筷子”，具体逻辑为：  
- 定义信号量数组`chopstick[5]`（每根筷子对应一个二元信号量，初值为1，代表筷子可用）；  
- 哲学家`i`的逻辑：`wait(chopstick[i])`（拿左筷子）→`wait(chopstick[(i+1)%5])`（拿右筷子）→就餐→`signal(chopstick[i])`→`signal(chopstick[(i+1)%5])`；  
- **死锁原因**：若5个哲学家同时拿起左筷子，会导致所有哲学家均无法拿到右筷子，陷入“循环等待”的死锁状态🔶3-713、🔶3-714、🔶3-715、🔶3-716、🔶3-717、🔶3-721、🔶3-722、🔶3-723、🔶3-724、🔶3-725、🔶3-726、🔶3-731。

#### 6.3.3.3 正确信号量解法
通过“状态管理+信号量唤醒”避免死锁，核心是确保哲学家仅在“左右邻居均未就餐”时才能拿起筷子：
- **共享变量与信号量定义**：  
  1. 状态数组`state[5]`：记录每个哲学家的状态，取值为`thinking`（思考）、`hungry`（饥饿，需就餐）、`eating`（就餐），初始值均为`thinking`；  
  2. 信号量数组`self[5]`：每个哲学家的等待信号量，初值为0（哲学家饥饿时阻塞，满足条件时被唤醒）；  
  3. 信号量`mutex`（二元信号量）：保护`state`数组的互斥访问，初值为1🔶3-739、🔶3-740、🔶3-741、🔶3-742、🔶3-743、🔶3-744。

- **核心函数**：  
  1. `test(int i)`：判断哲学家`i`是否能进入就餐状态，若左右邻居均未就餐且自身饥饿，则设置状态为`eating`并唤醒自身：  
     ```c
     void test(int i) {
         if (state[(i+4)%5] != eating  // 左邻居未就餐
             && state[i] == hungry     // 自身饥饿
             && state[(i+1)%5] != eating) {  // 右邻居未就餐
             state[i] = eating;        // 进入就餐状态
             signal(self[i]);          // 唤醒哲学家i
         }
     }
     ```  
  2. `pickup(int i)`：哲学家`i`申请筷子，设置状态为`hungry`并调用`test`，若不满足条件则阻塞：  
     ```c
     void pickup(int i) {
         wait(mutex);                 // 申请修改state的互斥权
         state[i] = hungry;           // 标记为饥饿
         test(i);                     // 判断是否能就餐
         signal(mutex);               // 释放state互斥权
         wait(self[i]);               // 不满足条件则阻塞，等待唤醒
     }
     ```  
  3. `putdown(int i)`：哲学家`i`释放筷子，设置状态为`thinking`并唤醒左右邻居：  
     ```c
     void putdown(int i) {
         wait(mutex);                 // 申请修改state的互斥权
         state[i] = thinking;         // 标记为思考
         test((i+4)%5);               // 唤醒左邻居
         test((i+1)%5);               // 唤醒右邻居
         signal(mutex);               // 释放state互斥权
     }
     ```  

- **哲学家主逻辑**：`thinking()`→`pickup(i)`→`eating()`→`putdown(i)`，循环执行🔶3-747、🔶3-748、🔶3-752、🔶3-753、🔶3-755。

#### 6.3.3.4 管程解法
通过管程封装`state`数组、`self`条件变量与核心函数，简化同步逻辑：
- 定义管程`dp`（dining-philosophers），内部包含：  
  1. 共享变量：`state[5]`（状态数组）；  
  2. 条件变量：`self[5]`（哲学家等待条件变量）；  
  3. 并发过程：`pickup(int i)`、`putdown(int i)`、`test(int i)`；  
- 管程自动保证`state`数组的互斥访问，无需手动管理`mutex`信号量，开发者仅需调用`dp.pickup(i)`与`dp.putdown(i)`即可实现哲学家的就餐逻辑🔶3-931、🔶3-932、🔶3-933、🔶3-934、🔶3-935、🔶3-936、🔶3-937、🔶3-938、🔶3-939、🔶3-940、🔶3-941、🔶3-942、🔶3-943、🔶3-946、🔶3-947、🔶3-948。


### 6.3.4 理发师问题（Sleeping-Barber Problem）
理发师问题综合“资源竞争”与“进程同步”，核心解决“顾客与理发师的协作”“顾客竞争等待椅”的问题，需避免顾客无限等待或理发师空闲时无顾客的低效场景。

#### 6.3.4.1 问题描述
- 场景定义：理发店包含两部分——等待室（有`N`个等待椅）、理发室（有1个理发椅和1个理发师）；  
- 核心行为：  
  1. 理发师：无顾客时睡觉，有顾客时理发，理完后召唤下一个等待顾客；  
  2. 顾客：进入理发店后，若等待椅未满则坐下等待，若理发师空闲则唤醒理发师；若等待椅已满则直接离开🔶3-767、🔶3-768、🔶3-769、🔶3-770、🔶3-771、🔶3-772、🔶3-825、🔶3-826、🔶3-827、🔶3-828、🔶3-829。

#### 6.3.4.2 核心矛盾
- 同步矛盾：顾客需唤醒睡觉的理发师，理发师需召唤等待的顾客，两者需协同避免“理发师空闲但顾客等待”或“顾客唤醒理发师后无人理发”；  
- 竞争矛盾：顾客需竞争有限的等待椅，避免等待椅满时顾客仍进入导致溢出🔶3-830、🔶3-831、🔶3-832、🔶3-833、🔶3-834、🔶3-835。

#### 6.3.4.3 信号量解法
通过“共享变量+三类信号量”协调理发师与顾客的行为，解决同步与竞争矛盾：
- **共享变量与信号量定义**：  
  1. 共享变量：`waitingN`（当前等待的顾客数，初值为0）、`CHAIRS`（等待椅总数，值为`N`）；  
  2. 信号量`customer`（二元信号量）：顾客用于唤醒理发师，初值为0（无顾客时理发师阻塞）；  
  3. 信号量`barber`（二元信号量）：理发师用于召唤等待顾客，初值为0（无空闲理发师时顾客阻塞）；  
  4. 信号量`mutex`（二元信号量）：保护`waitingN`的互斥访问，初值为1🔶3-838、🔶3-839、🔶3-840、🔶3-841、🔶3-842、🔶3-843、🔶3-844、🔶3-845、🔶3-846、🔶3-847、🔶3-848、🔶3-849、🔶3-850、🔶3-851。

- **进程逻辑**：  
  1. **理发师逻辑**：无顾客时阻塞，有顾客时理发，理完后减少等待顾客数并召唤下一个顾客：  
     ```c
     void Barber(void) {
         while (true) {
             wait(customer);          // 无顾客→阻塞，等待被顾客唤醒
             wait(mutex);             // 申请修改waitingN的互斥权
             waitingN--;              // 等待顾客数-1（即将理发）
             signal(mutex);           // 释放waitingN互斥权
             signal(barber);          // 召唤一个等待顾客（唤醒阻塞的顾客）
             cut_hair();              // 理发操作
         }
     }
     ```  
  2. **顾客逻辑**：判断等待椅是否已满，未满则等待或唤醒理发师，已满则离开：  
     ```c
     void Customer(void) {
         wait(mutex);                 // 申请修改waitingN的互斥权
         if (waitingN < CHAIRS) {     // 等待椅未满→进入等待
             waitingN++;              // 等待顾客数+1
             signal(customer);        // 唤醒理发师（若理发师睡觉）
             signal(mutex);           // 释放waitingN互斥权
             wait(barber);            // 等待理发师召唤（理发椅空闲）
             get_haircut();           // 理发操作
         } else {                     // 等待椅已满→离开
             signal(mutex);           // 释放waitingN互斥权
             leave_shop();            // 离开理发店
         }
     }
     ```  

- **关键逻辑**：`waitingN`通过`mutex`保护，避免多个顾客同时修改导致计数错误；`customer`与`barber`信号量实现理发师与顾客的双向唤醒，确保协作高效🔶3-858、🔶3-859、🔶3-860、🔶3-864、🔶3-865、🔶3-866。

## 6.4 操作系统中的同步实现（Case Studies）
### 6.4.1 Linux中的同步
Linux的同步实现以内核级工具为核心，结合硬件特性与调度策略，确保多进程/线程访问共享资源的安全性与效率，具体机制与特点如下：
- **核心同步机制**：
  1. **信号量**：通过`down()`（对应wait()操作，申请资源）和`up()`（对应signal()操作，释放资源）系统调用实现内核级信号量管理，支持一次申请或释放多个资源实例（如`down(n)`申请n个资源），简化多资源竞争场景的同步编程🔶3-362、🔶3-364；
  2. **自旋锁（Spinlock）**：属于忙等待型同步工具，适用于临界区执行时间短的场景；进程等待锁时不阻塞，持续检查锁状态（循环执行`TestAndSet`类原子指令），避免进程切换开销，是Linux内核中处理短临界区的核心工具🔶3-316；
  3. **读写锁**：专为“读多写少”场景优化，允许多个读者同时执行读操作，写操作需与读/写操作互斥；相较于传统信号量解法，Linux读写锁无需手动维护`readcount`等共享变量，直接通过锁机制实现读写协调，大幅简化编程🔶3-680、🔶3-681、🔶3-686。
- **关键特点**：支持处理器亲和性（硬亲和通过`sched_setaffinity()`指定进程可运行的处理器子集，软亲和默认让进程尽量在同一处理器执行），所有同步操作均在 kernel 态执行，避免用户态直接修改同步工具导致的安全性问题🔶3-631、🔶3-640。

### 6.4.2 Windows中的同步
Windows通过“优先级调度+专用API”实现同步，兼顾实时性与交互式场景需求，核心机制与优先级管理紧密结合：
- **核心同步机制**：
  1. **基于优先级的抢占式同步**：高优先级线程可抢占低优先级线程的CPU资源，同步工具（如信号量）的操作结果直接影响线程调度顺序，确保实时类进程（如工业控制任务）的同步需求优先满足🔶3-1071、🔶3-1072；
  2. **标准化同步API**：提供`WaitForSingleObject()`（等待信号量、互斥锁等同步对象，对应wait()操作）和`ReleaseSemaphore()`（释放信号量，对应signal()操作），封装内核级同步逻辑，用户程序通过API间接操作同步工具，保障安全性🔶3-360。
- **优先级管理**：采用32级优先级体系（0级为内存管理线程，1-15为可变类，16-31为实时类），同步过程中支持动态优先级调整：
  - 线程因等待事件（如I/O完成）重新就绪时，优先级会根据等待类型提升（I/O等待完成后提升更显著）；
  - 线程时间片耗尽时，优先级降低但不低于基准值；
  - 前台窗口线程可获得3倍优先级提升，优化交互式同步场景（如点击操作响应）的速度🔶3-1071、🔶3-1094、🔶3-1098。

### 6.4.3 Solaris中的同步
Solaris通过“多调度类+全局优先级映射”实现差异化同步，适配不同类型任务的资源需求，同步逻辑与调度策略深度融合：
- **调度类与同步适配**：支持6种调度类，各类同步工具的行为需结合调度类特性，确保任务类型与同步机制匹配：
  1. **时间共享类（TS，默认）**：适用于普通用户进程（如办公软件），采用多级反馈队列调度，同步时通过调度表配置时间片与优先级调整规则，避免线程因同步等待长期饥饿；
  2. **实时类（RT）**：适用于实时任务（如工业控制），同步工具优先级最高，确保同步操作在截止期内完成；
  3. **交互式类（IA）**：适用于终端交互进程，优先级低于TS，同步时优先保障交互响应性；
  此外还包括系统类（SYS，内核进程）、公平分享类（FSS，按用户配额分配资源）、固定优先级类（FP，优先级固定）🔶3-1112、🔶3-1113、🔶3-1114、🔶3-1115。
- **全局优先级映射**：所有调度类的优先级统一映射为全局优先级，决定同步时的资源抢占顺序，从高到低依次为：中断线程（最高，优先级169）→RT线程（100-159）→SYS线程（60-99）→FSS线程→FP线程→TS线程→IA线程（最低，0-59）；若多个线程优先级相同，采用时间片轮转调度协调同步顺序，避免单线程独占资源🔶3-1130、🔶3-1131、🔶3-1132。

## 六、6.5 附录（Appendix）
1. 附录6-1：同步硬件详细实现（TestAndSet、Swap指令的具体逻辑与应用）
2. 附录6-2：用信号量实现管程（通过mutex、next信号量和计数变量，封装管程的互斥与条件变量操作）

## 七、例题与习题（Examples and Exercises）
1. 信号量应用例题：进程执行顺序控制（如接力赛、多进程依赖关系）
2. 经典问题扩展：多生产者/多消费者、多类资源的哲学家问题等
3. 计算题：信号量取值范围、进程等待次数等