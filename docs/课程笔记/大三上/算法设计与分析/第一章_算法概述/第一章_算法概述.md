# 第一章：算法概述
## 总览
这份文档是北京邮电大学《算法设计与分析》这门课的第一章“算法概述”PPT内容，主要讲了两大部分：**课程相关安排**和**算法的核心基础概念**，用大白话拆解如下：


### 第一部分：这门课怎么上、怎么评分？
1. **上课节奏**：总共16周，每周2学时，学6类核心算法——先讲“算法入门”（前2周），再依次学“分治与递归”“动态规划”“贪心”“回溯”“分支界限”，每类算法学2-4周。  
2. **评分规则**：  
   - 期末闭卷考试占60%，平时成绩占40%；  
   - 平时分里，理论作业（比如做算法题）占10%，编程实验（写代码实现算法）占30%；  
   - 作业迟交会扣分（理论作业每周扣2分，编程每天扣10%），抄袭直接0分；  
   - 如果参加“CCF CSP认证”（一种编程能力考试），考300分以上能抵编程实验成绩（300分对应80分，380分就是满分）。  
3. **参考书**：推荐了3本，老师说“选一本看就行，别贪多”。


### 第二部分：算法到底是什么？怎么判断好坏？
1. **算法的核心问题**：同一问题能有多种解法（比如算1+2+…+100，能挨个加，也能凑50对101），但效率天差地别。我们学算法，就是要搞懂两件事：  
   - 怎么判断哪个算法更快、更省内存？  
   - 怎么设计出又快又省资源的算法？

2. **怎么评价一个算法“好不好”？**  
   有几个标准：比如结果对不对（正确性）、好不好懂（可读性）、能不能应对异常情况（比如输入错了不崩溃，叫健壮性），但最核心的是**时间复杂度**（跑得多快）和**空间复杂度**（占多少内存）。

3. **复杂度到底怎么算？不用算“精确步数”，看“增长趋势”**  
   - 比如算1+2+…+n，挨个加要n步，时间复杂度记成“跟n成正比”；如果是两层循环（比如简单排序），要n²步，就是“跟n的平方成正比”。  
   - 不用纠结“2n+3”里的“+3”，因为当n很大（比如n=100万），3和2n比起来可以忽略，重点看“n的几次方”“是不是指数增长”。  
   - 用几个符号简化描述：  
     - O（上界）：比如“2n+3=O(n)”，意思是“这算法最慢也就跟n成正比，不会更慢”；  
     - Ω（下界）：比如“2n+3=Ω(n)”，意思是“这算法最快也得跟n成正比，不会更快”；  
     - Θ（紧界）：比如“2n+3=Θ(n)”，意思是“这算法的速度就刚好跟n成正比，跑不快也慢不了多少”。

4. **哪些复杂度算“好”？哪些算“差”？**  
   常见复杂度按“增长快慢”排：  
   常数（比如查字典按页码，固定几步）< 对数（比如二分查找，n越大，步数涨得越慢）< 线性（比如挨个找元素）< nlogn（比如归并排序）< 平方（比如简单排序）< 立方 < 指数（比如汉诺塔问题）。  
   重点：指数增长巨可怕！比如汉诺塔问题，64片金片，普通电脑算到世界毁灭都算不完，超级计算机也得几分钟到几年。


### 第三部分：递归算法的复杂度怎么算？
递归就是“自己调用自己”（比如算阶乘，n! = n*(n-1)!），它的复杂度有4种常用算法：  
1. **代入法**：先猜一个复杂度（比如猜递归排序是O(nlogn)），再用数学归纳法证明猜对了；  
2. **迭代法**：把递归公式一层一层展开（比如T(n)=2T(n/2)+n，展开成T(n)=2[2T(n/4)+n/2]+n，直到拆到最底层），再求和；  
3. **递归树法**：画一棵“树”，每个节点代表一层递归的工作量，把所有节点的工作量加起来就是总复杂度；  
4. **主定理**：专门对付“T(n)=a*T(n/b)+f(n)”这种递归公式（比如二分查找是T(n)=T(n/2)+1），直接套公式就能出结果。


### 第四部分：空间复杂度是什么？举个例子
空间复杂度就是算法跑的时候占多少内存，比如：  
- 非递归的二分查找（在有序数组里找元素）：要存整个数组（占n个空间），还要存几个变量（比如左右边界、中间位置），所以空间复杂度是“跟n成正比”（Θ(n)）；  
- 递归的二分查找：除了数组，还要存“调用栈”（每次递归调用都要暂存参数），栈的深度是logn，所以空间复杂度是Θ(logn)。


### 最后：提了10个“主宰世界的算法”
比如排序用的归并/快速排序、处理信号的傅里叶变换、找最短路径的Dijkstra算法、加密用的RSA、压缩文件用的数据压缩算法等等，都是现实中用得超广的核心算法。