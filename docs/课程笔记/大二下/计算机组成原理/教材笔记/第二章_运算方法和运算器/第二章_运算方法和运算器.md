# 第二章：运算方法和运算器
## 2.1 数据与文字的表示方法
该节围绕**计算机中数据与文字的表示方法**展开，具体内容如下：

1. **数据类型分类**：计算机中使用的数据一般分为**数值数据**和**符号数据**两种类型。
2. **数值数据**：**表示数量的大小且可进行运算**。其常用的表示格式有**定点格式**和**浮点格式** 。**定点格式**容许的数值范围有限，所需处理硬件比较简单；**浮点格式**可表示的数值范围很大，但要求的处理硬件比较复杂。
3. **符号数据**：通常包括**文字、标点等，仅代表特定的标识**。例如，基于字母的西文字符系统一般用**ASCII码表示**，而**汉字有专门的编码方式** 。
4. **数的表示方式选择因素**：选择计算机数的表示方式时，需考虑以下因素：
    - 要表示的数的类型，如**小数、整数、实数和复数**；
    - 可能的**数值范围**；
    - **数值精确度**；
    - 数据存储和处理所需的**硬件代价** 。 
### 2.1.1 数据格式
该节主要介绍了计算机中**数据格式**的相关内容，具体如下：

1. **定点数的数据格式**：**定点格式**是指机器中所有数据的小数点位置固定不变，通常将数据表示成**纯小数或纯整数** 。若用\(n + 1\)位字表示定点数\(x\)，其中\(x_n\)表示符号位（\(0\)为正，\(1\)为负），其余位代表量值。当\(x\)为纯小数时，小数点位于\(x_n\)和\(x_{n - 1}\)之间，其表示范围为\(0 \leq |x| \leq 1 - 2^{-n}\)；当\(x\)为纯整数时，小数点位于最低位\(x_0\)右边，其表示范围为\(0 \leq x \leq 2^n - 1\)。目前计算机中多采用**定点纯整数表示**，相应运算称为整数运算。
2. **浮点数的表示方法**：由于定点格式表示数值范围有限，对于数值范围差异大的数，如电子质量和太阳质量，在定点计算机中处理不便 。**浮点表示法**将数的有效数字和数的范围在计算机存储单元中分别表示，相当于小数点位置随比例因子不同而自由浮动。任意二进制数\(N = 2^e·M\)，其中\(M\)为**尾数**（纯小数，决定表示精度），\(e\)为**阶码**（整数，决定表示范围） 。在机器中，一个浮点数由**阶码、尾数及其符号位**组成。
3. **十进制数串的表示方法**：大多数通用性强的计算机能直接处理十进制形式数据，主要有两种表示形式：
    - **字符串形式**：1字节存放一个十进制数位或符号位，在主存中占用连续多字节，需给出在主存中的起始地址和位数，常用于非数值计算领域。
    - **压缩的十进制数串形式**：1字节存放两个十进制数位，节省存储空间且便于十进制数算术运算 。每个数位占用半字节（4个二进制位），值可用二 - 十编码（BCD码）或数字符的ASCII码低4位表示，符号位占半字节放在最低数字位之后 。规定数位加符号位之和为偶数，不足时在最高数字位前补0。同样需给出在主存中的首地址和数字位个数（不含符号位），位长可变，许多机器规定长度为0 - 31 。 
### 2.1.2 数的机器码表示
该节主要介绍计算机中**数的机器码表示**方法，包括原码、补码、反码、移码以及浮点数的机器表示，具体内容如下：

1. **基本概念**：在计算机运算中，为处理符号位表示及参与运算等问题，产生了**原码、补码、反码、移码**等编码表示方法。一般书写的数称为**真值**，机器中编码表示的数称为**机器数或机器码**。
2. **原码表示法**：定点整数原码中，符号位加二进制数绝对值，正数符号位为0，负数为1。例如，**x = +1001**，**[x]原 = 01001**；**x = -1001**，**[x]原 = 11001** 。0有“+0”“-0”两种形式。原码表示简单，但**加法运算复杂**，需根据符号判断加减并比较绝对值。
3. **补码表示法**：以钟表对时为例，说明负数用补码表示可将减法转化为加法。定点整数和小数补码都有相应定义，0的补码只有一种形式 。补码进行减法运算方便，但求负数补码涉及减法，可通过**反码**过渡。正数的原码、反码、补码相同；负数原码变补码，需先将原码数值部分取反得反码，再给反码数值部分最低位加1 。
4. **移码表示法**：通常用于表示浮点数的阶码，定义为**[e]移=2k+e** ，k为阶码位数。移码中符号位表示规律与原码、补码、反码相反，便于指数大小比较和对阶操作。
5. **浮点数的机器表示**：当前计算机采用**IEEE754标准**表示浮点数，规定了32位短浮点数和64位长浮点数格式 。32位浮点数中，S为符号位，M为尾数域，E为阶码，阶符采用移码形式。为提高精度，规定**规格化表示形式**，并对特殊情况（如E = 255且M <> 0 等）进行定义。64位浮点数符号位1位，阶码域11位，尾数域52位，指数偏移值是1023。 最后通过多个例题，展示了浮点数与十进制数的相互转换，以及不同机器码表示的数值范围和计算方法。 
### 2.1.3 字符与字符串的表示方法
该节围绕**字符与字符串的表示方法**展开，具体内容如下：

1. **字符表示的背景**：现代计算机处理大量非数值领域问题，需引入**文字、字母及专用符号**表示文字语言、逻辑语言等信息，如人机交换信息时使用英文字母、标点符号、汉字字符及特殊符号等。因数字计算机只能处理二进制数据，这些信息需编写成二进制格式代码，即**符号数据**。
2. **ASCII码的介绍**：
    - **编码系统**：国际上普遍采用七单位的IRA码，其美国版为**ASCII码（美国国家信息交换标准字符码）**，包括10个十进制数码、26个英文字母和一定数量专用符号等，共128个元素。二进制编码需7位，加1个偶校验位共8位，为1字节。
    - **编码规则**：8个二进制位最高一位为0，余下7位给出128个编码表示128个不同字符。其中95个编码对应计算机终端能敲入、显示及打印机能打印的字符，如大小写英文字母、数字符、通用运算符和标点符号等；另外33个字符（编码值为0～31和127）为**控制码**，用于控制计算机外围设备工作特性和软件运行情况。
    - **与8421码的关系**：0～9这十个数字符号的8421码可将其ASCII码去掉b6b5b4(=011)得到。
3. **字符串的表示**：
    - **存储方式**：**字符串**指连续的一串字符，通常占用主存中连续多字节，每字节存一个字符。当主存字由2或4字节组成时，在同一个主存字中，字符串内容可按从低位字节向高位字节或从高位字节向低位字节的顺序存放，这两种方式都常用，不同计算机可任选一种。
    - **示例**：以字符串“IF A>B THEN READ(C)”为例，按从高位字节到低位字节依次存放在由4字节组成的主存单元中，每字节存放相应字符的ASCII值，空格也占1字节位置，具体每字节存放的十进制值分别为73，70，32，65，62，66，32，84，72，69，78，32，82，69，65，68，40，67，41，32 。 
### 2.1.4 汉字的表示和编码
该节聚焦**汉字的表示和编码**，鉴于字符数据在计算机应用中需支持输入、存储、输出和交换，且汉字编码较拼音文字复杂，因此介绍了三类常用编码，具体如下：

1. **汉字输入码**：旨在通过西文标准键盘输入汉字，主要有三类方法：
    - **数字编码**：如**国标区位码**，将6763个两级汉字分94区，每区分94位，以二维数组下标作为区位码，输入时需按键四次 ，例如“中”字区位码为5448。其优点是无重码、与内部编码转换方便，缺点是代码难记。
    - **拼音码**：基于汉语拼音，易上手但重码率高，需进行同音字选择，影响输入速度。部分拼音码改进为“双拼” ，以缩减按键次数。
    - **字形编码**：依据汉字形状，将笔画部件编码后按序输入，**五笔字型编码**是典型代表。此外，还有音形混合编码及词组输入、联想输入等快速方法，同时**语音识别技术和OCR技术**也已成熟，可实现更快速输入。
2. **汉字交换码**：早期计算机系统汉字内码不统一，为实现系统间正确交换汉字编码，制定了统一标准，常用的有GB/T 2312—1980、GB 18030—2022、BIG5、GBK等 。
    - **GB/T 2312—1980**：收录7445个常用汉字和图形符号，汉字6763个（含一级3755个、二级3008个），图形符号682个，采用2字节编码，每字节最高位为1。
    - **GB 18030—2022**：收录汉字及部首88115个，较2005版新增1.7万余个生僻汉字，采用不等长编码（单字节、双字节、四字节） ，单字节与ASCII码兼容，双字节与GB/T 2312—1980向下兼容，与UCS/Unicode字符集基本兼容，UCS/Unicode常用编码方案UTF - 8和UTF - 16对不同字符有不同字节编码方式。
3. **汉字输出码**：用于汉字显示、打印的外形编码，分为**点阵和矢量**两种形式：
    - **点阵形式**：以二维点阵存储汉字形状，点数影响显示美观度与存储空间，如32×32点阵的汉字占用128字节，字库存储量大，编码直观但放大易失真。
    - **矢量形式**：存储汉字字形轮廓特征，显示或打印时经数学运算转换外观，放大后笔画仍圆滑，输出质量高。 
### 2.1.5 校验码
该节围绕**校验码中的检错码——奇偶校验码**展开，具体内容如下：

1. **校验码的产生背景**：由于**元件故障、噪声干扰**等因素，计算机处理信息时易出现错误，如二进制数在部件间传送可能受噪声干扰而改变 。为**检测甚至校正错误**，采用专门逻辑电路编码，常见方式是在字上添加**校验位**，用于确定错误位置，计算机常用此技术检验存储器读写或信息传输的正确性，该节仅介绍**检错码**。
2. **奇偶校验码的原理**：
    - **基本概念**：**奇偶校验码**是**最简单且应用广泛的检错码**，通过在信息位外增加**一位校验码**，使包含校验位后的数据中**1的个数保持为奇数（奇校验）或偶数（偶校验）** 。
    - **校验位计算**：设 \(X=(x_0x_1…x_{n–1})\) 是一个 \(n\) 位字，**奇校验位 \(C\)** 定义为 \(C = x_0 \oplus x_1 \oplus …\oplus x_{n–1}\) ，只有当 \(X\) 中包含奇数个 1 时， \(C = 1\)，否则 \(C = 0\)；**偶校验位 \(C\)** 同样为 \(C = x_0 \oplus x_1 \oplus …\oplus x_{n–1}\) ，当 \(X\) 中包含偶数个 1 时， \(C = 0\) 。这里 \(\oplus\) 代表按位加。
3. **奇偶校验码的使用流程**：以字 \(X\) 从部件 \(A\) 传送到部件 \(B\) 为例，在源点 \(A\) 按公式算出校验位 \(C\) ，并将 \((x_0x_1…x_{n–1}C)\) 传送到 \(B\) ；在 \(B\) 点接收数据 \(X'=(x_0'x_1'…x_{n–1}'C')\) 后，计算 \(F = x_0' \oplus x_1' \oplus …\oplus x_{n–1}' \oplus C'\) ，若 \(F = 1\) ，则表明收到的信息有错；若 \(F = 0\) ，则表明字 \(X\) 传送正确 。
4. **奇偶校验码的特点**：
    - **优点**：**简单易实现**，因此被广泛应用。
    - **缺点**：只能**检测出奇数个错误**，无法检测出偶数个错误，也**不能识别错误信息的位置**，无法纠错。一旦检测到错误，只能丢弃数据，重新传输 。
5. **奇偶校验码的应用示例**：通过【例2.11】，对给定的5字节数据分别进行偶校验和奇校验编码，假定最低一位为校验位，其余高8位为数据位，校验位的值由数据位中1的个数决定 。 
## 2.2 定点加法、减法运算
### 2.2.1 补码加法
该节围绕**补码加法**展开，主要内容如下：

1. **补码加法的意义与公式**：
    - **意义**：在数的补码表示法下，**负数用补码表示后可与正数同样处理**，使得运算器只需一个加法器，无需为负数加法单独配备减法器 。
    - **公式**：**[x+y]补=[x]补+[y]补 (mod 2n+1)**，此为补码加法的理论基础，意味着在模2n+1意义下，任意两数的补码之和等于该两数之和的补码。
2. **补码加法公式的证明**：采用定点整数表示，基于先决条件**x＜(2n–1)，y＜(2n–1)，x + y＜(2n–1)**，分四种情况证明：
    - **x≥0，y≥0**：两数为正，和也为正，正数补码与原码相同，所以**[x]补+[y]补=x+y=[x+y]补 (mod 2n+1)**。
    - **x≥0，y＜0**：两数一正一负，结果有正有负，根据补码定义，**[x]补=x，[y]补=2n+1 +y**，进而推出**[x]补+[y]补=2n+1 +(x+y)=[x+y]补 (mod 2n+1)** 。
    - **x＜0，y≥0**：依据真值相加和补码相加的交换率，以及情况(2)的结论，可推导出**[x+y]补 = [x]补+[y]补**。
    - **x＜0，y＜0**：两数为负，和也为负，由**[x]补=2n+1 +x，[y]补=2n+1 +y**，可得**[x]补+[y]补=2n+1 +(2n+1 +x+y)=[x+y]补 (mod 2n+1)** 。
3. **补码加法的特点与实例**：
    - **实例**：通过两个例子演示补码加法运算。如**x=+1001，y=+0101**，**[x]补=01001，[y]补=00101**，相加得**[x+y]补=01110**，即**x+y = +1110**；再如**x=+1011，y= –0101**，**[x]补=01011，[y]补=11011**，相加得**[x+y]补=00110**（舍去进位），即**x+y = +0110** 。
    - **特点**：一是**符号位要作为数的一部分一起参加运算**；二是在**模2n+1的意义下相加，超过2n+1的进位要丢掉**。 
### 2.2.2 补码减法
该节围绕**补码减法**展开，主要介绍将补码减法运算转换为加法运算的原理、公式推导、证明过程、求[-y]补的法则，以及通过实例演示计算过程，具体如下：

1. **补码减法的目的**：补码加法运算算法统一，若将**补码减法运算转换为加法运算**，就能实现**补码加减运算的统一**，使用同一加法器电路完成，从而**简化计算机设计**。
2. **补码减法公式推导**：已知[x]补和[y]补，求[x - y]补。因为真值的加减可相互转化，由**补码加法公式[x + y]补 = [x]补 + [y]补 (mod 2n+1)** ，可得**补码减法运算公式[x - y]补 = [x + (-y)]补 = [x]补 + [-y]补** 。
3. **求[-y]补的法则**：由[y]补求[-y]补，需对[y]补**包括符号位在内“各位取反，末位加1”** 。若[y]补 = \(y_{n}y_{n - 1}\cdots y_{1}y_{0}\)，则[-y]补 = \(\overline{y_{n}y_{n - 1}\cdots y_{1}y_{0}}\) + 1 。对于**定点纯小数**，末位加1需改为加\(2^{-n}\)。
4. **[-y]补 = -[y]补的证明**：令x = -y，则[x + y]补 = [x]补 + [y]补 = [-y]补 + [y]补，又[x + y]补 = [-y + y]补 = [0]补 = 0，所以[-y]补 + [y]补 = 0，即**[-y]补 = -[y]补 (mod 2n+1)** ，再结合\(\overline{y_{n}y_{n - 1}\cdots y_{1}y_{0}}\) + 1 = \(-y_{n}y_{n - 1}\cdots y_{1}y_{0}\) ，完成证明。
5. **实例演示**：
    - **例2.14**：已知\(x_{1} = -1110\)，\(x_{2} = +1101\)，计算可得[x1]补 = 10010，[-x1]补 = 01110，[x2]补 = 01101，[-x2]补 = 10011 。
    - **例2.15**：已知x = +1101，y = +0110，先求出[x]补 = 01101，[y]补 = 00110，[-y]补 = 11010，通过[x]补 + [-y]补得到[x - y]补 = 00111，所以x - y = +0111 。 
### 2.2.3 溢出概念与检测方法
该节围绕**溢出概念与检测方法**展开，具体内容如下：

1. **溢出概念**：对于特定字长和数据格式的定点数，其可表示的数据范围是固定的，如8位二进制纯整数补码表示范围是–128～+127，16位则为–32768～+32767 。**运算结果超出能表示的数的范围就会产生“溢出”** ，溢出时计算结果错误，运算器需检测到溢出并让计算机做出反应 。通过**例2.16**（两个正数相加结果为负）和**例2.17**（两个负数相加结果为正）展示了溢出导致错误的情况，其中两个正数相加结果大于能表示的最大正数称为**正溢**，两个负数相加结果小于能表示的最小负数称为**负溢** 。
2. **溢出检测方法**：
    - **双符号位法（变形补码）**：
        - **原理**：使模2n+2补码表示数的范围扩大一倍，用同余式[x]补=2n+2 +x (mod 2n+2)，且[x]补+[y]补=[x+y]补 (mod 2n+2)，运算时两个符号位都参与运算，以2n+2为模的加法中最高符号位进位丢掉 。
        - **判断规则**：正数的两个符号位都是“0”，负数的两个符号位都是“1” 。**结果符号位出现“01”或“10”表示溢出**，最高符号位代表结果正确符号 。通过**例2.18**（符号位“01”，正溢出）和**例2.19**（符号位“10”，负溢出）进行了说明。
        - **结论**：变形补码运算时，**两符号位相异表示溢出，相同表示未溢出**，溢出逻辑表达式为V=Sf1⊕Sf2（Sf1和Sf2分别是最高和第二符号位），可用异或门实现；模2n+2补码相加，**不论是否溢出，最高符号位始终指示正确符号** 。
    - **单符号位法**：从实例可知，**最高有效位有进位而符号位无进位时产生正溢，最高有效位无进位而符号位有进位时产生负溢** 。溢出逻辑表达式为V=Cf ⊕C0（Cf为符号位进位，C0为最高有效位进位），也可用异或门实现 。
3. **溢出处理**：在定点机中，**运算结果溢出表示出错**，机器通过逻辑电路自动检测溢出，并进行**中断处理** 。 
### 2.2.4 行波进位二进制加/减法器
该节内容围绕**行波进位二进制加/减法器**展开，主要介绍其基本组成、工作原理、实现方式、时间延迟及改进方向，具体如下：

1. **全加器的定义与逻辑方程**：
    - **定义**：在计算机内部，**全加器（FA）是加减法运算器的最基本单位** 。它对两个二进制数字 **Ai、Bi** 和一个 **进位输入Ci** 进行相加，产生 **和输出Si** 以及 **进位输出Ci+1** 。
    - **逻辑方程**：根据全加器的输入输出真值表，三个输入端和两个输出端的逻辑关系为 **Si=AiBiCi** ， **Ci+1=AiBi+BiCi+CiAi=AiBi+(AiBi)Ci**  。按此表达式组成的FA中，**进位链采用1个与门和1个或门** 。
    - **时间延迟**：以单级逻辑电路的单位门延迟 **T** 为基准，单级与非门、或非门及非门的时间延迟为 **T** ，单级与门、或门的延迟为 **2T** ，单级异或门的延迟为 **3T** 。一位全加器 **求和结果Si的时间延迟为6T，Ci+1的时间延迟为2T（不含异或门延迟3T）** 。
2. **串行加法器与并行加法器**：
    - **串行加法器**：理论上，**一个全加器加上移位寄存器、计数器和多路开关等部件可实现串行加法器** ，其硬件复杂度低，但 **运算速度非常低** 。
    - **并行加法器**：计算机的运算器通常采用 **并行加法器方案** ，即 **用多个全加器同时对二进制数的多个二进制位进行运算** 。 **n个1位的全加器可级联成一个n位的行波进位加减器** 。
3. **行波进位二进制加/减法器的工作原理**：
    - **控制方式**：通过 **方式控制输入线M** 控制运算类型，**当M=0时，做加法（A+B）运算；当M=1时，做减法（A–B）运算** ，减法运算转化为 **[A]补+[–B]补** 运算，**求补过程由B +1实现** ，因此 **最右边全加器的起始进位输入端连接到功能方式线M上** ，做减法时 **M=1** ，相当于在加法器最低位上加1。
    - **溢出检测**：采用 **单符号位法检测溢出** ，**当Cn=Cn–1时，运算无溢出；当Cn≠Cn–1时，运算有溢出** ，通过 **异或门产生溢出信号** 。
4. **行波进位二进制加/减法器的时间延迟**：**n位行波进位加法器的延迟时间ta =n·2T+9T=(2n+9)T** ，其中 **9T为最低位上的两级异或门再加上溢出异或门的总时间** ， **2T为每级进位链的延迟时间** 。该时间表示 **在最坏情况下加法器输出端得到稳定求和输出所需的最长时间** ，时间越小越好。
5. **运算器速度的提升方向**：提高运算器运算速度的方法包括 **选择更高速的器件以降低T的值** （可能导致成本上升），以及 **改进全加器的组织结构** ， **把串行进位改为并行进位（先行进位）是最普遍的方法** 。 
### 2.2.5 单级分组先行进位加法器
该节围绕**单级分组先行进位加法器**展开，具体内容如下：

1. **改进思路与原理**：为改进串行进位并行加法器，需实现各二进制位进位运算同时进行，避免高有效位等待低有效位进位输出。进位输出由 **A<sub>i</sub>B<sub>i</sub>**（本地进位，仅当 **A<sub>i</sub>=1，B<sub>i</sub>=1** 时为1）和 **(A<sub>i</sub>⊕B<sub>i</sub>)C<sub>i</sub>**（条件进位，仅当 **A<sub>i</sub>≠B<sub>i</sub>** 时可能为1）两部分相或而成 。定义 **G<sub>i</sub>=A<sub>i</sub>B<sub>i</sub>** 为**进位产生函数**，**P<sub>i</sub>=A<sub>i</sub>⊕B<sub>i</sub>** 为**进位传递函数**，由此将进位输出表达式变形，可从最低进位 **C<sub>0</sub>** 直接求得所有进位，无需等待低位进位。
2. **实现方式与延迟**：
    - **实现方式**：一般通过两级与非门实现 **C<sub>i</sub>** ，如 **C<sub>1</sub>=G<sub>0</sub>+P<sub>0</sub>C<sub>0</sub>=G<sub>0</sub>·P<sub>0</sub>C<sub>0</sub>** 。
    - **延迟时间**：若每级与非门延迟为 **T** ，异或门延迟为 **3T** ，先行进位方式总时间延迟为 **5T** 。这种 **先行进位（CLA）方式** 减少了进位信号经过的门电路级数，以硬件复杂度换取性能提升，但电路复杂度随位数 **n** 增加而增加，因此常用于 **n较小** 的情况 。
3. **分组应用实例（16位单级分组先行进位并行加法器）**：
    - **结构与原理**：16位二进制数分为4个小组，小组内部4个二进制位采用先行进位，小组之间采用串行进位，每组内最高位进位作为组间进位向上一组传递 。
    - **延迟计算**：**进位产生/传播部件**生成 **P<sub>0</sub>～P<sub>15</sub>及G<sub>0</sub>～G<sub>15</sub>** ，总延迟 **3T** ；**进位部件**组间串行进位总延迟 **2T×4 = 8T** ；**求和部件**通过 **P<sub>i</sub>** 和 **C<sub>i</sub>** 异或求结果，总延迟 **3T** 。该加法器总延迟时间（含溢出判断）为 **3T+4×2T+3T = 14T** ，相比串行进位16位加法器的 **9T+2×16T = 41T** ，速度大幅提升 。 
### 2.2.6 多级分组先行进位加法器
该节主要介绍**多级分组先行进位加法器**，具体内容如下：

1. **基本概念与原理**：当运算器位数较多时，采用**多级分组先行进位方式** ，将若干小组编成一大组，小组内采用先行进位，同一大组内各小组之间也可采用先行进位；加法器有一个或多个大组，多个大组间可采用串行进位或并行进位 。为实现组间进位并行化，需改造小组间进位链，把每个小组向高一小组的进位分为**本组进位**和**组间传送进位** 。本组进位只与本组内二进制位有关，组间传送进位负责将低有效小组进位传递至高有效小组。以第0小组向高一小组的进位C4为例，通过公式拆解展示了本组进位、组间进位传递函数和组间传送进位的构成 。
2. **组间先行进位逻辑公式**：按照上述方法，可写出更高小组的组间进位输出表达式，代入低有效小组进位输出，得到**组间先行进位逻辑（BCLA）公式**，以16位加法器分为4个小组为例，给出了C4、C8、C12、C16等组间进位输出的计算公式 。
3. **两级分组16位先行进位加法器实例**：以**两级分组16位先行进位加法器**为例，16位加法器分为4个小组构成一个大组，每个小组4位，小组内和各小组之间均采用先行进位 。4位并行加法器包含进位产生/传播部件、组内先行进位逻辑CLA和求和部件 。为支持组间先行进位，将4位CLA输出的C4改为*3P和*3G 。各小组输出P*和G*后，组间先行进位逻辑经一定延迟输出C4、C8、C12、C16等进位信号，随后4个4位并行加法器并行输出求和结果 。
4. **其他并行进位加法器介绍**：除先行进位加法器外，还提及**“进位选择加法器”** ，其同样通过提升硬件复杂度换取运算速度，原理是高有效位采用两套电路分别对进位输入0和1同时计算，低有效位进位输出产生后，用于选择两套电路之一的输出作为最终结果，并留下设计电路的思考题 。 
## 2.3 定点乘法运算
该节围绕**定点乘法运算**展开，详细介绍了实现乘除法运算的方法、人工算法与机器算法的异同，以及无符号数和带符号数阵列乘法器，具体内容如下：

1. **乘除法运算实现方法**：在计算机中，实现乘除法运算一般有三种方法。
    - **完全软件实现**：简单处理器内部不设乘除法硬件电路，通过软件利用加法器和移位寄存器编程实现，成本低、电路简单，但速度慢，常用于偶尔需乘除运算的廉价系统。
    - **利用加法器加硬件辅助电路实现**：在加法器和移位寄存器基础上，设计扩展电路，通过加法和移位操作实现乘除法运算。
    - **专用乘除法器实现**：运算器中增设高速乘除法部件直接完成运算，速度最快，目前高性能处理器大多采用此方法。
2. **人工算法与机器算法**
    - **运算规则**：定点计算机中，两个原码表示的数相乘，**乘积的符号位由两数符号位异或得到，数值部分是两个正数相乘之积**。
    - **差异与改进**：人工算法对机器不完全适用，因机器字长有限，乘积可能超出表示范围，且加法器难以一次性完成多个位积相加。早期采用串行1位乘法（多次“加法 - 移位”），但速度慢；现在多采用高速的并行乘法器。
3. **无符号数阵列乘法器**
    - **原理**：两个无符号二进制整数相乘，产生的乘积位数为两数位数之和。其乘法过程与人工算法相似，通过“与”门并行产生被加数矩阵，关键在于缩短每列1的加法时间。
    - **实例**：以5位×5位无符号数阵列乘法器为例，由全加器和与门构成，其总的乘法时间与门和全加器的传输延迟时间有关，为\((8n - 4)T\) 。
4. **带符号数阵列乘法器**
    - **原码乘法**：将被乘数与乘数的符号位异或得到乘积符号位，绝对值通过无符号数阵列乘法器运算，组合后得到乘积原码。
    - **补码乘法**：
        - **求补电路**：介绍了具有使能控制端的二进制对2求补器电路，可将带符号数转换为补码形式，总时间延迟为\((2n + 5)T\) 。
        - **间接补码阵列乘法器**：通过三个求补器（两个算前求补器、一个算后求补器），实现负数操作数转换为绝对值参与运算，并在必要时将乘积绝对值转换为补码。该乘法器既适用于原码乘法，也适用于间接补码乘法，但间接补码乘法时间约为原码乘法的2倍 。 
## 2.4 定点除法运算
### 2.4.1 原码除法算法原理
该节围绕**原码除法算法原理**展开，介绍了原码除法中符号位和数值部分的运算方法、机器运算与手算的差异，以及恢复余数法和不恢复余数法（加减交替法），具体内容如下：

1. **原码除法的基本规则**：
    - **符号位运算**：两个原码表示的数相除，**商的符号由两数符号按位相加（模2求和，即异或运算）求得**，如商的符号运算\(q_f = x_f \oplus y_f\) 。
    - **数值部分运算**：商的数值部分由两数的数值部分相除求得，**实质上是两个正数求商的运算** 。以被除数\(x = 0.1001\)，除数\(y = 0.1011\)为例，手算过程包括判断\(x\)与\(y\)大小，然后逐位比较余数与相应倍数的\(y\)，确定每一位商。
2. **机器运算与手算的差异**：
    - **判断方式**：计算机中，**机器不能心算，需先做减法判断是否够减** 。令\(r = |x| - |y|\) ，若\(r \geq 0\) 则够减，若\(r < 0\) 则不够减。减法运算可通过补码运算实现，即减\([|y|]\)操作变为加\([-|y|]_{补}\)操作。判断\([[x]_{原} + [-|y|]_{补}]\)的求和结果是否大于等于\(0\)，可根据结果符号位或运算时最高位是否有进位判断（**最高位无进位时结果为负，最高位有进位时结果为正**）。
    - **操作方法**：**机器运算不保留每一步结果，不够减时需恢复余数** 。
3. **恢复余数法**：一种恢复余数的方法是将当前减法获得的**余数加上除数**，但**恢复余数次数取决于商取值，操作步数不固定** 。
4. **不恢复余数法（加减交替法）**：
    - **操作规则**：够减时，下一步进行“部分余数左移减除数操作”；不够减时，将恢复余数操作与下一步的“部分余数左移减除数操作”合并为“部分余数左移加余数操作” 。
    - **运算推导**：设某一步操作\(r_i' = 2r_{i - 1} - y\) ，当\(r_i' \geq 0\) 时，\(r_i = r_i'\) ，下一步仍进行\(r_i'\)左移减除数操作；当\(r_i' < 0\) 时，下一步直接进行\(r_i'\)左移加除数操作。
    - **纠余操作**：**除法运算的余数必须与被除数同号，若最终余数为负数，需进行“纠余”操作，即\(r_n = r_n' + y\)** 。
5. **早期硬件除法器方案**：早期计算机采用**串行的1位除法方案（多次执行“减法-移位”操作，用计数器控制移位次数）** ，但因速度太慢已被淘汰 。 
### 2.4.2 并行除法器
该节围绕**并行除法器中的加减交替阵列除法器**展开，介绍了其组成单元、工作原理、结构特点、运算过程及运算时间，具体内容如下：

1. **可控加法/减法（CAS）单元**：
    - **功能与特性**：**CAS单元**是加减交替阵列除法器的基础组成部分，其有四个输出端和四个输入端 。**通过输入线P控制运算类型**，当**P = 0**时，进行加法运算；当**P = 1**时，进行减法运算。
    - **逻辑方程与运算规则**：输入与输出关系可用逻辑方程表示，当**P = 0**时，等同于一位全加器公式；当**P = 1**时，得到求差公式。减法运算中，**Ci**为借位输入，**Ci+1**为借位输出。将逻辑方程变换后，每个CAS单元可用三级组合逻辑电路（含反相器）实现，**延迟时间为3T单位**。
2. **加减交替的阵列除法器**：
    - **基本假设与运算规则**：假定处理的数均为正小数。在加减交替的除法阵列中，**每一行的运算类型取决于前一行输出的符号与被除数的符号是否一致** 。不够减时，部分余数符号改变，产生商位“0”，除数沿对角线右移后加到下一行部分余数上；部分余数符号不变时，产生商位“1”，下一行进行减法操作。
    - **结构与数据输入输出**：以4位除4位的加减交替阵列除法器为例，其由可控加法/减法（CAS）单元组成流水阵列。推广到一般情况，一个**(n + 1)位÷(n + 1)位的加减交替除法阵列由(n + 1)²个CAS单元组成** 。被除数x为双倍长数值，由顶部一行和最右边对角线垂直输入线提供；除数y沿对角线方向进入阵列；商q在阵列左边产生；余数r在阵列最下一行产生。
    - **运算过程与时间**：最上面一行初始操作固定为减法（控制线P置为“1”），减法通过2的补码运算实现。每一行最左边单元的进位输出决定商值，该商反馈到下一行确定下一行操作。运算时每行存在进位（或借位）传播，且所有行在进位链上串行连接 。对于一个**2n位除以n位的加减交替阵列除法器**，在最大信号延迟情况下，**除法执行时间td = 3(n + 1)²T** 。
3. **实例计算**：通过【例2.25】，以**x = 0.10110，y = 0.11111**为例，模拟计算机用原码加减交替法计算x/y的过程，给出了被除数、除数、商和余数的计算过程及结果 。 
## 2.5 定点运算器的组成
### 2.5.1 逻辑运算
该节围绕**计算机中的逻辑运算**展开，主要介绍了逻辑运算的概念、用途及四种基本逻辑运算，具体内容如下：

1. **逻辑运算的概念与用途**：**逻辑运算**是计算机在非数值应用领域的重要操作，可对**无符号二进制数（逻辑数）**进行运算 。其用途广泛，如用于**两个数的比较**、**从某个数中选取某几位**，在**过程控制中判断开关量状态**等 。
2. **四种基本逻辑运算**：
    - **逻辑非运算**：也称**求反**，对逻辑数按位取反，用变量上方加一横表示。例如，若\(x = x_0x_1x_2…x_n\)，则\(\overline{x} = z = z_0z_1z_2…z_n\)，其中\(z_i = \overline{x_i}\) 。以\(x_1 = 01001011\)为例，\(\overline{x_1}=10110100\)。
    - **逻辑加运算**：即按位求“或”，又称**逻辑或**，用“+”表示。若\(x = x_0x_1x_2…x_n\)，\(y = y_0y_1y_2…y_n\)，\(x + y = z = z_0z_1z_2…z_n\)，则\(z_i = x_i + y_i\) 。如\(x = 10100001\)，\(y = 10011011\)，\(x + y = 10111011\) 。
    - **逻辑乘运算**：按位求“与”，又称**逻辑与**，用“·”表示。对于\(x = x_0x_1x_2…x_n\)，\(y = y_0y_1y_2…y_n\)，\(x·y = z = z_0z_1z_2…z_n\)，有\(z_i = x_i·y_i\) 。例如\(x = 10111001\)，\(y = 11110011\)，\(x·y = 10110001\) 。 
    - **逻辑异运算**：按位求模2和，又称**按位加**，用“”表示。若\(x = x_0x_1x_2…x_n\)，\(y = y_0y_1y_2…y_n\)，\(xy = z = z_0z_1z_2…z_n\)，则\(z_i = x_iy_i\) 。如\(x = 10101011\)，\(y = 11001100\)，\(xy = 01100111\) 。 
### 2.5.2 多功能算术/逻辑运算单元
该节围绕**多功能算术/逻辑运算单元（ALU）**展开，从基本思想、逻辑表达式、运算实现、两级先行进位等方面进行了介绍，具体内容如下：

1. **基本思想**：为实现多种算术/逻辑运算，不直接对输入\(A_i\)、\(B_i\)和进位输入\(C_i\)进行全加，而是先将\(A_i\)和\(B_i\)组合成由**控制参数\(S_0\)、\(S_1\)、\(S_2\)、\(S_3\)控制的组合函数\(X_i\)和\(Y_i\)** ，再将其与进位输入通过全加器进行全加，不同控制参数组合可实现多种运算。一位算术/逻辑运算单元逻辑表达式为\(F_i=X_i\oplus Y_i\oplus C_{n + i}\)、\(C_{n + i + 1}=X_iY_i + Y_iC_{n + i}+C_{n + i}X_i\) ，其中\(n\)和\(i\)分别代表不同意义的进位和位数标识。
2. **逻辑表达式**：控制参数\(S_0\)、\(S_1\)控制产生\(Y_i\)，\(S_2\)、\(S_3\)控制产生\(X_i\) ，并给出具体函数关系表。由此列出\(X_i\)和\(Y_i\)逻辑表达式，化简后代入得到ALU某一位逻辑表达式。4位之间采用先行进位公式，通过递推得到进位公式，设\(G\)和\(P\)后，得到最终进位公式\(C_{n + 4}=G + PC_n\) ，表明ALU具有先行进位逻辑，可实现高速运算。同时给出了用正逻辑表示的4位ALU（74181ALU）逻辑电路图。
3. **算术逻辑运算的实现**：控制端**\(M\)用于控制ALU进行算术或逻辑运算** 。当\(M = 0\)时，进行算术操作，\(F_i\)与本位操作数及进位值有关；当\(M = 1\)时，封锁进位输出，进行逻辑操作，\(F_i\)仅与本位操作数有关 。74181ALU有正逻辑和负逻辑两种工作方式，\(S_0～S_3\)的16种状态组合使正、负逻辑输入输出各有16种算术和逻辑运算功能。此外，还说明了算术运算中补码表示、减法实现方式及“A=B”输出端的作用。 
4. **两级先行进位的ALU**：74181ALU的\(P\)和\(G\)输出端送入74182先行进位部件（CLA）可实现第二级先行进位，即组与组之间的先行进位。给出了4片74181的先行进位输出与74182CLA的进位逻辑关系表达式，以及成组进位发生输出\(G^*\)和成组进位传送输出\(P^*\) 。最后介绍了用74181ALU位片与74182CLA构成全字长ALU的方式，如用两个16位全先行进位部件级联组成32位ALU，可缩短全字长ALU的运算时间。 
### 2.5.3 内部总线
该节围绕**内部总线**展开，主要介绍了内部总线的定义、分类以及双向数据总线的具体情况，具体内容如下：

1. **内部总线的定义与作用**：
    - **定义背景**：由于计算机内部主要工作是信息传送和加工，各部件间数据传送频繁，为**减少内部数据传送线并便于控制**，将寄存器间数据传送通路归并，组成**总线结构**，使不同来源信息在传输线上**分时传送**。
    - **分类**：根据总线所处位置，总线分为**内部总线**和**外部总线**，**内部总线是指CPU内各部件的连线**，而外部总线是指系统总线，即CPU与存储器、I/O系统之间的连线，该节仅讨论内部总线。
2. **内部总线的逻辑结构分类**：按总线的逻辑结构，总线可分为**单向传送总线**和**双向传送总线**。**单向总线**信息只能向一个方向传送；**双向总线**信息可以向两个方向传送，既能发送数据，也能接收数据 。
3. **4位双向数据总线介绍**：以**图2.15带有缓冲驱动器的4位双向数据总线**为例，其所用基本电路是**三态逻辑电路** 。当“发送”信号有效时，数据从左向右传送；当“接收”信号有效时，数据从右向左传送 。这种类型的缓冲器根据使用情况，常被称为总线扩展器、总线驱动器、总线接收器等 。 
### 2.5.4 定点运算器的基本结构
该节围绕**定点运算器的基本结构**展开，介绍了运算器的组成部分、设计要点，以及三种不同结构形式运算器的特点，具体内容如下：

1. **运算器的组成与设计要点**：
    - **组成部分**：运算器由 **ALU、阵列乘除器、寄存器、多路开关、三态缓冲器、数据总线** 等逻辑部件构成。
    - **设计核心**：运算器的设计主要围绕 **ALU 和寄存器同数据总线之间** 如何传送操作数和运算结果进行，设计时需考虑 **数据传送的方便性、操作速度** ，在微型机和单片机中还需考虑 **硅片上制作总线的工艺** 。
2. **运算器的三种结构形式**：
    - **单总线结构的运算器**：所有部件都连接到 **同一总线** ，数据可在寄存器之间或寄存器与ALU之间传送。因同一时间单总线上只能有一个操作数，执行加法等操作时，两个操作数需 **分两次输入到ALU** ，并需 **A、B两个缓冲寄存器** ，数据和结果需三次串行选通操作， **操作速度较慢** ，但 **控制电路简单** 。不过，当操作数涉及存储器访问时，其速度受存储器访问时间限制，只有对CPU寄存器中的操作数操作时才会有明显时间损失 。
    - **双总线结构的运算器**：具备 **两条总线** ，两个操作数可 **同时加到ALU进行运算** ，一次操作控制就能得到结果。专用寄存器分为两组与不同总线交换数据，数据传送更灵活。但ALU输出不能直接连总线，需设置缓冲寄存器，操作控制分两步：先输入操作数得到结果并存入缓冲寄存器，再将结果送入目的寄存器。若在总线与ALU输入端加输入缓冲寄存器，ALU输出可直接送至总线 。
    - **三总线结构的运算器**：ALU的两个输入端由 **两条总线供给** ，输出与 **第三条总线相连** ，算术逻辑操作 **一步控制即可完成** ，操作速度快。由于ALU存在时间延迟，输出结果的选通脉冲需考虑该延迟。还设置了 **总线旁路器** ，不需要修改的操作数可直接传送，需要修改的则借助ALU 。 
## 2.6 浮点运算方法和浮点运算器
### 2.6.1 浮点加法、减法运算
该节围绕**浮点加法、减法运算**展开，详细介绍了运算规则、操作过程、舍入处理、溢出处理、运算电路硬件框图，以及具体运算实例，具体内容如下：

1. **运算规则**：对于浮点数\(x = 2^{E_x}·M_x\)和\(y = 2^{E_y}·M_y\)，其加减运算规则为\(z = x±y = (M_x2^{E_x－E_y}±M_y)2^{E_y}\) （\(E_x≤E_y\)）。
2. **操作过程**：
    - **0操作数检查**：若操作数\(x\)或\(y\)中有一个为\(0\)，可直接得出运算结果，避免后续复杂操作，节省时间。
    - **比较阶码大小并完成对阶**：先求阶码差\(\Delta E = E_x - E_y\)，根据\(\Delta E\)判断阶码关系。当\(E_x≠E_y\)时，**小阶向大阶看齐**，即小阶的尾数右移，每右移一位阶码加\(1\)，直到两数阶码相等，右移位数等于阶差\(\Delta E\) 。当阶码用移码表示时，移码加减运算常混合使用移码和补码，如移码加法公式为\([E_x]_{移}+[E_y]_{补}=[E_x + E_y]_{移}\pmod{2^n}\) ，并通过双符号位阶码加法器判定运算溢出 。
    - **尾数加减运算**：对阶后，尾数按定点加减运算方法进行加法操作 。
    - **结果规格化**：若尾数求和结果出现\(01. x…x\)或\(10. x…x\)的形式，需向右规格化，即尾数右移\(1\)位，阶码加\(1\)；对于IEEE754表示形式，当尾数不是\(1.M\)时须向左规格化。
    - **舍入处理**：在对阶或向右规格化时，尾数右移会丢失低位部分，需进行舍入处理。IEEE754标准提供**就近舍入、朝0舍入、朝+∞舍入、朝–∞舍入**四种方法 。
    - **溢出处理**：浮点数溢出以阶码溢出体现，分为**阶码上溢（认为是+∞和–∞）、阶码下溢（认为是0）、尾数上溢（尾数右移，阶码增1重新对齐）、尾数下溢（进行舍入处理）** 。
3. **运算电路硬件框图**：两个加数的指数部分通过ALU1相减，判断指数大小和差值，该差值控制多路开关挑选较大指数、较小加数和较大加数的有效数位；较小加数有效数位右移后，在ALU2中与另一加数有效数位相加；结果进行规格化（通过移位操作并相应调整指数）、舍入，舍入后可能需再次规格化得到最终结果 。
4. **运算实例**：通过**【例2.30】** ，以二进制形式计算\(x = (0.5)_{10}\)与\(y = –(0.4375)_{10}\)的和，经过对阶、尾数相加、规格化、检查溢出、舍入操作得到最终结果；通过**【例2.31】** ，以十进制形式计算\(x = 10^{2}×0.3\)与\(y = 10^{3}×0.2\)的和与差，展示浮点加减法运算中小数点对齐的概念 。 
### 2.6.2 浮点乘法、除法运算
该节围绕**浮点乘法、除法运算**展开，主要介绍了运算规则、运算步骤、尾数处理方法及具体运算实例，具体内容如下：

1. **浮点乘法、除法运算规则**：
    - **乘法规则**：对于两个浮点数\(x = 2^{E_x}·M_x\)和\(y = 2^{E_y}·M_y\)，乘法运算规则为\(x×y = 2^{(E_x + E_y)}·(M_x×M_y)\) ，即**乘积的尾数是两数尾数之积，阶码是两数阶码之和** ，后续还需进行规格化与舍入等操作。
    - **除法规则**：浮点除法运算规则为\(x÷y = 2^{(E_x - E_y)}·(M_x÷M_y)\) ，**商的尾数是两数尾数之商，阶码是两数阶码之差** ，同样需进行规格化和舍入。**浮点乘除法不存在对阶问题，相对浮点加减法更简单** 。
2. **浮点乘、除法运算步骤**：浮点数的乘除运算大体分为六步：
    - **0操作数检查**：若被除数\(x\)为\(0\)，则商为\(0\)；若除数\(y\)为\(0\)，则商为\(\infty\) 。
    - **阶码加/减操作**：乘法是两阶码求和，除法是两阶码求差，运算时需检查结果是否溢出。
    - **尾数乘/除操作**：进行尾数的乘法或除法运算。
    - **结果规格化**：对运算结果进行规格化处理。
    - **舍入处理**：处理尾数运算中因截断等产生的精度问题。
    - **确定积的符号**：根据乘数和被乘数的符号确定积的符号。
3. **尾数处理方法**：
    - **截断处理**：无条件丢掉正常尾数最低位之后的全部数值，处理简单但影响精度。
    - **舍入处理**：保留右移中移出的若干高位的值，再按规则修正尾数 。当尾数用原码表示时，舍入规则包括：只要尾数最低位为\(1\)，或移出的几位中有为\(1\)的数值位，就使最低位的值为\(1\)；或采用**0舍1入法**，即当丢失的最高位的值为\(1\)时，把这个\(1\)加到最低数值位上进行修正。
4. **运算实例**：
    - **【例2.32】**：以二进制形式计算\(x = (0.5)_{10}\)与\(y = –(0.4375)_{10}\)的乘积，经阶码相加、尾数相乘、规格化与溢出检查、舍入及确定符号，得到\((x×y)_{浮}= –(1.110)_2×2^{–3}\) ，并通过十进制浮点数验证结果。
    - **【例2.33】**：以基数\(R = 10\)为例，计算\(x = 10^2×0.4\)与\(y = 10^3×0.2\)的乘积与商，分别得出\(x×y = 8000\)，\(x÷y = 0.2\) 。 