# 第四章：指令系统
## 4.1 指令系统的发展与性能要求
### 4.1.1 指令系统的发展
该节主要围绕计算机**指令系统的发展**展开，介绍了指令的分类、指令系统的定义、指令系统在不同时期的发展历程及特点，具体如下：

1. **指令的分类与指令系统的定义**：计算机指令分为**微指令、机器指令和宏指令**。**微指令**属于硬件，是微程序级命令；**宏指令**由若干机器指令组成，属于软件；**机器指令**介于两者之间，简称指令，可完成独立算术或逻辑运算操作，本章讨论的指令即机器指令。一台计算机中所有机器指令的集合称为**指令系统（指令集）**，它是表征计算机性能的重要因素，其格式与功能影响硬件结构和系统软件，是计算机硬件与底层软件的接口。
2. **指令系统的发展历程**
    - **20世纪50年代**：受器件限制，计算机硬件结构简单，指令系统仅有定点加减、逻辑运算、数据传送、转移等**几十条指令** 。
    - **20世纪60年代后期**：随着集成电路出现，硬件功能增强，指令系统更加丰富，新增乘除运算、浮点运算、十进制运算、字符串处理等指令，指令数目多达**一二百条**，寻址方式也趋于多样化。同时，出现**系列计算机**，即基本指令系统和体系结构相同的一系列计算机，系列机解决了软件兼容问题，新机种指令系统包含旧机种全部指令，使旧机种软件可在新机种上直接运行，减少软件开发费用。
    - **20世纪70年代末期**：随着VLSI技术发展，计算机硬件结构复杂化，多数计算机指令系统多达**几百条**，这类计算机被称为**复杂指令系统计算机（CISC）**。但庞大指令系统导致研制周期变长，存在硬件资源浪费，出现“20∶80规律”，即20%的简单指令在程序中出现频率占80%。因此，人们提出**精简指令系统计算机（RISC）**，以适应VLSI技术实现 。 
### 4.1.2 指令系统的性能要求
该节围绕**指令系统的性能要求**展开，强调指令系统设计在计算机系统设计中的**核心地位**，其性能影响计算机基本功能、硬件结构及用户使用需求。一个完善的指令系统需满足四方面要求：

1. **完备性**：指用汇编语言编写各类程序时，指令系统直接提供的指令足够，无需借助软件实现。要求指令系统丰富、功能全、使用便捷。虽然计算机最基本指令有限，部分指令如乘除、浮点运算指令既可用硬件实现，也能用基本指令编程实现，但采用硬件指令可**提高程序执行速度**，方便用户编程 。
2. **有效性**：即利用指令系统编写的程序能**高效运行**，体现在程序**存储空间小**、**执行速度快**。通常，功能更强大、完善的指令系统有效性更佳。
3. **规整性**：涵盖指令系统的**对称性、匀齐性**以及**指令格式和数据格式的一致性** 。
    - **对称性**：指令系统中所有寄存器和存储器单元同等对待，所有指令均可使用各种寻址方式。
    - **匀齐性**：一种操作性质的指令能支持多种数据类型，如算术运算指令可支持字节、字、双字整数运算，十进制数运算以及单、双精度浮点数运算等。
    - **一致性**：指令长度和数据长度存在一定关系，通常为字节长度的整数倍，便于处理和存取 。
4. **兼容性**：系列机各机种具有相同基本结构和基本指令系统，实现指令系统兼容，即各机种基本软件通用。但因推出时间不同，结构和性能有差异，只能做到**“向上兼容”**，即低档机软件可在高档机上运行 。 
### 4.1.3 低级语言与硬件结构的关系
该节内容主要围绕**低级语言与硬件结构的关系**展开，介绍了计算机语言的分类、低级语言与高级语言的特点及性能比较，以及低级语言与硬件结构的紧密联系，具体如下：

1. **计算机语言分类**：计算机语言分为**高级语言**和**低级语言**。高级语言如C、FORTRAN等，其语句和用法**与具体机器的指令系统无关**；低级语言包括**机器语言（二进制语言）**和**汇编语言（符号语言）**，这两种语言**面向机器**，与具体机器的指令系统**密切相关**，其中机器语言用指令代码编写程序，汇编语言用指令助记符编写程序 。
2. **语言转换需求**：计算机**唯一能直接识别和执行的语言是二进制机器语言**，但直接使用它编写程序不方便。而使用符号语言或高级语言编写程序虽对人方便，但机器无法识别，因此需要借助**汇编器（汇编程序）或编译器（编译程序）**，将其翻译成机器语言。
3. **高级语言与低级语言性能比较**：通过表格从六个方面对高级语言和低级语言进行比较。在**对程序员的训练要求**上，高级语言需要通用算法知识，语言规则要求较少，无需硬件知识；低级语言同样需要通用算法知识，但语言规则要求较多，且需要掌握硬件知识。在**对机器独立的程度**上，高级语言独立于机器，低级语言则不独立。**编制程序的难易程度**方面，高级语言易，低级语言难；**编制程序所需时间**上，高级语言短，低级语言较长；**程序执行时间**上，高级语言较长，低级语言短；**编译过程中对计算机资源（时间和存储容量）的要求**，高级语言多，低级语言少。
4. **低级语言与硬件结构的关系**：**汇编语言依赖于计算机的硬件结构和指令系统**，不同机器指令不同，所以汇编语言编写的程序**不能在其他类型机器上运行**。高级语言与硬件结构及指令系统无关，编写程序更具优势，但无法直接编写访问硬件资源的软件。为解决这一问题，一些高级语言（如C、FORTRAN等）**提供与汇编语言的调用接口**，汇编语言程序可作为高级语言的外部过程或函数，通过堆栈传递参数，两者源程序经编译或汇编生成目标文件后，用连接程序连接成可执行文件运行。
5. **指令系统体系结构（ISA）**：**机器语言程序员看到的计算机属性即指令系统体系结构ISA**，它与程序设计相关，主要包括**寄存器组织、存储器的组织和寻址方式、I/O系统结构、数据类型及其表示、指令系统、中断机制、机器工作状态的定义及切换，以及保护机制等**。 
## 4.2 指令格式
该节围绕**指令格式**展开，介绍了指令字、指令格式的定义及组成部分，具体内容如下：

1. **指令字定义**：**机器指令**由机器字表示，**表示一条指令的机器字称为指令字**，通常简称为指令。
2. **指令格式定义与组成**：**指令格式**是指令字以二进制代码表示的结构形式，**主要由操作码字段和地址码字段组成**。其中，**操作码字段（OP）**用于表征指令的操作特性与功能，不同的操作码对应不同的操作（如加法、减法、存储等）；**地址码字段（A）**通常用于指定参与操作的操作数的地址 ，根据具体指令需求，地址码可以指向主存单元、寄存器，或者用于指定操作数本身等。通过操作码与地址码的组合，指令能够明确告知计算机要执行何种操作以及操作对象的位置。 
### 4.2.1 操作码
该节主要介绍了指令系统中**操作码**的相关内容，具体如下：

1. **操作码的规定与作用**：在计算机设计时，需为指令系统的**每一条指令**规定一个操作码。**操作码OP**用于**表示指令的操作性质**，例如加法、减法、乘法等不同操作。不同指令通过操作码字段的**不同编码**区分，每种编码对应一种指令，如操作码001规定为加法操作，010为减法操作，110为取数操作等。CPU中的专门电路可解释操作码，使机器执行相应操作 。
2. **操作码位数的确定**：操作码字段的**位数**取决于**计算机指令系统的规模**。指令系统规模越大，所需位数越多。一般来说，**n位操作码最多能表示2ⁿ条指令** 。例如，8条指令的指令系统只需3位操作码（2³ = 8），32条指令则需要5位操作码（2⁵ = 32）。
3. **操作码与地址码字段长度**：在多数机器的指令系统中，指令字里**操作码字段和地址码字段长度固定**。但在**单片机**中，因指令字较短，为充分利用指令字长度，二者字段**长度不固定**，不同类型指令有不同划分方式，这样既能用较短指令字长表示更多操作种类，也有助于在更大存储空间中寻址 。 
### 4.2.2 地址码
该节主要围绕**指令系统中的地址码**展开，介绍了根据操作数地址数量划分的指令类型，以及二地址指令格式下操作数的物理位置类型，具体内容如下：

1. **指令按操作数地址数量分类**：根据指令中操作数地址的数量，可将指令分为几操作数指令或几地址指令。操作数一般有被操作数、操作数及操作结果三种，早期计算机指令基本格式为三地址指令格式，后在此基础上发展出二地址、一地址和零地址格式。
    - **零地址指令**：指令字中只有**操作码**，无**地址码**，如停机指令，因其操作不需要操作数。
    - **一地址指令**：只有一个地址码，指定一个操作数，另一个操作数地址隐含（常为运算器中累加寄存器AC中的数据），操作结果放回累加寄存器AC并覆盖原数据，数学含义为**AC←(AC)OP(A)** ，地址码字段A指明的是操作数地址而非操作数本身。
    - **二地址指令**：又称双操作数指令，有两个地址码字段A1和A2，指明参与操作的两个数的地址，A1兼作存放操作结果的地址，数学含义为**A1←(A1)OP(A2)** 。
    - **三地址指令**：指令字中有三个操作数地址A1、A2和A3，A1为被操作数地址（源操作数地址），A2为操作数地址（终点操作数地址），A3为存放操作结果的地址，数学含义为**A3←(A1)OP(A2)** ，A1、A2、A3通常指定为运算器中通用寄存器的地址以加快指令执行速度。
2. **二地址指令格式下操作数的物理位置类型**
    - **存储器-存储器(SS)型指令**：访问内存的指令格式，操作数都在内存中，取操作数和存放操作结果都在内存单元，机器执行需多次访问内存。
    - **寄存器-寄存器(RR)型指令**：访问寄存器的指令格式，执行时需多个通用寄存器或个别专用寄存器，从寄存器取操作数，操作结果放另一寄存器，执行速度快，无需访问内存。
    - **寄存器-存储器(RS)型指令**：执行时既要访问内存单元又要访问寄存器。
3. **CISC计算机的指令特点**：在**CISC计算机**中，指令系统中指令字的长度和地址结构不单一，常采用多种格式混合使用，以增强指令功能 。 
### 4.2.3 指令字长度
该节主要围绕**指令字长度**展开，介绍了其定义、与机器字长的关系、不同指令字长度的特点、指令字结构类型以及扩展操作码技术，具体内容如下：

1. **指令字长度的定义**：一个指令字中包含二进制代码的位数，称为**指令字长度**。**机器字长**是指计算机能直接处理的二进制数据的位数，决定了计算机的运算精度，通常与主存单元的位数一致。
2. **指令字长度与机器字长的关系**：指令字长度等于机器字长度的指令，称为**单字长指令**；指令字长度等于半个机器字长度的指令，称为**半字长指令**；指令字长度等于两个机器字长度的指令，称为**双字长指令**。例如，IBM370系列有16位（半字）、32位（单字）、48位（一个半字）的指令格式；英特尔IA-32系列机指令格式可变，有8位、16位、32位、64位不等。
3. **多字长指令的优缺点**：早期计算机使用多字长指令是为了提供足够的地址位来解决访问内存任何单元的寻址问题。但缺点是必须两次或三次访问内存以取出一整条指令，**降低了CPU的运算速度**，同时**占用了更多的存储空间**。
4. **指令字结构类型**
    - **等长指令字结构**：在一个指令系统中，如果各种指令字长度是相等的，称为**等长指令字结构**，它们可以都是单字长指令或半字长指令。这种指令字结构**简单**，且指令字长度是不变的。
    - **变长指令字结构**：如果各种指令字长度随指令功能而异，如有的指令是单字长指令，有的指令是双字长指令，就称为**变长指令字结构**。这种指令字结构**灵活**，能充分利用指令长度，但指令的控制**较复杂**。随着技术发展，指令字长度逐渐变成多于32位的固定长度。
5. **扩展操作码技术**：以某等长指令字结构机器（指令长度为16位，包括4位基本操作码字段和三个4位地址字段）为例，介绍了扩展操作码技术。当4位基本操作码若全部用于三地址指令，只能安排16种三地址指令。为确保指令字长度尽可能统一，采用扩展操作码技术，向地址码字段扩展操作码的长度：
    - 三地址指令的操作码占用4位基本操作码编码空间的0000～1110共15种组合，剩下1111用于把操作码扩展到A1地址域，从4位操作码扩展到8位。
    - 二地址指令的操作码占用8位操作码编码空间的1111, 0000～1111, 1101共14种，剩下两个编码用于把操作码扩展到A2地址域，从8位操作码扩展到12位。
    - 一地址指令的操作码占用12位操作码编码空间的1111, 1110, 0000～1111, 1111, 1110共31种编码，剩下一个编码用于把操作码扩展到A3地址域，从12位操作码扩展到16位。
    - 零地址指令的操作码占用16位操作码编码空间的1111,1111,1111,0000～1111,1111,1111, 1111共16种编码 。 
### 4.2.4 指令助记符
该节主要围绕**指令助记符**展开，介绍了其产生原因、表示形式、作用、不同计算机的差异以及转换方式，具体内容如下：

1. **指令助记符的产生原因**：因为硬件只能识别**1和0组成的二进制**，使用二进制书写程序很麻烦，为便于书写和阅读程序，所以产生了指令助记符。
2. **指令助记符的表示形式**：每条指令通常用**3个或4个英文缩写字母**来表示，这种缩写码就称为指令助记符。例如，在假定指令系统只有7条指令的情况下，操作码只需3位二进制，加法指令的指令助记符为**ADD**，对应二进制操作码**001**；减法指令助记符是**SUB**，对应**010**；传送指令助记符为**MOV**，对应**011**等 。
3. **指令助记符的作用**：指令助记符提示了每条指令的意义，**容易记忆**，书写方便，**阅读程序时容易理解**，例如加法指令可用ADD代表操作码001，存数指令可用STO表示操作码110。
4. **不同计算机的指令助记符差异**：在**不同的计算机中**，指令助记符的规定是**不一样的**。
5. **指令助记符的转换方式**：由于硬件只能识别二进制语言，指令助记符必须转换成与之相对应的二进制操作码，这种转换可借助**汇编器**自动完成，汇编器的作用类似于一个“翻译” 。 
### 4.2.5 指令格式举例
该节为“指令格式举例”，主要介绍了不同计算机的指令格式特点，通过实例分析指令格式各字段含义与功能，具体内容如下：

1. **八位微型计算机的指令格式**：早期8位微型机**字长8位**，指令结构为**可变字长形式**，包含单字长、双字长、三字长等指令。**单字长指令**仅有操作码，无操作数地址；**双字长或三字长指令**包含操作码和地址码 。由于内存按字节编址，单字长指令执行后指令地址加1，双字长或三字长指令执行时需连续读取2字节或3字节代码，指令地址相应加2或3，**多字长指令格式不利于提高机器速度**。
2. **MIPS R4000指令格式**：MIPS R4000是20世纪80年代后期推出的**RISC系统**，**字长32位**，字节寻址。其指令格式简单，指令数量少，有32个通用寄存器。算术指令（**R型指令**）格式中包含**OP字段（操作码）、rs字段（第1个源操作数寄存器）、rt字段（第2个源操作数寄存器）、rd字段（存放操作结果的目的数寄存器）、shamt字段（移位值）、funct字段（函数码）**。访问存储器的**I型（立即数）指令**，其16位address字段提供取字或存字指令访问存储器的基值地址码。R型和I型格式部分字段长度和名称一致，通过**OP字段区分指令格式**。例如加法和减法指令OP字段值相同，依靠funct字段确定操作类型 。
3. **32位ARM指令系统的指令格式**：ARM是应用广泛的处理器架构，不同版本支持不同指令系统。32位ARM指令格式中，**opcode为操作码**，**Rd指明目标寄存器地址**，**Rn指明源寄存器地址**，**operand 2指明第2个源操作数**，**I用于指明立即数**，**S和cond涉及条件转移指令**，**F说明指令类型**。 
4. **英特尔IA-32指令格式**：英特尔IA-32机的**指令字长度可变（1B - 12B）**，为典型**CISC结构**。指令由**操作码字段、Mod - R/M字段、SIB字段、位移量字段、立即数字段组成**，后四个字段为可选字段。**Mod - R/M字段规定存储器操作数寻址方式、给出寄存器操作数地址号**；**SIB字段由比例系数S、变址寄存器号I、基址寄存器号B组成**，与Mod - R/M字段共同说明操作数来源 。Pentium采用RS型指令，指令格式中只有一个存储器操作数。
5. **指令格式分析实例**
    - **例4.2**：某16位机指令为**单字长二地址指令**，操作码字段OP可指定\(2^7 = 128\)条指令，源寄存器和目标寄存器均为通用寄存器（可指定16个），属于**RR型指令**，常用于算术逻辑运算类指令。
    - **例4.3**：某16位机指令为**双字长二地址指令**，用于访问存储器，操作码字段OP为6位，可指定\(2^6 = 64\)种操作，一个操作数在源寄存器（16个），另一个在存储器中（由变址寄存器和位移量决定），属于**RS型指令** 。 
## 4.3 指令和数据的寻址方式
### 4.3.1 指令的寻址方式
该节主要介绍了指令的两种寻址方式，即**顺序寻址方式**和**跳跃寻址方式**，具体内容如下：

1. **顺序寻址方式**：在内存中，指令地址是**按顺序排列**的。当执行一段程序时，通常按照**一条接一条**的顺序执行指令，即从存储器取出一条指令执行后，接着取出下一条指令继续执行，这种按顺序执行程序的过程，就是指令的顺序寻址方式。为了记录指令的顺序号（即指令在内存中的地址），需要使用**程序计数器（PC，又称指令指针寄存器）** 进行计数。
2. **跳跃寻址方式**：当程序需要**改变执行顺序**时，就会采用跳跃寻址方式。其特点是**下条指令的地址码不由程序计数器给出，而是由本条指令给出**。程序跳跃后，将按照新的指令地址开始顺序执行，此时**程序计数器的内容也必须相应改变**，以跟踪新的指令地址。采用跳跃寻址方式，能够实现程序转移或构成循环程序，有助于**缩短程序长度**，还可以将某些程序作为公共程序引用。指令系统中的**条件转移或无条件转移指令**，就是为实现指令的跳跃寻址而设置的。 
### 4.3.2 操作数基本寻址方式
该节主要围绕**操作数基本寻址方式**展开，介绍了操作数的来源、寻址方式的定义及多种具体寻址方式，具体内容如下：

1. **操作数来源与寻址方式定义**：指令执行时，操作数来源主要有三：指令地址码直接给出（固定不变）、CPU通用数据寄存器存放（数量有限）、内存数据区存放（最常用）。**形成操作数有效地址的方法即操作数寻址方式**。一般指令地址码并非操作数有效地址，需通过**形式地址**结合**寻址方式特征位（如间址位、变址位）**变换得到有效地址，寻址过程就是形式地址到有效地址的变换过程 。
2. **具体寻址方式**
    - **隐含寻址**：指令不明确给出操作数地址，而是隐含操作数地址，如英特尔IA - 32乘法指令“MUL opr”，被乘数隐含使用AX或AL寄存器 。
    - **立即寻址**：指令地址字段直接是操作数本身（即立即数），如英特尔IA - 32指令“MOV AL, 7”将7送入寄存器AL。优点是操作数立即可用，节省访存时间；缺点是操作数范围有限、灵活性差 。
    - **直接寻址**：指令地址字段直接为操作数在内存的地址A，形式地址A即有效地址EA，表达式为D=(A) ，简单但地址范围有限。
    - **间接寻址**：形式地址A是操作数地址的指示器，需结合寻址特征位I判断，I = 0为直接寻址（EA = A），I = 1为间接寻址（EA=(A)），因两次访存影响速度，现较少使用。
    - **寄存器寻址**：操作数存于CPU通用寄存器，指令给出寄存器编号（EA = R），指令短、执行快，如“MOV AL, 7”中目的操作数AL采用此方式 。
    - **寄存器间接寻址**：寄存器内容为操作数在内存的地址（EA=(R)），与寄存器寻址不同。
    - **偏移寻址**：结合直接寻址和寄存器间接寻址，有效地址EA=A+(R)，常用形式有：
        - **相对寻址**：隐含引用程序计数器(PC)，EA=A+(PC) ，可节省地址位数、便于程序搬动。
        - **基址寻址**：专用寄存器含存储器地址，地址字段为偏移量，利用存储局部性原理，段寻址实质是基址寻址 。
        - **变址寻址**：地址域为主存地址，专用寄存器含正偏移量，用于高效重复操作 。
    - **段寻址**：如英特尔IA - 32将1MB空间按64KB分段，通过段寄存器左移4位与16位偏移量相加形成20位物理地址 。
    - **堆栈寻址**：基于先进后出原理，有寄存器堆栈和存储器堆栈，通过堆栈指示器管理，PUSH指令数据进栈（指示器减1），POP指令数据退栈（指示器加1） 。
3. **寻址方式指定**：不同指令系统指定寻址方式的方法不同，有的指令固定某种寻址方式，有的允许多种，或通过指令寻址方式字段指明，或用不同操作码区分，也可组合成复合寻址方式。 
### 4.3.3 寻址方式举例
该节主要介绍了英特尔IA-32和Power PC的寻址方式，并通过实例进行说明，具体内容如下：

1. **英特尔IA-32的寻址方式**
    - **地址模式**：英特尔IA-32外部地址总线宽度36位，支持32位物理地址空间。在**实地址模式**下采用段寻址，将16位段寄存器内容左移4位补0得20位段基地址，再加上段内偏移得到20位物理地址；在**保护模式**下，32位段基地址加上段内偏移得到32位线性地址LA，由存储管理部件转换为32位物理地址，此过程对指令系统和程序员透明 。
    - **9种寻址方式**：
        - **立即寻址**：立即数为8位、16位或32位操作数，包含在指令中。
        - **寄存器寻址**：根据指令类型，可使用8位、16位或32位通用寄存器，对64位浮点数操作需用一对32位寄存器，部分指令也可用段寄存器实施该寻址方式。
        - **偏移量寻址**：也称直接寻址，偏移量即操作数距离段起点的位移，长度达32位，可用于访问全局，有效地址EA = A（A为偏移量）。
        - **基址寻址**：基址寄存器B可为任意通用寄存器，有效地址EA=(B)。
        - **基址+偏移量寻址**：基址寄存器B为32位通用寄存器之一，有效地址EA=(B)+A 。
        - **比例变址+偏移量寻址**：变址寄存器I为除ESP外的32位通用寄存器，可将其内容乘以1、2、4或8的比例因子S，再加上偏移量得到有效地址，即EA=(I)×S+A。
        - **基址+变址+偏移寻址**：是基址寻址和变址寻址的组合，偏移量可有可无，有效地址EA=(B)+(I)+A 。
        - **基址+比例变址+偏移量寻址**：同样是组合寻址方式，有效地址EA=(B)+(I)×S+A 。
        - **相对寻址**：适用于转移控制类指令，用当前指令指针寄存器EIP或IP内容（下一条指令地址）加上有符号偏移量，形成CS段的段内偏移，即指令地址=(PC)+A。
2. **Power PC寻址方式**：Power PC是RISC机器，其寻址方式按指令类型分类 ：
    - **取数/存数寻址**：包括间接寻址（EA=(BR)+D ，BR为基址寄存器，D为偏移量）和间接变址寻址（EA=(BR)+(IR) ，IR为变址寄存器）。
    - **转移寻址**：有绝对寻址（EA=I ，I为立即值）、相对寻址（EA=(PC)+I ）和间接寻址（EA=(L/CR) ，L/CR为链接或计数寄存器）。
    - **定点计算**：采用寄存器寻址（EA=GPR ，GPR为通用寄存器）和立即寻址（操作数=I）。
    - **浮点计算**：采用寄存器寻址（EA=FPR ，FPR为浮点寄存器）。
3. **寻址方式实例**：以一种二地址RS型指令结构为例，通过间接寻址标志位I、寻址模式字段X和偏移量字段D的组合，构成6种寻址方式，分别为直接寻址（E=D）、相对寻址（E=(PC)±D）、变址寻址（E=(R2)±D ，R2为变址寄存器）、寄存器间接寻址（E=(R3) ）、间接寻址（E=(D)）、基址寻址（E=(R1)±D ，R1为基址寄存器）。 
## 4.4 典型指令
### 4.4.1 指令的分类
该节围绕**指令的分类**展开，指出不同机器指令系统各异，较完善的指令系统包含数据处理、存储、传送、程序控制四大类指令，具体如下：

1. **数据传送指令**：涵盖取数、存数、成组传送等指令，**主要用于实现主存与寄存器之间、寄存器与寄存器之间的数据传送**，如寄存器内容存至主存、寄存器间数据传递、主存取数至寄存器、寄存器或主存单元清零等操作 。
2. **算术运算指令**：包含二进制定点与浮点的加、减、乘、除指令，求反、求补指令等，**用于定点或浮点的算术运算**。部分大型机还有向量运算指令，可对向量或矩阵直接求和、求积 。
3. **逻辑运算指令**：包括逻辑加、乘、按位加、逻辑移位等指令，**主要用于无符号数的位操作、代码转换、判断及运算**。移位指令分算术移位（符号位不动，低位或高位补零）和逻辑移位（所有位一起移位） 。
4. **程序控制指令**：也称转移指令。正常情况下程序按指令计数器地址顺序执行，当执行到特定指令出现不同结果时，需执行转移指令改变执行顺序，这类指令称为**条件转移指令**，转移条件包括进位标志、结果为零标志等。此外还有无条件转移指令、转子程序指令等。转移地址确定方式有**直接寻址（绝对转移）**和**相对寻址（相对转移）** 。
5. **输入输出指令**：用于启动外围设备、检查设备工作状态，**实现外部设备与CPU之间或外围设备之间的信息传送**。不同机器的输入输出指令差异大，部分机器因外部设备寄存器与存储器单元统一编址，可用取数、存数指令替代输入输出指令 。
6. **字符串处理指令**：属于非数值处理指令，包括字符串传送、转换、比较、查找等，**在文字编辑中用于处理大量字符串** 。
7. **特权指令**：是具有特殊权限的指令，**只用于操作系统或其他系统软件**，用于系统资源分配和管理，如改变系统工作方式、检测用户访问权限等 。
8. **其他指令**：包括状态寄存器置位、复位指令，测试指令，暂停指令，空操作指令等**系统控制用的特殊指令** 。 
### 4.4.2 RISC 指令系统
该节内容围绕**RISC指令系统**展开，主要介绍了其特点、典型RISC指令系统基本特征、与CISC的性能比较，以及以Power PC机为例说明其指令系统，具体如下：

1. **RISC指令系统的特点**：
    - **指令数量**：选取使用频率最高的简单指令，**指令条数少**。
    - **指令格式**：指令长度固定，**指令格式种类少**，寻址方式种类也少。
    - **操作方式**：只有**取数/存数指令访问存储器**，其余指令操作均在寄存器之间进行。
2. **典型RISC指令系统的基本特征**：通过表格列举了RISC-Ⅰ、RISC-Ⅱ、MIPS等型号的指令系统，展示了指令数、寻址方式、指令格式、通用寄存器数和主频等信息 。不同型号在指令数、寻址方式等方面存在差异，如RISC-Ⅰ指令数为31条，寻址方式有2种；而Power PC指令数为64条，寻址方式有6种。
3. **RISC与CISC的性能比较**：通过公式**P = I×C×T**（P为计算机执行程序的时间，I为机器指令数，C为每条机器指令执行所需平均机器周期数，T为每个机器周期执行时间）对比。数据显示，RISC的机器指令数I为1.2 - 1.4（相对CISC），平均机器周期数C为1.3 - 1.7，每个机器周期执行时间T小于1；CISC的I为1，C为4 - 6，T为1 。表明RISC在指令执行效率等方面有一定优势。
4. **Power PC机指令系统说明**：
    - **指令类型**：Power PC机为32位字长，有64条指令，包含整数算术、逻辑、移位/旋转指令，浮点算术指令，取数/存数指令，条件寄存器指令，转移指令五种类型。
    - **指令格式**：所有指令均为32位长，格式规整。指令前6位指定操作码，部分指令存在操作码扩展；取数/存数、算术、逻辑指令在操作码后有两个5位寄存器字段，可使用32个通用寄存器。
    - **指令特殊位及字段**：转移指令含链接(L)位、寻址方式(A)位；条件转移指令的CR位字段指定条件寄存器测试位，选项字段指向转移条件；多数计算指令含(R)位，用于指示运算结果是否记录在条件寄存器；浮点指令有三个源寄存器字段，部分指令可实现矩阵运算中的“乘—加”操作 。 
## 4.5 ARM 汇编语言
该节主要围绕**32位嵌入式ARM处理器的汇编语言**展开，具体内容如下：

1. **ARM汇编语言概述**：汇编语言是对计算机机器语言（二进制指令代码）的**符号化表示**，每一个基本汇编语句对应一条机器指令。32位嵌入式ARM处理器汇编语言的操作数使用**16个寄存器**（r0，r1～r12，SP，Ir，PC）以及**30个存储字**（字节编址，连续字地址相差4） 。
2. **ARM汇编语言指令格式**：通过表格展示了ARM汇编语言主要指令格式，涵盖**算术运算、数据传送、逻辑运算、条件转移、无条件转移**等指令类别。例如，算术运算指令**ADD**（加） 、**SUB**（减）采用三寄存器操作数，如`ADD r1,r2,r3`表示`r1=r2+r3`；数据传送指令中，**LDR**（取数至寄存器）、**STR**（自寄存器存数） 用于内存与寄存器间数据传输，如`LDR r1,[r2,#20]`表示将存储单元`[r2+20]`的数据存入`r1`；逻辑运算指令**AND**（与）、**ORR**（或） 等进行比特间逻辑操作；条件转移指令**CMP**（比较）用于条件转移的比较操作，**BEQ**（相等时转移） 等根据条件标志执行转移；无条件转移指令**B**（转移）、**BL**（转移并链接，用于子程序调用）实现程序跳转 。
3. **ARM汇编语言程序设计与翻译**：汇编语言程序设计中，用英文单词或缩写表示指令，标识符表示数据或地址，避免记忆二进制代码，且可调用操作系统程序段完成输入输出等操作。汇编语言源程序需经**“汇编器”翻译为机器语言程序**后才能被计算机硬件执行 。
4. **ARM汇编语言翻译实例**：以C语言语句`A[30]=h+A[30]`编译成的3条汇编语言指令`LDR r5,[r3,#120]` 、`ADD r5,r2,r5` 、`STR r5,[r3,#120]`为例，根据指令译码格式表，先确定各指令对应字段的操作码、寄存器等信息，用十进制数表示机器语言指令，再转换为二进制机器指令 。 